{
  "Name": "SonarAnalyzer.CSharp",
  "Rules": [
    {
      "Code": "6287",
      "Title": "HTTP responses should not be vulnerable to session fixation",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-6287",
      "Description": "User provided data, such as URL parameters, should always be considered untrusted and tainted. Constructing cookies directly from tainted data\nenables attackers to set the session identifier to a known value, allowing the attacker to share the session with the victim. Successful attacks might\nresult in unauthorized access to sensitive information, for example if the session identifier is not regenerated when the victim authenticates.\nTypically, the solution to prevent this type of attack is to restrict the cookies that can be influenced with an allow-list.\nNoncompliant Code Example\n\nusing System.Web;\nusing System.Web.Mvc;\n\n[HttpGet]\npublic ActionResult index(string val)\n{\n    Response.AddHeader(\"Set-Cookie\", val);  // Noncompliant\n    HttpCookie cookie = new HttpCookie(\"ASP.NET_SessionId\", val);  // Noncompliant\n    Response.AppendCookie(cookie);\n    return View(\"\");\n}\n\nCompliant Solution\n\nusing System.Web;\nusing System.Web.Mvc;\n\n[HttpGet]\npublic ActionResult index(string val)\n{\n    Response.AddHeader(\"X-Data\", val);\n    HttpCookie cookie = new HttpCookie(\"data\", val);\n    Response.AppendCookie(cookie);\n    return View(\"\");\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-384 - Session Fixation \n\n\n"
    },
    {
      "Code": "6096",
      "Title": "Extracting archives should not lead to zip slip vulnerabilities",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-6096",
      "Description": "File names of the entries in a zip archive should be considered untrusted, tainted and should be validated before being used for file system\noperations. Indeed, file names can contain specially crafted values, such as '../', that change the initial path and, when accessed, resolve to a path\non the filesystem where the user should normally not have access.\nA successful attack might give an attacker the ability to read, modify, or delete sensitive information from the file system and sometimes even\nexecute arbitrary operating system commands. This special case of path injection vulnerabilities is called \"zip slip\".\nThe mitigation strategy should be based on the whitelisting of allowed paths or characters.\nNoncompliant Code Example\n\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\n\nnamespace ZipSlip\n{\n    public class ZipSlipNoncompliant\n    {\n        public void ExtractEntry(IEnumerator&lt;ZipArchiveEntry&gt; entriesEnumerator, string destinationDirectory)\n        {\n            var entry = entriesEnumerator.Current;\n            var destinationPath = Path.Combine(destinationDirectory, entry.FullName);\n            entry.ExtractToFile(destinationPath); // Noncompliant\n        }\n    }\n}\n\nCompliant Solution\n\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\n\nnamespace ZipSlip\n{\n    public class ZipSlipCompliant\n    {\n        public void ExtractEntry(IEnumerator&lt;ZipArchiveEntry&gt; entriesEnumerator, string destinationDirectory)\n        {\n            var entry = entriesEnumerator.Current;\n            var destinationDirectoryFullPath = Path.GetFullPath(destinationDirectory);\n            var destinationPath = Path.Combine(destinationDirectoryFullPath, entry.FullName);\n            var destinationFullPath = Path.GetFullPath(destinationPath);\n            if (!destinationFullPath.StartsWith(destinationDirectoryFullPath))\n            {\n                throw new IOException(\"Attempting to extract archive entry outside destination directory\");\n            }\n            entry.ExtractToFile(destinationFullPath); // OK\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A1 - Broken Access Control \n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   snyk - Zip Slip Vulnerability \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-22 - Improper Limitation of a Pathname to a Restricted Directory ('Path\n  Traversal') \n   MITRE, CWE-99 - Improper Control of Resource Identifiers ('Resource Injection')\n  \n   MITRE, CWE-641 - Improper Restriction of Names for Files and Other Resources\n  \n   SANS Top 25 - Risky Resource Management \n\n\n"
    },
    {
      "Code": "5334",
      "Title": "Dynamic code execution should not be vulnerable to injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5334",
      "Description": "Applications that execute code dynamically should neutralize any externally-provided values used to construct the code. Failure to do so could\nallow an attacker to execute arbitrary code. This could enable a wide range of serious attacks like accessing/modifying sensitive information or gain\nfull system access.\nThe mitigation strategy should be based on whitelisting of allowed values or casting to safe types.\nNoncompliant Code Example\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.CodeDom.Compiler;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class DynamicCodeExecutionNoncompliantController : Controller\n    {\n        public ActionResult UnsafeCodeExecution(string code)\n        {\n            var provider = CodeDomProvider.CreateProvider(\"CSharp\");\n            var compilerParameters = new CompilerParameters { ReferencedAssemblies = { \"System.dll\", \"System.Runtime.dll\" } };\n            var compilerResults = provider.CompileAssemblyFromSource(compilerParameters, code);  // Noncompliant\n            object myInstance = compilerResults.CompiledAssembly.CreateInstance(\"MyClass\");\n            var result = (string)myInstance.GetType().GetMethod(\"MyMethod\").Invoke(myInstance, new object[0]);\n            return Content(result);\n        }\n    }\n}\n\nCompliant Solution\n\nusing Microsoft.AspNetCore.Mvc;\nusing System.CodeDom.Compiler;\nusing System.Linq;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class DynamicCodeExecutionCompliantController : Controller\n    {\n        private readonly string[] allowedInnerInvocations = { \"method1\", \"method2\" };\n\n        public ActionResult SafeCodeExecution(string innerInvocationCode)\n        {\n            // Match the input against a whitelist\n            if (!allowedInnerInvocations.Contains(innerInvocationCode))\n            {\n                return BadRequest();\n            }\n            // Code created is based on controlled template\n            var code = CreateFromTemplate(innerInvocationCode);\n\n            var provider = CodeDomProvider.CreateProvider(\"CSharp\");\n            var compilerParameters = new CompilerParameters { ReferencedAssemblies = { \"System.dll\", \"System.Runtime.dll\" } };\n            var compilerResults = provider.CompileAssemblyFromSource(compilerParameters, code);\n            object myInstance = compilerResults.CompiledAssembly.CreateInstance(\"MyClass\");\n            var result = (string)myInstance.GetType().GetMethod(\"MyMethod\").Invoke(myInstance, new object[0]);\n            return Content(result);\n        }\n\n        private string CreateFromTemplate(string innerInvocationCode)\n        {\n            // Create code to be compiled from known template using a validated input\n            // ...\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-95 - Improper Neutralization of Directives in Dynamically Evaluated\n  Code ('Eval Injection') \n   SANS Top 25 - Risky Resource Management \n\n\n"
    },
    {
      "Code": "5146",
      "Title": "HTTP request redirections should not be open to forging attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5146",
      "Description": "User provided data, such as URL parameters, POST data payloads, or cookies, should always be considered untrusted and tainted. Applications\nperforming HTTP redirects based on tainted data could enable an attacker to redirect users to a malicious site to, for example, steal login\ncredentials.\nThis problem could be mitigated in any of the following ways:\n\n   Validate the user provided data based on an allowlist and reject input not matching. \n   Redesign the application to not perform redirects based on user provided data. \n\nNoncompliant Code Example\n\nusing Microsoft.AspNetCore.Mvc;\n\npublic class HomeController : Controller\n{\n\n    public IActionResult RedirectMe(string url)\n    {\n        return Redirect(url);\n    }\n\n    public IActionResult SetLocationHeader(string url)\n    {\n        Response.Headers[\"Location\"] = url; // Noncompliant\n        return StatusCode(302);\n    }\n}\n\nCompliant Solution\n\nusing Microsoft.AspNetCore.Mvc;\n\npublic class HomeController : Controller\n{\n    private readonly string[] whiteList = { \"/\", \"/login\", \"/logout\" };\n\n    public IActionResult RedirectMe(string url)\n    {\n        // Match the incoming URL against a whitelist\n        if (!whiteList.Contains(url))\n        {\n            return BadRequest();\n        }\n\n        return Redirect(url);\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A1 - Broken Access Control \n   Microsoft Documentation ASP.NET\n  Core - Prevent Open Redirect Attacks in ASP.NET Core \n   Microsoft Documentation ASP.NET\n  MVC - Preventing Open Redirection Attacks \n   OWASP Top 10 2017 Category A5 - Broken Access Control \n   MITRE, CWE-601 - URL Redirection to Untrusted Site ('Open Redirect') \n   SANS Top 25 - Risky Resource Management \n\n\n"
    },
    {
      "Code": "5135",
      "Title": "Deserialization should not be vulnerable to injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5135",
      "Description": "User provided data such as URL parameters, POST data payloads or cookies should always be considered untrusted and tainted. Deserialization based\non data supplied by the user could result in two types of attacks:\n\n   Remote code execution attacks, where the structure of the serialized data is changed to modify the behavior of the object being unserialized.\n  \n   Parameter tampering attacks, where data is modified to escalate privileges or change for example quantity or price of products. \n\nThe best way to protect against deserialization attacks is probably to challenge the use of the deserialization mechanism in the application. They\nare cases were the use of deserialization mechanism was not justified and created breaches (CVE-2017-9785).\nIf the use of deserialization mechanisms is valid in your context, the problem could be mitigated in any of the following ways:\n\n   Instead of using a native data interchange format, use a safe, standard format such as untyped JSON or structured data approaches such as\n  Google Protocol Buffers. \n   To ensure integrity is not compromised, add a digital signature (HMAC) to the serialized data that is validated before deserialization (this is\n  only valid if the client doesn’t need to modify the serialized data) \n   As a last resort, restrict deserialization to be possible only to specific, whitelisted classes. \n\nNoncompliant Code Example\nFor XmlSerializer \nserializer, the expected type should not come from user-controlled input:\n\npublic class XmlSerializerTestCase : Controller\n{\n   public ActionResult unsecuredeserialization(string typeName)\n  {\n     // ....\n     ExpectedType obj = null;\n     Type t = Type.GetType(typeName); // typeName is user-controlled\n     XmlSerializer serializer = new XmlSerializer(t); // Noncompliant\n     obj = (ExpectedType) serializer.Deserialize(fs);\n     // ....\n   }\n}\n\nCompliant Solution\nFor XmlSerializer \nserializer:\n\npublic class XmlSerializerTestCase : Controller\n{\n   public ActionResult securedeserialization()\n  {\n     // ....\n     ExpectedType obj = null;\n     XmlSerializer serializer = new XmlSerializer(typeof(ExpectedType)); // Compliant\n     obj = (ExpectedType) serializer.Deserialize(fs);\n     // ....\n   }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A8 - Software and Data\n  Integrity Failures \n   OWASP Top 10 2017 Category A8 - Insecure Deserialization\n  \n   MITRE, CWE-134 - Use of Externally-Controlled Format String \n   MITRE, CWE-502 - Deserialization of Untrusted Data \n   SANS Top 25 - Risky Resource Management \n\n\n"
    },
    {
      "Code": "5131",
      "Title": "Endpoints should not be vulnerable to reflected cross-site scripting (XSS) attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5131",
      "Description": "User provided data, such as URL parameters, POST data payloads, or cookies, should always be considered untrusted and tainted. Endpoints reflecting\nback tainted data could allow attackers to inject code that would eventually be executed in the user’s browser. This could enable a wide range of\nserious attacks like accessing/modifying sensitive information or impersonating other users.\nTypically, the solution is one of the following:\n\n   Validate user provided data based on a whitelist and reject input that’s not whitelisted. \n   Sanitize user provided data from any characters that can be used for malicious purposes. \n   Encode user provided data being reflected as output. Adjust the encoding to the output context so that, for example, HTML encoding is used for\n  HTML content, HTML attribute encoding is used for attribute values, and JavaScript encoding is used for server-generated JavaScript. \n\nWhen sanitizing or encoding data, it is recommended to only use libraries specifically designed for security purposes. Also, make sure that the\nlibrary you are using is being actively maintained and is kept up-to-date with the latest discovered vulnerabilities.\nNoncompliant Code Example\n\nstring name = Request.QueryString[\"name\"];\nResponse.Write(\"Hello \" + name); // Noncompliant\n\nCompliant Solution\n\nstring name = Request.QueryString[\"name\"];\nname = System.Web.Security.AntiXss.AntiXssEncoder.HtmlEncode(name, true);\nResponse.Write(\"Hello \" + name);\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Cheat Sheet - XSS\n  Prevention Cheat Sheet \n   OWASP Top 10 2017 Category A7 - Cross-Site Scripting\n  (XSS) \n   MITRE, CWE-79 - Improper Neutralization of Input During Web Page Generation\n  ('Cross-site Scripting') \n   SANS Top 25 - Insecure Interaction Between Components \n\n\n"
    },
    {
      "Code": "3884",
      "Title": "\"CoSetProxyBlanket\" and \"CoInitializeSecurity\" should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3884",
      "Description": "CoSetProxyBlanket and CoInitializeSecurity both work to set the permissions context in which the process invoked\nimmediately after is executed. Calling them from within that process is useless because it’s too late at that point; the permissions context has\nalready been set.\nSpecifically, these methods are meant to be called from non-managed code such as a C++ wrapper that then invokes the managed, i.e. C# or VB.NET,\ncode.\nNoncompliant Code Example\n\n[DllImport(\"ole32.dll\")]\nstatic extern int CoSetProxyBlanket([MarshalAs(UnmanagedType.IUnknown)]object pProxy, uint dwAuthnSvc, uint dwAuthzSvc,\n\t[MarshalAs(UnmanagedType.LPWStr)] string pServerPrincName, uint dwAuthnLevel, uint dwImpLevel, IntPtr pAuthInfo,\n\tuint dwCapabilities);\n\npublic enum RpcAuthnLevel\n{\n\tDefault = 0,\n\tNone = 1,\n\tConnect = 2,\n\tCall = 3,\n\tPkt = 4,\n\tPktIntegrity = 5,\n\tPktPrivacy = 6\n}\n\npublic enum RpcImpLevel\n{\n\tDefault = 0,\n\tAnonymous = 1,\n\tIdentify = 2,\n\tImpersonate = 3,\n\tDelegate = 4\n}\n\npublic enum EoAuthnCap\n{\n\tNone = 0x00,\n\tMutualAuth = 0x01,\n\tStaticCloaking = 0x20,\n\tDynamicCloaking = 0x40,\n\tAnyAuthority = 0x80,\n\tMakeFullSIC = 0x100,\n\tDefault = 0x800,\n\tSecureRefs = 0x02,\n\tAccessControl = 0x04,\n\tAppID = 0x08,\n\tDynamic = 0x10,\n\tRequireFullSIC = 0x200,\n\tAutoImpersonate = 0x400,\n\tNoCustomMarshal = 0x2000,\n\tDisableAAA = 0x1000\n}\n\n[DllImport(\"ole32.dll\")]\npublic static extern int CoInitializeSecurity(IntPtr pVoid, int cAuthSvc, IntPtr asAuthSvc, IntPtr pReserved1,\n\tRpcAuthnLevel level, RpcImpLevel impers, IntPtr pAuthList, EoAuthnCap dwCapabilities, IntPtr pReserved3);\n\nstatic void Main(string[] args)\n{\n\tvar hres1 = CoSetProxyBlanket(null, 0, 0, null, 0, 0, IntPtr.Zero, 0); // Noncompliant\n\n\tvar hres2 = CoInitializeSecurity(IntPtr.Zero, -1, IntPtr.Zero, IntPtr.Zero, RpcAuthnLevel.None,\n\t\tRpcImpLevel.Impersonate, IntPtr.Zero, EoAuthnCap.None, IntPtr.Zero); // Noncompliant\n}\n\nSee\n\n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n\n\n"
    },
    {
      "Code": "3649",
      "Title": "Database queries should not be vulnerable to injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3649",
      "Description": "User provided data, such as URL parameters, should always be considered untrusted and tainted. Constructing SQL queries directly from tainted data\nenables attackers to inject specially crafted values that change the initial meaning of the query itself. Successful database query injection attacks\ncan read, modify, or delete sensitive information from the database and sometimes even shut it down or execute arbitrary operating system\ncommands.\nTypically, the solution is to use prepared statements and to bind variables to SQL query parameters with dedicated methods like\nsetParameter, which ensures that user provided data will be properly escaped. Another solution is to validate every parameter used to\nbuild the query. This can be achieved by transforming string values to primitive types or by validating them against a white list of accepted\nvalues.\nNoncompliant Code Example\n\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing WebApplication1.Controllers;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC3649SQLiNoncompliant : Controller\n    {\n        private readonly UserAccountContext _context;\n\n        public RSPEC3649SQLiNoncompliant(UserAccountContext context)\n        {\n            _context = context;\n        }\n\n        public IActionResult Authenticate(string user)\n        {\n            string query = \"SELECT * FROM Users WHERE Username = '\" + user + \"'\";\n\n            // an attacker can bypass authentication by setting user to this special value\n            // user = \"' or 1=1 or ''='\";\n\n            var userExists = false;\n            if (_context.Database.ExecuteSqlCommand(query) &gt; 0) // Noncompliant\n            {\n                userExists = true;\n            }\n\n            return Content(userExists ? \"success\" : \"fail\");\n        }\n    }\n}\n\nCompliant Solution\n\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing WebApplication1.Controllers;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC3649SQLiCompliant : Controller\n    {\n        private readonly UserAccountContext _context;\n\n        public RSPEC3649SQLiCompliant(UserAccountContext context)\n        {\n            _context = context;\n        }\n\n        public IActionResult Authenticate(string user)\n        {\n            var query = \"SELECT * FROM Users WHERE Username = {0}\"; // Safe\n\n            var userExists = false;\n            if  (_context.Database.ExecuteSqlCommand(query, user) &gt; 0)\n            {\n                userExists = true;\n            }\n\n            return Content(userExists ? \"success\" : \"fail\");\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-89 - Improper Neutralization of Special Elements used in an SQL Command\n  \n   MITRE, CWE-564 - SQL Injection: Hibernate \n   MITRE, CWE-943 - Improper Neutralization of Special Elements in Data Query Logic\n  \n   OWASP SQL Injection Prevention Cheat\n  Sheet \n   SANS Top 25 - Insecure Interaction Between Components \n\n\n"
    },
    {
      "Code": "2755",
      "Title": "XML parsers should not be vulnerable to XXE attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2755",
      "Description": "XML standard allows the use of entities, declared in the DOCTYPE of the document, which can be internal or external.\nWhen parsing the XML file, the content of the external entities is retrieved from an external storage such as the file system or network, which may\nlead, if no restrictions are put in place, to arbitrary file disclosures or server-side request forgery (SSRF) vulnerabilities.\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!DOCTYPE person [\n  &lt;!ENTITY file SYSTEM \"file:///etc/passwd\"&gt;\n  &lt;!ENTITY ssrf SYSTEM \"https://internal.network/sensitive_information\"&gt;\n]&gt;\n\n&lt;person&gt;\n  &lt;name&gt;&amp;file;&lt;/name&gt;\n  &lt;city&gt;&amp;ssrf;&lt;/city&gt;\n  &lt;age&gt;18&lt;/age&gt;\n&lt;/person&gt;\n\nIt’s recommended to limit resolution of external entities by using one of these solutions:\n\n   If DOCTYPE is not necessary, completely disable all DOCTYPE declarations. \n   If external entities are not necessary, completely disable their declarations. \n   If external entities are necessary then:\n    \n       Use XML processor features, if available, to authorize only required protocols (eg: https). \n       And use an entity resolver (and optionally an XML Catalog) to resolve only trusted entities. \n      \n\nNoncompliant Code Example\nSystem.Xml.XmlDocument\n\n// .NET Framework &lt; 4.5.2\nXmlDocument parser = new XmlDocument(); // Noncompliant: XmlDocument is not safe by default\nparser.LoadXml(\"xxe.xml\");\n\nor\n\n// .NET Framework 4.5.2+\nXmlDocument parser = new XmlDocument();\nparser.XmlResolver = new XmlUrlResolver(); // Noncompliant: XmlDocument.XmlResolver configured with XmlUrlResolver that makes it unsafe\nparser.LoadXml(\"xxe.xml\");\n\nSystem.Xml.XmlTextReader\n\n// .NET Framework &lt; 4.5.2\nXmlTextReader reader = new XmlTextReader(\"xxe.xml\"); // Noncompliant: XmlTextReady is not safe by default\nwhile (reader.Read())\n{ ... }\n\nor\n\n// .NET Framework 4.5.2+\nXmlTextReader reader = new XmlTextReader(\"xxe.xml\");\nreader.XmlResolver = new XmlUrlResolver(); // Noncompliant: XmlTextRead.XmlResolver configured with XmlUrlResolver that makes it unsafe\nwhile (reader.Read())\n{ ... }\n\nSystem.Xml.XmlReader\n\n// .NET Framework 4.5.2+\nXmlReaderSettings settings = new XmlReaderSettings();\nsettings.DtdProcessing = DtdProcessing.Parse;\nsettings.XmlResolver = new XmlUrlResolver();\nXmlReader reader = XmlReader.Create(\"xxe.xml\", settings); // Noncompliant: XmlReader is safe by default and becomes unsafe if DtdProcessing = Parse and XmlResolver is not null\nwhile (reader.Read())\n{ ... }\n\nSystem.Xml.XPath.XPathDocument\n\n// prior to .NET 4.5.2\nXPathDocument doc = new XPathDocument(\"example.xml\"); // Noncompliant\nXPathNavigator nav = doc.CreateNavigator();\nstring xml = nav.InnerXml.ToString();\n\nCompliant Solution\nSystem.Xml.XmlDocument\n\nXmlDocument parser = new XmlDocument();\nparser.XmlResolver = null; // Compliant: XmlResolver has been set to null\nparser.LoadXml(\"xxe.xml\");\n\nor\n\nXmlDocument parser = new XmlDocument(); // Compliant: XmlDocument is safe by default in  .NET Framework 4.5.2+ because XmlResolver is set by default to null\nparser.LoadXml(\"xxe.xml\");\n\nSystem.Xml.XmlTextReader\n\n// .NET 4.5.2+\nXmlTextReader reader = new XmlTextReader(\"xxe.xml\"); // Compliant: XmlTextReader is safe by default in  .NET Framework 4.5.2+ because XmlResolver is set by default to null\nwhile (reader.Read())\n{ ... }\n\n// .NET 4.0 to .NET 4.5.1\nXmlTextReader reader = new XmlTextReader(\"xxe.xml\");\nreader.DtdProcessing = DtdProcessing.Prohibit; // Compliant: XmlTextReader is safe by default in  .NET Framework 4.5.2+ because XmlResolver is set by default to null\n\n// &lt; .NET 4.0\nXmlTextReader reader = new XmlTextReader(stream);\nreader.ProhibitDtd = true; // Compliant: default is false\n\nSystem.Xml.XmlReader\n\nXmlReader reader = XmlReader.Create(\"xxe.xml\"); // Compliant: XmlReader is safe by default\nwhile (reader.Read())\n{ ... }\n\nSystem.Xml.XPath.XPathDocument\n\n// prior to .NET 4.5.2\nXmlReader reader = XmlReader.Create(\"example.xml\");\nXPathDocument doc = new XPathDocument(reader); // Compliant: XPathDocument is safe when being given a safe XmlReader\nXPathNavigator nav = doc.CreateNavigator();\nstring xml = nav.InnerXml.ToString();\n\nSee\n\n   OWASP Top 10 2017 Category A4 - XML External Entities\n  (XXE) \n   OWASP XXE Prevention Cheat\n  Sheet \n   MITRE, CWE-611 - Information Exposure Through XML External Entity Reference \n   MITRE, CWE-827 - Improper Control of Document Type Definition \n\n\n"
    },
    {
      "Code": "2115",
      "Title": "A secure password should be used when connecting to a database",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2115",
      "Description": "When relying on the password authentication mode for the database connection, a secure password should be chosen.\nThis rule raises an issue when an empty password is used.\nNoncompliant Code Example\n\nprotected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n{\n  optionsBuilder.UseSqlServer(\"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=\"); // Noncompliant\n}\n\nIn Web.config\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"myConnection\" connectionString=\"Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=\" /&gt; &lt;!-- Noncompliant --&gt;\n  &lt;/connectionStrings&gt;\n&lt;/configuration&gt;\n\nCompliant Solution\n\nprotected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n{\n  optionsBuilder.UseSqlServer(\"Server=myServerAddress;Database=myDataBase;Integrated Security=True\");\n}\n\nIn Web.config\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;connectionStrings&gt;\n    &lt;add name=\"myConnection\" connectionString=\"Server=myServerAddress;Database=myDataBase;Integrated Security=True\" /&gt;\n  &lt;/connectionStrings&gt;\n&lt;/configuration&gt;\n\nSee\n\n   OWASP Top 10 2017 Category A2 - Broken\n  Authentication \n   OWASP Top 10 2017 Category A3 - Sensitive Data\n  Exposure \n   MITRE, CWE-521 - Weak Password Requirements \n\n\n"
    },
    {
      "Code": "2091",
      "Title": "XPath expressions should not be vulnerable to injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2091",
      "Description": "User provided data, such as URL parameters, should always be considered untrusted and tainted. Constructing XPath expressions directly from tainted\ndata enables attackers to inject specially crafted values that changes the initial meaning of the expression itself. Successful XPath injection\nattacks can read sensitive information from XML documents.\nNoncompliant Code Example\n\nusing System;\nusing System.Xml;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2091XPathInjectionNoncompliant : Controller\n    {\n        public XmlDocument doc { get; set; }\n\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult Authenticate(string user, string pass)\n        {\n            String expression = \"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\"; // Unsafe\n\n            // An attacker can bypass authentication by setting user to this special value\n            // user = \"' or 1=1 or ''='\";\n\n            return Content(doc.SelectSingleNode(expression) != null ? \"success\" : \"fail\"); // Noncompliant\n        }\n\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Text.RegularExpressions;\nusing System.Xml;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2091XPathInjectionCompliant : Controller\n    {\n        public XmlDocument doc { get; set; }\n\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult Authenticate(string user, string pass)\n        {\n            // Restrict the username and password to letters only\n            if (!Regex.IsMatch(user, \"^[a-zA-Z]+$\") || !Regex.IsMatch(pass, \"^[a-zA-Z]+$\"))\n            {\n                return BadRequest();\n            }\n\n            String expression = \"/users/user[@name='\" + user + \"' and @pass='\" + pass + \"']\"; // Compliant\n            return Content(doc.SelectSingleNode(expression) != null ? \"success\" : \"fail\");\n        }\n\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-643 - Improper Neutralization of Data within XPath Expressions \n\n\n"
    },
    {
      "Code": "2083",
      "Title": "I/O function calls should not be vulnerable to path injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2083",
      "Description": "User provided data, such as URL parameters, POST data payloads, or cookies, should always be considered untrusted and tainted. Constructing file\nsystem paths directly from tainted data could enable an attacker to inject specially crafted values, such as '../', that change the\ninitial path and, when accessed, resolve to a path on the filesystem where the user should normally not have access.\nA successful attack might give an attacker the ability to read, modify, or delete sensitive information from the file system and sometimes even\nexecute arbitrary operating system commands. This is often referred to as a \"path traversal\" or \"directory traversal\" attack.\nThe mitigation strategy should be based on the whitelisting of allowed paths or characters.\nNoncompliant Code Example\n\nusing System;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2083IOInjectionNoncompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult DeleteFile(string fileName)\n        {\n            System.IO.File.Delete(fileName); // Noncompliant\n\n            return Content(\"File \" + fileName + \" deleted\");\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.IO;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2083IOInjectionCompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult DeleteFile(string fileName)\n        {\n            string destDirectory = \"~/CustomersData/\";\n\n            string destFileName = Path.GetFullPath(System.IO.Path.Combine(destDirectory, fileName));\n            string fullDestDirPath = Path.GetFullPath(destDirectory + Path.DirectorySeparatorChar);\n\n            if (!destFileName.StartsWith(fullDestDirPath, StringComparison.Ordinal))\n            {\n                System.IO.File.Delete(destFileName); // Compliant\n                return Content(\"File \" + fileName + \" deleted\");\n            } else\n            {\n                return BadRequest();\n            }\n        }\n\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A1 - Broken Access Control \n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   OWASP Top 10 2017 Category A5 - Broken Access Control \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-22 - Improper Limitation of a Pathname to a Restricted Directory ('Path\n  Traversal') \n   MITRE, CWE-99 - Improper Control of Resource Identifiers ('Resource Injection')\n  \n   MITRE, CWE-641 - Improper Restriction of Names for Files and Other Resources\n  \n   SANS Top 25 - Risky Resource Management \n\n\n"
    },
    {
      "Code": "2078",
      "Title": "LDAP queries should not be vulnerable to injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2078",
      "Description": "User provided data such as URL parameters should always be considered as untrusted and tainted. Constructing LDAP names or search filters directly\nfrom tainted data enables attackers to inject specially crafted values that changes the initial meaning of the name or filter itself. Successful LDAP\ninjections attacks can read, modify or delete sensitive information from the directory service.\nWithin LDAP names, the special characters ' ', '#', '\"', '+', ',',\n';', '&lt;', '&gt;', '\\' and null must be escaped according to RFC 4514, for example\nby replacing them with the backslash character '\\' followed by the two hex digits corresponding to the ASCII code of the character to be\nescaped. Similarly, LDAP search filters must escape a different set of special characters (including but not limited to '*',\n'(', ')', '\\' and null) according to RFC 4515.\nNoncompliant Code Example\n\nusing System.DirectoryServices;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2078LDAPInjectionNoncompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public DirectorySearcher ds { get; set; }\n\n        public IActionResult Authenticate(string user, string pass)\n        {\n            ds.Filter = \"(&amp;(uid=\" + user + \")(userPassword=\" + pass + \"))\"; // Noncompliant\n\n            // If the special value \"*)(uid=*))(|(uid=*\" is passed as user, authentication is bypassed\n            // Indeed, if it is passed as a user, the filter becomes:\n            // (&amp;(uid=*)(uid=*))(|(uid=*)(userPassword=...))\n            // as uid=* match all users, it is equivalent to:\n            // (|(uid=*)(userPassword=...))\n            // again, as uid=* match all users, the filter becomes useless\n\n            return Content(ds.FindOne() != null ? \"success\" : \"fail\");\n        }\n    }\n}\n\nCompliant Solution\n\nusing System.DirectoryServices;\nusing System.Text.RegularExpressions;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2078LDAPInjectionCompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public DirectorySearcher ds { get; set; }\n\n        public IActionResult Authenticate(string user, string pass)\n        {\n            // restrict the username and password to letters only\n            if (!Regex.IsMatch(user, \"^[a-zA-Z]+$\") || !Regex.IsMatch(pass, \"^[a-zA-Z]+$\"))\n            {\n                return BadRequest();\n            }\n\n            ds.Filter = \"(&amp;(uid=\" + user + \")(userPassword=\" + pass + \"))\"; // Now safe\n            return Content(ds.FindOne() != null ? \"success\" : \"fail\");\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   RFC 4514 - LDAP: String Representation of Distinguished Names \n   RFC 4515 - LDAP: String Representation of Search Filters \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-90 - Improper Neutralization of Special Elements used in an LDAP Query\n  ('LDAP Injection') \n\n\n"
    },
    {
      "Code": "2076",
      "Title": "OS commands should not be vulnerable to command injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2076",
      "Description": "Applications that allow execution of operating system commands from user-controlled data should control the command to execute, otherwise an\nattacker can inject arbitrary commands that will compromise the underlying operating system.\nThe mitigation strategy can be based on a list of authorized and safe commands to execute and when a shell is spawned to sanitize shell\nmeta-characters. Keep in mind that when a single argument to the command is user-controlled and shell-metachars are sanitized, it can still lead to\nvulnerabilities if the attacker can inject a dangerous option supported by the command, such as -exec available with find, in that case, mark end of option processing on the command line using -- (double-dash)\nor restrict options to only trusted values.\nNoncompliant Code Example\n\nusing System.Diagnostics;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2076OSCommandInjectionNoncompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult Run(string binary)\n        {\n            // If the value \"/sbin/shutdown\" is passed as binary and the web server is running as root,\n            // then the machine running the web server will be shut down and become unavailable for future requests\n\n            Process p = new Process();\n            p.StartInfo.FileName = binary; // Noncompliant\n            p.StartInfo.RedirectStandardOutput = true;\n            p.Start();\n            string output = p.StandardOutput.ReadToEnd();\n            p.Dispose();\n\n            return View();\n        }\n    }\n}\n\nCompliant Solution\n\nusing System.Diagnostics;\nusing System.Text.RegularExpressions;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2076OSCommandInjectionCompliantControllerController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult Run(string binary)\n        {\n            if (binary.Equals(\"/usr/bin/ls\") || binary.Equals(\"/usr/bin/cat\"))\n            {\n               // only ls and cat commands are authorized\n\n              Process p = new Process();\n              p.StartInfo.FileName = binary; // Compliant\n              p.StartInfo.RedirectStandardOutput = true;\n              p.Start();\n              string output = p.StandardOutput.ReadToEnd();\n              p.Dispose();\n            }\n\n            return View();\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP OS Command Injection Defense Cheat\n  Sheet \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-78 - Improper Neutralization of Special Elements used in an OS Command\n  \n   SANS Top 25 - Insecure Interaction Between Components \n\n\n"
    },
    {
      "Code": "4159",
      "Title": "Classes should implement their \"ExportAttribute\" interfaces",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4159",
      "Description": "In the Attributed Programming Model, the ExportAttribute declares that a part \"exports\", or provides to the composition container, an\nobject that fulfills a particular contract. During composition, parts with imports that have matching contracts will have those dependencies filled by\nthe exported object.\nIf the type doesn’t implement the interface it is exporting there will be an issue at runtime (either a cast exception or just a container not\nfilled with the exported type) leading to unexpected behaviors/crashes.\nThe rule raises an issue when a class doesn’t implement or inherit the type declared in the ExportAttribute.\nNoncompliant Code Example\n\n[Export(typeof(ISomeType))]\npublic class SomeType // Noncompliant; doesn't implement 'ISomeType'.\n{\n}\n\nCompliant Solution\n\n[Export(typeof(ISomeType))]\npublic class SomeType : ISomeType\n{\n}\n\n\n"
    },
    {
      "Code": "3889",
      "Title": "Neither \"Thread.Resume\" nor \"Thread.Suspend\" should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3889",
      "Description": "Thread.Suspend and Thread.Resume can give unpredictable results, and both methods have been deprecated. Indeed, if\nThread.Suspend is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock. Other safer\nsynchronization mechanisms should be used, such as Monitor, Mutex, and Semaphore.\nNoncompliant Code Example\n\nstatic void Main(string[] args)\n{\n  // ...\n  Thread.CurrentThread.Suspend(); // Noncompliant\n  Thread.CurrentThread.Resume(); // Noncompliant\n}\n\nSee\n\n   Thread.Resume Method () \n   Thread.Suspend Method () \n\n\n"
    },
    {
      "Code": "3869",
      "Title": "\"SafeHandle.DangerousGetHandle\" should not be called",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3869",
      "Description": "Not surprisingly, the SafeHandle.DangerousGetHandle method is dangerous. That’s because it may not return a valid handle. Using it can\nlead to leaks and vulnerabilities. While it is possible to use the method successfully, it’s extremely difficult to do correctly, so the method should\nsimply be avoided altogether.\nNoncompliant Code Example\n\nstatic void Main(string[] args)\n{\n    System.Reflection.FieldInfo fieldInfo = ...;\n    SafeHandle handle = (SafeHandle)fieldInfo.GetValue(rKey);\n    IntPtr dangerousHandle = handle.DangerousGetHandle();  // Noncompliant\n}\n\n\n"
    },
    {
      "Code": "3464",
      "Title": "Type inheritance should not be recursive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3464",
      "Description": "Recursion is acceptable in methods, where you can break out of it. But with class types, you end up with code that will compile but not run if you\ntry to instantiate the class.\nNoncompliant Code Example\n\nclass C1&lt;T&gt;\n{\n}\nclass C2&lt;T&gt; : C1&lt;C2&lt;C2&lt;T&gt;&gt;&gt; // Noncompliant\n{\n}\n\n...\nvar c2 = new C2&lt;int&gt;();\n\n\n"
    },
    {
      "Code": "2930",
      "Title": "\"IDisposables\" should be disposed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2930",
      "Description": "When writing managed code, you don’t need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency\nreasons, some objects such as Bitmap use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have\npotentially huge unmanaged memory footprints, but will have tiny managed ones. Unfortunately, the garbage collector only sees the tiny managed\nfootprint, and fails to reclaim the unmanaged memory (by calling Bitmap's finalizer method) in a timely fashion.\nMoreover, memory is not the only system resource which needs to be managed in a timely fashion: The operating system can only handle having so many\nfile descriptors (e.g. FileStream) or sockets (e.g. WebClient) open at any given time. Therefore, it is important to\nDispose of them as soon as they are no longer needed, rather than relying on the garbage collector to call these objects' finalizers at\nsome nondeterministic point in the future.\nThis rule tracks private fields and local variables of the following IDisposable types, which are never disposed, closed,\naliased, returned, or passed to other methods.\n\n   System.IO namespace\n    \n       System.IO.FileStream \n       System.IO.StreamReader \n       System.IO.StreamWriter \n      \n   System.Net namespace\n    \n       System.Net.WebClient \n      \n   System.Net.Sockets namespace\n    \n       System.Net.Sockets.Socket \n       System.Net.Sockets.TcpClient \n       System.Net.Sockets.UdpClient \n      \n   System.Drawing namespace\n    \n       System.Drawing.Image \n       System.Drawing.Bitmap \n      \n\nwhich are either instantiated directly using the new operator, or using one of the following factory methods:\n\n   System.IO.File.Create() \n   System.IO.File.Open() \n   System.Drawing.Image.FromFile() \n   System.Drawing.Image.FromStream() \n\non both private fields and local variables.\nNoncompliant Code Example\n\npublic class ResourceHolder\n{\n  private FileStream fs; // Noncompliant; Dispose or Close are never called\n\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n\n  public void WriteToFile(string path, string text)\n  {\n    var fs = new FileStream(path, FileMode.Open); // Noncompliant\n    var bytes = Encoding.UTF8.GetBytes(text);\n    fs.Write(bytes, 0, bytes.Length);\n  }\n}\n\nCompliant Solution\n\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n\n  public void Dispose()\n  {\n    this.fs.Dispose();\n  }\n\n  public void WriteToFile(string path, string text)\n  {\n    using (var fs = new FileStream(path, FileMode.Open))\n    {\n      var bytes = Encoding.UTF8.GetBytes(text);\n      fs.Write(bytes, 0, bytes.Length);\n    }\n  }\n}\n\nExceptions\nIDisposable variables returned from a method or passed to other methods are ignored, as are local IDisposables that are\ninitialized with other IDisposables.\n\npublic Stream WriteToFile(string path, string text)\n{\n  var fs = new FileStream(path, FileMode.Open); // Compliant, because it is returned\n  var bytes = Encoding.UTF8.GetBytes(text);\n  fs.Write(bytes, 0, bytes.Length);\n  return fs;\n}\n\npublic void ReadFromStream(Stream s)\n{\n  var sr = new StreamReader(s); // Compliant as it would close the underlying stream.\n  // ...\n}\n\nSee\n\n   MITRE, CWE-459 - Incomplete Cleanup \n\n\n"
    },
    {
      "Code": "2857",
      "Title": "SQL keywords should be delimited by whitespace",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2857",
      "Description": "Badly formed SQL is likely to cause errors at runtime.\nThis rule raises an issue when the spacing around SQL keywords appears to be missing.\nNoncompliant Code Example\n\nstring select = \"SELECT p.fname, p.lname, p.street1, p.street2, p.city, p.state, p.zip\" +\n        \"FROM person p\" +  // Noncompliant; concatenates to: p.zipFROM\n        \"WHERE p.id = @ID\";  // Noncompliant; concatenates to: pWHERE\n\nCompliant Solution\n\nstring select = \"SELECT p.fname, p.lname, p.street1, p.street2, p.city, p.state, p.zip\" +\n    \" FROM person p\" +\n    \" WHERE p.id = @ID\";\n\n\n"
    },
    {
      "Code": "2275",
      "Title": "Composite format strings should not lead to unexpected behavior at runtime",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2275",
      "Description": "Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected\nbehaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of\nString.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine,\nTextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String,\u2002Object[]),\nTrace.TraceError(String,\u2002Object[]), Trace.TraceInformation(String,\u2002Object[]),\nTrace.TraceWarning(String,\u2002Object[]) and TraceSource.TraceInformation(String,\u2002Object[]).\nNoncompliant Code Example\n\ns = string.Format(\"[0}\", arg0);\ns = string.Format(\"{{0}\", arg0);\ns = string.Format(\"{0}}\", arg0);\ns = string.Format(\"{-1}\", arg0);\ns = string.Format(\"{0} {1}\", arg0);\n\nCompliant Solution\n\ns = string.Format(\"{0}\", 42); // Compliant\ns = string.Format(\"{0,10}\", 42); // Compliant\ns = string.Format(\"{0,-10}\", 42); // Compliant\ns = string.Format(\"{0:0000}\", 42); // Compliant\ns = string.Format(\"{2}-{0}-{1}\", 1, 2, 3); // Compliant\ns = string.Format(\"no format\"); // Compliant\n\nExceptions\n\n   No issue is raised if the format string is not a const. \n\n\nvar pattern = \"{0} {1} {2}\";\nvar res = string.Format(pattern, 1, 2); // Compliant, not const string are not recognized\n\n\n   No issue is raised if the argument is not an inline creation array. \n\n\nvar array = new int[] {};\nvar res = string.Format(\"{0} {1}\", array); // Compliant we don't know the size of the array\n\n\n   This rule doesn’t check whether the format specifier (defined after the :) is actually valid. \n\n\n"
    },
    {
      "Code": "2190",
      "Title": "Recursion should not be infinite",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2190",
      "Description": "Recursion happens when control enters a loop that has no exit. This can happen a method invokes itself, when a pair of methods invoke each other,\nor when goto statements are used to move between two segments of code. It can be a useful tool, but unless the method includes a\nprovision to break out of the recursion and return, the recursion will continue until the stack overflows and the program crashes.\nNoncompliant Code Example\n\nint Pow(int num, int exponent)   // Noncompliant; no condition under which pow isn't re-called\n{\n  num = num * Pow(num, exponent-1);\n  return num;  // this is never reached\n}\n\nvoid InternalRecursion(int i)\n{\n  start:\n    goto end;\n  end:\n    goto start; // Noncompliant; there's no way to break out of this method\n}\n\nCompliant Solution\n\nint Pow(int num, int exponent)\n{\n  if (exponent &gt; 1) // recursion now conditional and stop-able\n  {\n    num = num * Pow(num, exponent-1);\n  }\n  return num;\n}\n\n\n"
    },
    {
      "Code": "1048",
      "Title": "Destructors should not throw exceptions",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1048",
      "Description": "If Finalize or an override of Finalize throws an exception, and the runtime is not hosted by an application that overrides the default policy, the\nruntime terminates the process immediately without graceful cleanup (finally blocks and finalizers are not executed). This behavior ensures process\nintegrity if the finalizer cannot free or destroy resources.\nThe rule reports on throw statements used in finalizers.\nNoncompliant Code Example\n\nclass MyClass\n{\n    ~MyClass()\n    {\n        throw new NotImplementedException(); // Noncompliant\n    }\n}\n\nCompliant Solution\n\nclass MyClass\n{\n    ~MyClass()\n    {\n        // no throw\n    }\n}\n\n\n"
    },
    {
      "Code": "2068",
      "Title": "Hard-coded credentials are security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2068",
      "Description": "Because it is easy to extract strings from an application source code or binary, credentials should not be hard-coded. This is particularly true\nfor applications that are distributed or that are open-source.\nIn the past, it has led to the following vulnerabilities:\n\n   CVE-2019-13466 \n   CVE-2018-15389 \n\nCredentials should be stored outside of the code in a configuration file, a database, or a management service for secrets.\nThis rule flags instances of hard-coded credentials used in database and LDAP connections. It looks for hard-coded credentials in connection\nstrings, and for variable names that match any of the patterns from the provided list.\nIt’s recommended to customize the configuration of this rule with additional credential words such as \"oauthToken\", \"secret\", …​\nAsk Yourself Whether\n\n   Credentials allows access to a sensitive component like a database, a file storage, an API or a service. \n   Credentials are used in production environments. \n   Application re-distribution is required before updating the credentials. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Store the credentials in a configuration file that is not pushed to the code repository. \n   Store the credentials in a database. \n   Use your cloud provider’s service for managing secrets. \n   If the a password has been disclosed through the source code: change it. \n\nSensitive Code Example\n\nstring username = \"admin\";\nstring password = \"Admin123\"; // Sensitive\nstring usernamePassword  = \"user=admin&amp;password=Admin123\"; // Sensitive\nstring url = \"scheme://user:Admin123@domain.com\"; // Sensitive\n\nCompliant Solution\n\nstring username = \"admin\";\nstring password = GetEncryptedPassword();\nstring usernamePassword = string.Format(\"user={0}&amp;password={1}\", GetEncryptedUsername(), GetEncryptedPassword());\nstring url = $\"scheme://{username}:{password}@domain.com\";\n\nstring url2 = \"http://guest:guest@domain.com\"; // Compliant\nconst string Password_Property = \"custom.password\"; // Compliant\n\nExceptions\n\n   Issue is not raised when URI username and password are the same. \n   Issue is not raised when searched pattern is found in variable name and value. \n\nSee\n\n   OWASP Top 10 2017 Category A2 - Broken Authentication \n   MITRE, CWE-798 - Use of Hard-coded Credentials \n   MITRE, CWE-259 - Use of Hard-coded Password \n   SANS Top 25 - Porous Defenses \n   Derived from FindSecBugs rule Hard Coded Password \n\n\n"
    },
    {
      "Code": "3877",
      "Title": "Exceptions should not be thrown from unexpected methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3877",
      "Description": "It is expected that some methods should be called with caution, but others, such as ToString, are expected to \"just work\". Throwing an\nexception from such a method is likely to break callers' code unexpectedly.\nAn issue is raised when an exception is thrown from any of the following:\n\n   Event accessors \n   Object.Equals \n   IEquatable.Equals \n   GetHashCode \n   ToString \n   static constructors \n   Module initializers \n   IDisposable.Dispose \n   operators ==, !=, &lt;, &gt;, &lt;=, &gt;= \n   implicit cast operators \n\nNoncompliant Code Example\n\npublic override string ToString()\n{\n  if (string.IsNullOrEmpty(Name))\n  {\n    throw new ArgumentException(\"...\");  // Noncompliant\n  }\n  //...\n\nExceptions\nSystem.NotImplementedException and its derivatives are ignored.\nSystem.InvalidOperationException, System.NotSupportedException, and System.ArgumentException and their\nderivatives are ignored in event accessors.\n\n"
    },
    {
      "Code": "3875",
      "Title": "\"operator==\" should not be overloaded on reference types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3875",
      "Description": "The use of == to compare two objects is expected to do a reference comparison. That is, it is expected to return true if\nand only if they are the same object instance. Overloading the operator to do anything else will inevitably lead to the introduction of bugs by\ncallers. On the other hand, overloading it to do exactly that is pointless; that’s what == does by default.\nNoncompliant Code Example\n\npublic static bool operator== (MyType x, MyType y) // Noncompliant\n{\n\nExceptions\n\n   Classes with overloaded operator + or operator - methods are ignored. \n   Classes that implement IComparable&lt;T&gt; or IEquatable&lt;T&gt; most probably behave as a value-type objects and\n  so are ignored. \n\n\n"
    },
    {
      "Code": "3443",
      "Title": "Type should not be examined on \"System.Type\" instances",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3443",
      "Description": "If you call GetType() on a Type variable, the return value will always be typeof(System.Type). So there’s no\nreal point in making that call. The same applies to passing a type argument to IsInstanceOfType. In both cases the results are entirely\npredictable.\nNoncompliant Code Example\n\nvar intType = typeof(int);\nvar runtimeType = intType.GetType(); // Noncompliant, always typeof(System.RuntimeType)\n\nvar s = \"abc\";\nif (s.GetType().IsInstanceOfType(typeof(string))) // Noncompliant; false\n{ /* ... */ }\n\nCompliant Solution\n\nvar s = \"abc\";\n\nif (s.GetType().IsInstanceOfType(\"string\"))\n{ /* ... */ }\n\nExceptions\n\ntypeof(Type).GetType(); // Can be used by convention to get an instance of ‘System.RuntimeType’\n\n\n"
    },
    {
      "Code": "3433",
      "Title": "Test method signatures should be correct",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3433",
      "Description": "A method is detected as test method if marked with one of the following attributes [TestMethod] or [DataTestMethod] (for\nmstest), [Fact] or [Theory] (for xunit) or [Test], [TestCase], [TestCaseSource] or\n[Theory] (for nunit). However, whether or not they have a test attribute, non-public methods are not recognized as tests,\nand therefore not executed. Neither are async void methods, or methods with generics anywhere in their signatures.\nNoncompliant Code Example\n\n[TestMethod]\nvoid TestNullArg()  // Noncompliant; method is not public\n{  /* ... */  }\n\n[TestMethod]\npublic async void MyIgnoredTestMethod()  // Noncompliant; this is an 'async void' method\n{ /* ... */ }\n\n[TestMethod]\npublic void MyIgnoredGenericTestMethod&lt;T&gt;(T foo)  // Noncompliant; method has generics in its signature\n{ /* ... */ }\n\nCompliant Solution\n\n[TestMethod]\npublic void TestNullArg()\n{  /* ... */  }\n\nExceptions\nAccessibility is ignored for xUnit Fact test methods, since they do not need to be public.\n[Theory] test methods in xUnit and [TestCase] and [TestCaseSource] test methods in nunit can be generic.\n\n"
    },
    {
      "Code": "3427",
      "Title": "Method overloads with default parameter values should not overlap ",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3427",
      "Description": "The rules for method resolution are complex and perhaps not properly understood by all coders. Having overloads with optional parameter values\nmakes the matter even harder to understand.\nThis rule raises an issue when an overload with default parameter values is hidden by one without the optional parameters.\nNoncompliant Code Example\n\npublic class MyClass\n{\n  void Print(string[] messages) {...}\n  void Print(string[] messages, string delimiter = \"\\n\") {...} // Noncompliant; default parameter value is hidden by overload\n}\n\n// ...\nMyClass myClass = new MyClass();\n\nmyClass.Print(new string[3] {\"yes\", \"no\", \"maybe\"});  // which version of Print will be called?\n\n\n"
    },
    {
      "Code": "3237",
      "Title": "\"value\" parameters should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3237",
      "Description": "In property and indexer set methods, and in event add and remove methods, the implicit value\nparameter holds the value the accessor was called with. Not using the value means that the accessor ignores the caller’s intent which\ncould cause unexpected results at runtime.\nNoncompliant Code Example\n\nprivate int count;\npublic int Count\n{\n  get { return count; }\n  set { count = 42; } // Noncompliant\n}\n\nCompliant Solution\n\nprivate int count;\npublic int Count\n{\n  get { return count; }\n  set { count = value; }\n}\n\nor\n\npublic int Count\n{\n  get { return count; }\n  set { throw new InvalidOperationException(); }\n}\n\nExceptions\nThis rule doesn’t raise an issue when the setter is empty and part of the implementation of an interface . The assumption is that this\npart of the interface is not meaningful to that particular implementation. A good example of that would be a \"sink\" logger that discards any logs.\n\n"
    },
    {
      "Code": "3060",
      "Title": "\"is\" should not be used with \"this\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3060",
      "Description": "There’s no valid reason to test this with is. The only plausible explanation for such a test is that you’re executing\ncode in a parent class conditionally based on the kind of child class this is. But code that’s specific to a child class should be\nin that child class, not in the parent.\nNoncompliant Code Example\n\npublic class JunkFood\n{\n  public void DoSomething()\n  {\n    if (this is Pizza) // Noncompliant\n    {\n      // ...\n    } else if (...\n  }\n}\n\n\n"
    },
    {
      "Code": "2953",
      "Title": "Methods named \"Dispose\" should implement \"IDisposable.Dispose\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2953",
      "Description": "Dispose as a method name should be used exclusively to implement IDisposable.Dispose to prevent any confusion.\nIt may be tempting to create a Dispose method for other purposes, but doing so will result in confusion and likely lead to problems in\nproduction.\nNoncompliant Code Example\n\npublic class GarbageDisposal\n{\n  private int Dispose()  // Noncompliant\n  {\n    // ...\n  }\n}\n\nCompliant Solution\n\npublic class GarbageDisposal : IDisposable\n{\n  public void Dispose()\n  {\n    // ...\n  }\n}\n\nor\n\npublic class GarbageDisposal\n{\n  private int Grind()\n  {\n    // ...\n  }\n}\n\nExceptions\nMethods named Dispose and invoked from the IDisposable.Dispose implementation are not reported.\n\npublic class GarbageDisposal  :  IDisposable\n{\n  protected virtual void Dispose(bool disposing)\n  {\n    //...\n  }\n  public void Dispose()\n  {\n    Dispose(true);\n    GC.SuppressFinalize(this);\n  }\n}\n\n\n"
    },
    {
      "Code": "2699",
      "Title": "Tests should include assertions",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2699",
      "Description": "A test case without assertions ensures only that no exceptions are thrown. Beyond basic runnability, it ensures nothing about the behavior of the\ncode under test.\nThis rule raises an exception when no assertions from any of the following frameworks are found in a test:\n\n   MSTest \n   NUnit \n   xUnit \n   FluentAssertions (4.x and 5.x) \n   NFluent \n   NSubstitute \n   Shoudly \n\nNoncompliant Code Example\n\n[TestMethod]\npublic void MyMethod_WhenSomething_ExpectsSomething()\n{\n    var myClass = new Class();\n    var result = myClass.GetFoo();\n}\n\nCompliant Solution\n\n[TestMethod]\npublic void MyMethod_WhenSomething_ExpectsSomething()\n{\n    var myClass = new Class();\n    var result = myClass.GetFoo();\n    Assert.IsTrue(result);\n}\n\nExceptions\nTo create a custom assertion method declare an attribute with name AssertionMethodAttribute and mark the method with it:\n\nusing System;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\n[TestClass]\npublic class CustomTest\n{\n    [TestMethod]\n    public void TestMethod1() =&gt; Validator.CustomMethod(42);    // Compliant\n}\n\npublic static class Validator\n{\n    [AssertionMethod]\n    public static void CustomMethod(int value) { }\n}\n\npublic class AssertionMethodAttribute : Attribute { }\n\n\n"
    },
    {
      "Code": "2437",
      "Title": "Silly bit operations should not be performed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2437",
      "Description": "Certain bit operations are just silly and should not be performed because their results are predictable.\nSpecifically, using &amp; -1 with any value will always result in the original value, as will anyValue ^ 0 and\nanyValue | 0.\n\n"
    },
    {
      "Code": "2368",
      "Title": "Public methods should not have multidimensional array parameters",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2368",
      "Description": "Exposing methods with multidimensional array parameters requires developers to have advanced knowledge about the language in order to be able to\nuse them. Moreover, what exactly to pass to such parameters is not intuitive. Therefore, such methods should not be exposed, but can be used\ninternally.\nNoncompliant Code Example\n\npublic class Program\n{\n    public void WriteMatrix(int[][] matrix) // Non-Compliant\n    {\n    }\n}\n\nCompliant Solution\n\npublic class Matrix\n{\n    // ...\n}\n\npublic class Program\n{\n    public void WriteMatrix(Matrix matrix) // Compliant\n    {\n    }\n}\n\n\n"
    },
    {
      "Code": "2306",
      "Title": "\"async\" and \"await\" should not be used as identifiers",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2306",
      "Description": "Since C# 5.0, async and await are contextual keywords. Contextual keywords do have a particular meaning in some contexts,\nbut can still be used as variable names. Keywords, on the other hand, are always reserved, and therefore are not valid variable names. To avoid any\nconfusion though, it is best to not use async and await as identifiers.\nNoncompliant Code Example\n\nint await = 42; // Noncompliant\n\nCompliant Solution\n\nint someOtherName = 42;\n\n\n"
    },
    {
      "Code": "2187",
      "Title": "TestCases should contain tests",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2187",
      "Description": "There’s no point in having a test class without any test methods.This could lead a maintainer to assume a class is covered by tests even though it\nis not.\nSupported test frameworks are NUnit and MSTest (not applicable to xUnit).\nThis rule will raise an issue when any of these conditions are met:\n\n   For NUnit, a class is marked with TestFixture but does not contain any method marked with Test,\n  TestCase, TestCaseSource or Theory. \n   For MSTest, a class is marked with TestClass but does not contain any method marked with TestMethod\n  or DataTestMethod. \n\nNoncompliant Code Example\n\n[TestFixture]\npublic class SomeClassTest { } // Noncompliant - no test\n\n[TestClass]\npublic class SomeOtherClassTest { } // Noncompliant - no test\n\nCompliant Solution\n\n[TestFixture]\npublic class SomeClassTest\n{\n    [Test]\n    public void SomeMethodShouldReturnTrue() { }\n}\n\n[TestClass]\npublic class SomeOtherClassTest\n{\n    [TestMethod]\n    public void SomeMethodShouldReturnTrue() { }\n}\n\nExceptions\n\n   abstract classes \n   derived classes that inherit from a base class that does have test methods \n   in MSTest, classes that contain methods marked with either AssemblyInitialize or AssemblyCleanup.\n  \n\n\n"
    },
    {
      "Code": "2178",
      "Title": "Short-circuit logic should be used in boolean contexts",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2178",
      "Description": "The use of non-short-circuit logic in a boolean context is likely a mistake - one that could cause serious program errors as conditions are\nevaluated under the wrong circumstances.\nNoncompliant Code Example\n\nif (GetTrue() | GetFalse()) // Noncompliant; both sides evaluated\n{\n}\n\nCompliant Solution\n\nif (GetTrue() || GetFalse()) // true short-circuit logic\n{\n}\n\n\n"
    },
    {
      "Code": "5659",
      "Title": "JWT should be signed and verified with strong cipher algorithms",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5659",
      "Description": "If a JSON Web Token (JWT) is not signed with a strong cipher algorithm (or not signed at all) an attacker can forge it and impersonate user\nidentities.\n\n   Don’t use none algorithm to sign or verify the validity of a token. \n   Don’t use a token without verifying its signature before. \n\nNoncompliant Code Example\njwt-dotnet library:\n\nvar decodedtoken1 = decoder.Decode(token, secret, verify: false); // Noncompliant: signature should be verified\n\nvar decodedtoken2 = new JwtBuilder()\n   .WithSecret(secret)\n   .Decode(forgedtoken1); // Noncompliant: signature should be verified\n\nCompliant Solution\njwt-dotnet library:\n\nvar decodedtoken1 = decoder.Decode(forgedtoken1, secret, verify: true); // Compliant\n\nvar decodedtoken2 = new JwtBuilder()\n   .WithSecret(secret)\n   .MustVerifySignature()\n   .Decode(token); // Compliant\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   MITRE, CWE-347 - Improper Verification of Cryptographic Signature \n\n\n"
    },
    {
      "Code": "5547",
      "Title": "Cipher algorithms should be robust",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5547",
      "Description": "Strong cipher algorithms are cryptographic systems resistant to cryptanalysis, they\nare not vulnerable to well-known attacks like brute force attacks for example.\nA general recommendation is to only use cipher algorithms intensively tested and promoted by the cryptographic community.\nMore specifically for block cipher, it’s not recommended to use algorithm with a block size inferior than 128 bits.\nNoncompliant Code Example\nFor System.Security.Cryptography library,\nthese old cryptographic algorithms should no longer be used for any reason:\n\nvar tripleDES1 = new TripleDESCryptoServiceProvider(); // Noncompliant: Triple DES is vulnerable to meet-in-the-middle attack\n\nvar simpleDES = new DESCryptoServiceProvider(); // Noncompliant: DES works with 56-bit keys allow attacks via exhaustive search\n\nvar RC2 = new RC2CryptoServiceProvider(); // Noncompliant: RC2 is vulnerable to a related-key attack\n\nFor Bouncycastle library, AESFastEngine has a side channel leak, it\nis possible to gain information about the key used to initialize the cipher:\n\nAesFastEngine aesFast = new AesFastEngine(); // Noncompliant\n\nCompliant Solution\nFor System.Security.Cryptography library,\nit’s recommended to use AesCryptoServiceProvider:\n\nvar AES = new AesCryptoServiceProvider(); // Compliant\n\nFor Bouncycastle library, it’s recommended to use AESEngine:\n\nvar AES = new AESEngine(); // Compliant\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   MITRE, CWE-327 - Use of a Broken or Risky Cryptographic Algorithm \n   SANS Top 25 - Porous Defenses \n\n\n"
    },
    {
      "Code": "5542",
      "Title": "Encryption algorithms should be used with secure mode and padding scheme",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5542",
      "Description": "Encryption operation mode and the padding scheme should be chosen appropriately to guarantee data confidentiality, integrity and authenticity:\n\n   For block cipher encryption algorithms (like AES):\n    \n       The GCM (Galois Counter Mode) mode which works\n      internally with zero/no padding scheme, is recommended, as it is designed to provide both data authenticity (integrity) and confidentiality.\n      Other similar modes are CCM, CWC, EAX, IAPM and OCB. \n       The CBC (Cipher Block Chaining) mode by itself provides only data confidentiality, it’s recommended to use it along with Message\n      Authentication Code or similar to achieve data authenticity (integrity) too and thus to prevent padding oracle attacks. \n       The ECB (Electronic Codebook) mode doesn’t provide serious message confidentiality: under a given key any given plaintext block always gets\n      encrypted to the same ciphertext block. This mode should not be used. \n      \n   For RSA encryption algorithm, the recommended padding scheme is OAEP. \n\nNoncompliant Code Example\nAesManaged object with\ninsecure mode:\n\nAesManaged aes4 = new AesManaged\n{\n  KeySize = 128,\n  BlockSize = 128,\n  Mode = CipherMode.ECB, // Noncompliant\n  Padding = PaddingMode.PKCS7\n};\n\nRSACryptoServiceProvider\nobject without OAEP padding:\n\nRSACryptoServiceProvider RSA1 = new RSACryptoServiceProvider();\nencryptedData = RSA1.Encrypt(dataToEncrypt, false); // Noncompliant: OAEP Padding is not used (second parameter set to false)\n\nCompliant Solution\nAES with GCM mode with bouncycastle library:\n\nGcmBlockCipher blockCipher = new GcmBlockCipher(new AesEngine()); // Compliant\nblockCipher.Init(true, new AeadParameters(new KeyParameter(secretKey), 128, iv, null));\n\nAES with GCM mode with AesGcm\nobject:\n\nvar aesGcm = new AesGcm(key); // Compliant\n\nRSA with OAEP padding with RSACryptoServiceProvider\nobject:\n\nRSACryptoServiceProvider RSA2 = new RSACryptoServiceProvider();\nencryptedData = RSA2.Encrypt(dataToEncrypt, true); // Compliant: OAEP Padding is used (second parameter set to true)\n\nSee\n\n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   MITRE, CWE-327 - Use of a Broken or Risky Cryptographic Algorithm \n   SANS Top 25 - Porous Defenses \n\n\n"
    },
    {
      "Code": "5445",
      "Title": "Insecure temporary file creation methods should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5445",
      "Description": "Creating temporary files using insecure methods exposes the application to race conditions on filenames: a malicious user can try to create a file\nwith a predictable name before the application does. A successful attack can result in other files being accessed, modified, corrupted or deleted.\nThis risk is even higher if the application run with elevated permissions.\nIn the past, it has led to the following vulnerabilities:\n\n   CVE-2014-1858 \n   CVE-2014-1932 \n\nPath.GetTempFileName()&nbsp;generates predictable file names and is inherently unreliable and insecure. Additionally, the&nbsp;method\nwill raise an&nbsp;IOException if it is used to create more than 65535 files without deleting previous temporary files.\nRecommended Secure Coding Practices\nOut of the box, .NET is missing secure-by-design APIs to create temporary files. To overcome this, one of the following options can be used:\n\n   Use a dedicated sub-folder with tightly controlled permissions \n   Created temporary files in a publicly writable folder and make sure:\n    \n       Generated filename is unpredictable \n       File is readable and writable only by the creating user ID \n       File descriptor is not inherited by child processes \n       File is destroyed as soon as it is closed \n      \n\nNoncompliant Code Example\n\nvar tempPath = Path.GetTempFileName();  // Noncompliant\n\nusing (var writer = new StreamWriter(tempPath))\n{\n    writer.WriteLine(\"content\");\n}\n\nCompliant Solution\n\nvar randomPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());\n\n// Creates a new file with write, non inheritable permissions which is deleted on close.\nusing (var fileStream = new FileStream(randomPath, FileMode.CreateNew, FileAccess.Write, FileShare.None, 4096, FileOptions.DeleteOnClose))\nusing (var writer = new StreamWriter(fileStream))\n{\n    writer.WriteLine(\"content\");\n}\n\nSee\n\n   OWASP Top 10 2017 Category A9 - Using\n  Components with Known Vulnerabilities \n   MITRE, CWE-377 - Insecure Temporary File \n   MITRE, CWE-379 - Creation of Temporary File in Directory with Incorrect Permissions\n  \n   OWASP, Insecure Temporary File \n\n\n"
    },
    {
      "Code": "4830",
      "Title": "Server certificates should be verified during SSL/TLS connections",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4830",
      "Description": "Validation of X.509 certificates is essential to create secure SSL/TLS sessions not vulnerable to man-in-the-middle attacks.\nThe certificate chain validation includes these steps:\n\n   The certificate is issued by its parent Certificate Authority or the root CA trusted by the system. \n   Each CA is allowed to issue certificates. \n   Each certificate in the chain is not expired. \n\nIt’s not recommended to reinvent the wheel by implementing custom certificate chain validation.\nTLS libraries provide built-in certificate validation functions that should be used.\nNoncompliant Code Example\n\nServicePointManager.ServerCertificateValidationCallback +=\n    (sender, certificate, chain, errors) =&gt; {\n        return true; // Noncompliant: trust all certificates\n    };\n\nCompliant Solution\n\nServicePointManager.ServerCertificateValidationCallback +=\n    (sender, certificate, chain, errors) =&gt;\n    {\n        if (development) return true; // for development, trust all certificates\n        return errors == SslPolicyErrors.None\n            &amp;&amp; validCerts.Contains(certificate.GetCertHashString()); // Compliant: trust only some certificates\n    };\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   Mobile AppSec Verification\n  Standard - Network Communication Requirements \n   OWASP Mobile Top 10 2016 Category M3 - Insecure\n  Communication \n   MITRE, CWE-295 - Improper Certificate Validation \n\n\n"
    },
    {
      "Code": "4433",
      "Title": "LDAP connections should be authenticated",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4433",
      "Description": "An LDAP client authenticates to an LDAP server with a \"bind request\" which provides, among other, a simple authentication method.\nSimple authentication in LDAP can be used with three different mechanisms:\n\n   Anonymous Authentication Mechanism by performing a bind request with a username and password value of zero length. \n   Unauthenticated Authentication Mechanism by performing a bind request with a password value of zero length. \n   Name/Password Authentication Mechanism by performing a bind request with a password value of non-zero length. \n\nAnonymous binds and unauthenticated binds allow access to information in the LDAP directory without providing a password, their use is therefore\nstrongly discouraged.\nNoncompliant Code Example\nThis rule raises an issue when an LDAP connection is created with AuthenticationTypes.Anonymous or\nAuthenticationTypes.None.\n\nDirectoryEntry myDirectoryEntry = new DirectoryEntry(adPath);\nmyDirectoryEntry.AuthenticationType = AuthenticationTypes.None; // Noncompliant\n\nDirectoryEntry myDirectoryEntry = new DirectoryEntry(adPath, \"u\", \"p\", AuthenticationTypes.None); // Noncompliant\n\nCompliant Solution\n\nDirectoryEntry myDirectoryEntry = new DirectoryEntry(myADSPath); // Compliant; default DirectoryEntry.AuthenticationType property value is \"Secure\" since .NET Framework 2.0\n\nDirectoryEntry myDirectoryEntry = new DirectoryEntry(myADSPath, \"u\", \"p\", AuthenticationTypes.Secure);\n\nSee\n\n   OWASP Top 10 2017 Category A2 - Broken Authentication \n   CWE-521 - Weak Password Requirements \n   ldapwiki.com- Simple Authentication \n\n\n"
    },
    {
      "Code": "4426",
      "Title": "Cryptographic keys should be robust",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4426",
      "Description": "Most of cryptographic systems require a sufficient key size to be robust against brute-force attacks.\nNIST recommendations will be checked for these\nuse-cases:\nDigital Signature Generation and Verification:\n\n   p ≥ 2048 AND q ≥ 224 for DSA (p is key length and q the modulus length) \n   n ≥ 2048 for RSA (n is the key length) \n\nKey Agreement:\n\n   p ≥ 2048 AND q ≥ 224 for DH and MQV \n   n ≥ 224 for ECDH and ECMQV (Examples: secp192r1 is a non-compliant curve (n &lt; 224) but secp224k1 is\n  compliant (n &gt;= 224)) \n\nSymmetric keys:\n\n   key length ≥ 128 bits \n\nThis rule will not raise issues for ciphers that are considered weak (no matter the key size) like DES, Blowfish.\nNoncompliant Code Example\n\nusing System;\nusing System.Security.Cryptography;\n\nnamespace MyLibrary\n{\n    public class MyCryptoClass\n    {\n        static void Main()\n        {\n            var dsa1 = new DSACryptoServiceProvider(); // Noncompliant - default key size is 1024\n            dsa1.KeySize = 2048; // Noncompliant - the setter does not update the underlying key size for the DSACryptoServiceProvider class\n\n            var dsa2 = new DSACryptoServiceProvider(2048); // Noncompliant - cannot create DSACryptoServiceProvider with a key size bigger than 1024\n\n            var rsa1 = new RSACryptoServiceProvider(); // Noncompliant - default key size is 1024\n            rsa1.KeySize = 2048; // Noncompliant - the setter does not update the underlying key size for the RSACryptoServiceProvider class\n\n            var rsa2 = new RSACng(1024); // Noncompliant\n\n            // ...\n        }\n    }\n}\n\nKeySize property of DSACryptoServiceProvider and RSACryptoServiceProvider does not change the value of underlying KeySize for the algorithm.\nProperty setter is ignored without error and KeySize can be changed only by using constructor overload. See:\n\n   DSACryptoServiceProvider.KeySize\n  Property \n   RSACryptoServiceProvider.KeySize\n  Property \n\nCompliant Solution\n\nusing System;\nusing System.Security.Cryptography;\n\nnamespace MyLibrary\n{\n    public class MyCryptoClass\n    {\n        static void Main()\n        {\n            var dsa1 = new DSACng(); // Compliant - default key size is 2048\n            var dsa2 = new DSACng(2048); // Compliant\n            var rsa1 = new RSACryptoServiceProvider(2048); // Compliant\n            var rsa2 = new RSACng(); // Compliant - default key size is 2048\n\n            // ...\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   Mobile AppSec\n  Verification Standard - Cryptography Requirements \n   OWASP Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography \n   NIST 800-131A - Recommendation for Transitioning the\n  Use of Cryptographic Algorithms and Key Lengths \n   MITRE, CWE-326 - Inadequate Encryption Strength \n\n\n"
    },
    {
      "Code": "4423",
      "Title": "Weak SSL/TLS protocols should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4423",
      "Description": "Older versions of SSL/TLS protocol like \"SSLv3\" have been proven to be insecure.\nThis rule raises an issue when an SSL/TLS is configured at application level with an insecure version (ie: a protocol different from \"TLSv1.2\" or\n\"TLSv1.3\").\nNo issue is raised when the choice of the SSL/TLS version relies on the OS configuration. Be aware that the latest version of Windows 10 and Windows Server 2016 have TLSv1.0 and\nTLSv1.1 enabled by default. Administrators can configure the OS to enforce TLSv1.2 minumum by updateing registry settings or by applying a group\npolicy.\nNoncompliant Code Example\n\nServicePointManager.SecurityProtocol = SecurityProtocolType.Tls; // Noncompliant; legacy version TLSv1 is enabled\n\nFor System.Net.Http.HttpClient\n\nnew HttpClientHandler\n{\n    SslProtocols = SslProtocols.Tls // Noncompliant; legacy version TLSv1 is enabled\n};\n\nCompliant Solution\n\nServicePointManager.SecurityProtocol = SecurityProtocolType.SystemDefault; // Compliant; choice of the SSL/TLS versions rely on the OS configuration\nServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls13; // Compliant\n\nFor System.Net.Http.HttpClient\n\nnew HttpClientHandler\n{\n    SslProtocols = SslProtocols.Tls12 // Compliant\n};\n\nnew HttpClientHandler\n{\n    SslProtocols = SslProtocols.None // Compliant; choice of the TLS versions rely on the OS configuration\n};\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   MITRE, CWE-327 - Inadequate Encryption Strength \n   MITRE, CWE-326 - Use of a Broken or Risky Cryptographic Algorithm \n   SANS Top 25 - Porous Defenses \n   SSL and TLS Deployment Best\n  Practices - Use secure protocols \n   Transport Layer Security (TLS) best practices with the .NET\n  Framework \n\n\n"
    },
    {
      "Code": "3329",
      "Title": "Cipher Block Chaining IVs should be unpredictable",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3329",
      "Description": "When encrypting data with the Cipher Block Chaining (CBC) mode an Initialization Vector (IV) is used to randomize the encryption, ie under a given\nkey the same plaintext doesn’t always produce the same ciphertext. The IV doesn’t need to be secret but should be unpredictable to avoid\n\"Chosen-Plaintext Attack\".\nTo generate Initialization Vectors, NIST recommends to use a secure random number generator.\nNoncompliant Code Example\n\npublic void Encrypt(byte[] key, byte[] data, MemoryStream target)\n{\n    byte[] initializationVector = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n\n    using var aes = new AesCryptoServiceProvider();\n    var encryptor = aes.CreateEncryptor(key, initializationVector); // Noncompliant, hardcoded value is used\n\n    using var cryptoStream = new CryptoStream(target, encryptor, CryptoStreamMode.Write);\n    cryptoStream.Write(data);\n}\n\nCompliant Solution\n\npublic byte[] Encrypt(byte[] key, byte[] data, MemoryStream target)\n{\n    using var aes = new AesCryptoServiceProvider();\n    var encryptor = aes.CreateEncryptor(key, aes.IV); // aes.IV is automatically generated to random secure value\n\n    using var cryptoStream = new CryptoStream(target, encryptor, CryptoStreamMode.Write);\n    cryptoStream.Write(data);\n\n    return aes.IV;\n}\n\nSee\n\n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   Mobile AppSec\n  Verification Standard - Cryptography Requirements \n   OWASP Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography \n   MITRE, CWE-329 - CWE-329: Not Using an Unpredictable IV with CBC Mode \n   MITRE, CWE-330 - Use of Insufficiently Random Values \n   MITRE, CWE-340 - Generation of Predictable Numbers or Identifiers \n   MITRE, CWE-1204 - Generation of Weak Initialization Vector (IV) \n   NIST, SP-800-38A - Recommendation for Block Cipher\n  Modes of Operation \n\n\n"
    },
    {
      "Code": "2631",
      "Title": "Regular expressions should not be vulnerable to Denial of Service attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2631",
      "Description": "Most of the regular expression engines use backtracking to try all possible execution paths of the regular expression when evaluating\nan input, in some cases it can cause performance issues, called catastrophic backtracking situations. In the worst case, the complexity\nof the regular expression is exponential in the size of the input, this means that a small carefully-crafted input (like 20 chars) can trigger\ncatastrophic backtracking and cause a denial of service of the application. Super-linear regex complexity can lead to the same impact too\nwith, in this case, a large carefully-crafted input (thousands chars).\nIt is not recommended to construct a regular expression pattern from a user-controlled input, if no other choice, sanitize the input to\nremove/annihilate regex metacharacters.\nNoncompliant Code Example\n\nusing System.Text.RegularExpressions;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2631RegExpInjectionNoncompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult Validate(string regex, string input)\n        {\n            bool match = Regex.IsMatch(input, regex); // Noncompliant\n\n            return Content(\"Valid? \" + match);\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Text.RegularExpressions;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC2631RegExpInjectionCompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult Validate(string regex, string input)\n        {\n            bool match = Regex.IsMatch(input, Regex.Escape(regex)); // Compliant\n\n            return Content(\"Valid? \" + match);\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-400 - Uncontrolled Resource Consumption \n   MITRE, CWE-1333 - Inefficient Regular Expression Complexity \n   OWASP Regular expression Denial of Service - ReDoS\n  \n\n\n"
    },
    {
      "Code": "2053",
      "Title": "Hashes should include an unpredictable salt",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2053",
      "Description": "In cryptography, a \"salt\" is an extra piece of data which is included when hashing a password. This makes rainbow-table attacks more\ndifficult. Using a cryptographic hash function without an unpredictable salt increases the likelihood that an attacker could successfully find the\nhash value in databases of precomputed hashes (called rainbow-tables).\nThis rule raises an issue when a hashing function which has been specifically designed for hashing passwords, such as PBKDF2, is used\nwith a non-random, reused or too short salt value. It does not raise an issue on base hashing algorithms such as sha1 or md5\nas they should not be used to hash passwords.\nRecommended Secure Coding Practices\n\n   Use hashing functions generating their own secure salt or generate a secure random value of at least 16 bytes. \n   The salt should be unique by user password. \n\nNoncompliant Code Example\n\npublic void Hash(string password)\n{\n    var salt = Encoding.UTF8.GetBytes(\"Hardcoded salt\");\n    var fromHardcoded = new Rfc2898DeriveBytes(password, salt);     // Noncompliant, salt is hardcoded\n\n    salt = Encoding.UTF8.GetBytes(password);\n    var fromPassword = new Rfc2898DeriveBytes(password, salt);     // Noncompliant, password should not be used as a salt as it makes it predictable\n\n    var shortSalt = new byte[8];\n    RandomNumberGenerator.Create().GetBytes(shortSalt);\n    var fromShort = new Rfc2898DeriveBytes(password, shortSalt);   // Noncompliant, salt is too short (should be at least 16 bytes, not 8)\n}\n\nCompliant Solution\n\npublic DeriveBytes Hash(string password)\n{\n    return new Rfc2898DeriveBytes(password, 16);\n}\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   MITRE, CWE-759 - Use of a One-Way Hash without a Salt \n   MITRE, CWE-760 - Use of a One-Way Hash with a Predictable Salt \n   SANS Top 25 - Porous Defenses \n\n\n"
    },
    {
      "Code": "4586",
      "Title": "Non-async \"Task/Task\" methods should not return null",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4586",
      "Description": "Returning null from a non-async Task/Task&lt;T&gt; method will cause a\nNullReferenceException at runtime. This problem can be avoided by returning Task.FromResult&lt;T&gt;(null) instead.\nNoncompliant Code Example\n\npublic Task&lt;object&gt; GetFooAsync()\n{\n    return null; // Noncompliant\n}\n\nCompliant Solution\n\npublic Task&lt;object&gt; GetFooAsync()\n{\n    return Task.FromResult&lt;object&gt;(null);\n}\n\n\n"
    },
    {
      "Code": "4583",
      "Title": "Calls to delegate's method \"BeginInvoke\" should be paired with calls to \"EndInvoke\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4583",
      "Description": "Calling the BeginInvoke method of a delegate will allocate some resources that are only freed-up when EndInvoke is\ncalled. This is why you should always pair BeginInvoke with an EndInvoke to complete your asynchronous call.\nThis rule raises an issue when:\n\n   the BeginInvoke method is called without any callback and it is not paired with a call to EndInvoke in the same\n  block. \n   a callback with a single parameter of type IAsyncResult doesn’t contain a call to EndInvoke. \n\nNoncompliant Code Example\nBeginInvoke without callback\n\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample = new AsyncExample();\n    AsyncMethodCaller caller = new AsyncMethodCaller(asyncExample.MyMethod);\n\n    // Initiate the asynchronous call.\n    IAsyncResult result = caller.BeginInvoke(null, null); // Noncompliant - not paired with EndInvoke\n}\n\nBeginInvoke with callback\n\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample = new AsyncExample();\n    AsyncMethodCaller caller = new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result = caller.BeginInvoke(\n        new AsyncCallback((IAsyncResult ar) =&gt; {}),\n        null); // Noncompliant - not paired with EndInvoke\n}\n\nCompliant Solution\nBeginInvoke without callback\n\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample = new AsyncExample();\n    AsyncMethodCaller caller = new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result = caller.BeginInvoke(null, null);\n\n    string returnValue = caller.EndInvoke(result);\n}\n\nBeginInvoke with callback\n\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample = new AsyncExample();\n    AsyncMethodCaller caller = new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result = caller.BeginInvoke(\n        new AsyncCallback((IAsyncResult ar) =&gt;\n            {\n                // Call EndInvoke to retrieve the results.\n                string returnValue = caller.EndInvoke(ar);\n            }), null);\n}\n\nSee\nCalling\nSynchronous Methods Asynchronously\n\n"
    },
    {
      "Code": "4277",
      "Title": "\"Shared\" parts should not be created with \"new\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4277",
      "Description": "Marking a class with PartCreationPolicy(CreationPolicy.Shared), which is part of Managed Extensibility Framework (MEF), means that a\nsingle, shared instance of the exported object will be created. Therefore it doesn’t make sense to create new instances using the constructor and it\nwill most likely result in unexpected behaviours.\nThis rule raises an issue when a constructor of a class marked shared with a PartCreationPolicyAttribute is invoked.\nNoncompliant Code Example\n\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Shared)]\npublic class FooBar : IFooBar\n{\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var fooBar = new FooBar(); // Noncompliant;\n    }\n}\n\nCompliant Solution\n\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Shared)]\npublic class FooBar : IFooBar\n{\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var fooBar = serviceProvider.GetService&lt;IFooBar&gt;();\n    }\n}\n\n\n"
    },
    {
      "Code": "4275",
      "Title": "Getters and setters should access the expected fields",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4275",
      "Description": "Properties provide a way to enforce encapsulation by providing public, protected or internal methods that\ngive controlled access to private fields. However in classes with multiple fields it is not unusual that cut and paste is used to quickly\ncreate the needed properties, which can result in the wrong field being accessed by a getter or setter.\nThis rule raises an issue in any of these cases:\n\n   A setter does not update the field with the corresponding name. \n   A getter does not access the field with the corresponding name. \n\nFor simple properties it is better to use auto-implemented\nproperties (C# 3.0 or later).\nField and property names are compared as case-insensitive. All underscore characters are ignored.\nNoncompliant Code Example\n\nclass A\n{\n    private int x;\n    private int y;\n\n    public int X\n    {\n        get { return x; }\n        set { x = value; }\n    }\n\n    public int Y\n    {\n        get { return x; }  // Noncompliant: field 'y' is not used in the return value\n        set { x = value; } // Noncompliant: field 'y' is not updated\n    }\n}\n\nCompliant Solution\n\nclass A\n{\n    private int x;\n    private int y;\n\n    public int X\n    {\n        get { return x; }\n        set { x = value; }\n    }\n\n    public int Y\n    {\n        get { return y; }\n        set { y = value; }\n    }\n}\n\n\n"
    },
    {
      "Code": "3449",
      "Title": "Right operands of shift operators should be integers",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3449",
      "Description": "Numbers can be shifted with the &lt;&lt; and &gt;&gt; operators, but the right operand of the operation needs to be an\nint or a type that has an implicit conversion to int. However, with dynamic, the compiler’s type checking is\nturned off, so you can pass anything to a shift operator and have it compile. And if the argument can’t be converted to int at runtime,\nthen a RuntimeBinderException will be raised.\nNoncompliant Code Example\n\ndynamic d = 5;\nvar x = d &gt;&gt; 5.4; // Noncompliant\nx = d &gt;&gt; null; // Noncompliant\nx &lt;&lt;= new object(); // Noncompliant\n\n\n"
    },
    {
      "Code": "2551",
      "Title": "Shared resources should not be used for locking",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2551",
      "Description": "Shared resources should not be used for locking as it increases the chance of deadlocks. Any other thread could acquire (or attempt to acquire) the\nsame lock for another unrelated purpose.\nInstead, a dedicated object instance should be used for each shared resource, to avoid deadlocks or lock contention.\nThe following objects are considered as shared resources:\n\n   this \n   a Type object \n   a string literal \n   a string instance \n\nNoncompliant Code Example\n\npublic void MyLockingMethod()\n{\n    lock (this) // Noncompliant\n    {\n        // ...\n    }\n}\n\nCompliant Solution\n\nprivate readonly object lockObj = new object();\n\npublic void MyLockingMethod()\n{\n    lock (lockObj)\n    {\n        // ...\n    }\n}\n\nSee\nMicrosoft Documentation: Managed Threading\nBest Practices\n\n"
    },
    {
      "Code": "5443",
      "Title": "Using publicly writable directories is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5443",
      "Description": "Operating systems have global directories where any user has write access. Those folders are mostly used as temporary storage areas like\n/tmp in Linux based systems. An application manipulating files from these folders is exposed to race conditions on filenames: a malicious\nuser can try to create a file with a predictable name before the application does. A successful attack can result in other files being accessed,\nmodified, corrupted or deleted. This risk is even higher if the application runs with elevated permissions.\nIn the past, it has led to the following vulnerabilities:\n\n   CVE-2012-2451 \n   CVE-2015-1838 \n\nThis rule raises an issue whenever it detects a hard-coded path to a publicly writable directory like /tmp (see examples bellow). It\nalso detects access to environment variables that point to publicly writable directories, e.g., TMP, TMPDIR and\nTEMP.\n\n   /tmp \n   /var/tmp \n   /usr/tmp \n   /dev/shm \n   /dev/mqueue \n   /run/lock \n   /var/run/lock \n   /Library/Caches \n   /Users/Shared \n   /private/tmp \n   /private/var/tmp \n   \\Windows\\Temp \n   \\Temp \n   \\TMP \n   %USERPROFILE%\\AppData\\Local\\Temp \n\nAsk Yourself Whether\n\n   Files are read from or written into a publicly writable folder \n   The application creates files with predictable names into a publicly writable folder \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\nOut of the box, .NET is missing secure-by-design APIs to create temporary files. To overcome this, one of the following options can be used:\n\n   Use a dedicated sub-folder with tightly controlled permissions \n   Created temporary files in a publicly writable folder and make sure:\n    \n       Generated filename is unpredictable \n       File is readable and writable only by the creating user ID \n       File descriptor is not inherited by child processes \n       File is destroyed as soon as it is closed \n      \n\nSensitive Code Example\n\nusing var writer = new StreamWriter(\"/tmp/f\"); // Sensitive\n\n\nvar tmp = Environment.GetEnvironmentVariable(\"TMP\"); // Sensitive\n\nCompliant Solution\n\nvar randomPath = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());\n\n// Creates a new file with write, non inheritable permissions which is deleted on close.\nusing var fileStream = new FileStream(randomPath, FileMode.CreateNew, FileAccess.Write, FileShare.None, 4096, FileOptions.DeleteOnClose);\nusing var writer = new StreamWriter(fileStream);\n\nSee\n\n   OWASP Top 10 2017 Category A5 - Broken Access Control \n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   MITRE, CWE-377 - Insecure Temporary File \n   MITRE, CWE-379 - Creation of Temporary File in Directory with Incorrect Permissions\n  \n   OWASP, Insecure Temporary File \n\n\n"
    },
    {
      "Code": "5332",
      "Title": "Using clear-text protocols is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5332",
      "Description": "Clear-text protocols as ftp, telnet or non secure http are lacking encryption of transported data. They are\nalso missing the capability to build an authenticated connection. This mean that any attacker who can sniff traffic from the network can read, modify\nor corrupt the transported content. These protocol are not secure as they expose applications to a large range of risk:\n\n   Sensitive data exposure \n   Traffic redirected to a malicious endpoint \n   Malware infected software update or installer \n   Execution of client side code \n   Corruption of critical information \n\nNote also that using the http protocol is being deprecated by major web browser.\nIn the past, it has led to the following vulnerabilities:\n\n   CVE-2019-6169 \n   CVE-2019-12327 \n   CVE-2019-11065 \n\nAsk Yourself Whether\n\n   The confidentiality and integrity of data is necessary in the context of the web application. \n   The data is exchanged on an exposed network (Internet, public network etc). \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Use ssh as an alternative to telnet \n   Use sftp, scp or ftps instead of ftp \n   Use https instead of http \n   Use SMTP over SSL/TLS or SMTP with STARTTLS instead of clear-text SMTP \n\nIt is recommended to secure all transport channels (event local network) as it can take a single non secure connection to compromise an entire\napplication or system.\nSensitive Code Example\n\nvar urlHttp = \"http://example.com\";                 // Noncompliant\nvar urlFtp = \"ftp://anonymous@example.com\";         // Noncompliant\nvar urlTelnet = \"telnet://anonymous@example.com\";   // Noncompliant\n\n\nusing var smtp = new SmtpClient(\"host\", 25); // Noncompliant, EnableSsl is not set\nusing var telnet = new MyTelnet.Client(\"host\", port); // Noncompliant, rule raises Security Hotspot on any member containing \"Telnet\"\n\nCompliant Solution\n\nvar urlHttps = \"https://example.com\";\nvar urlSftp = \"sftp://anonymous@example.com\";\nvar urlSsh = \"ssh://anonymous@example.com\";\n\n\nusing var smtp = new SmtpClient(\"host\", 25) { EnableSsl = true };\nusing var ssh = new MySsh.Client(\"host\", port);\n\nExceptions\nNo issue is reported for the following cases because they are not considered sensitive:\n\n   Insecure protocol scheme followed by loopback addresses like 127.0.0.1 or localhost \n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   Mobile AppSec Verification\n  Standard - Network Communication Requirements \n   OWASP Mobile Top 10 2016 Category M3 - Insecure\n  Communication \n   MITRE, CWE-200 - Exposure of Sensitive Information to an Unauthorized Actor \n   MITRE, CWE-319 - Cleartext Transmission of Sensitive Information \n   Google, Moving towards more secure web \n   Mozilla, Deprecating non secure http \n\n\n"
    },
    {
      "Code": "5042",
      "Title": "Expanding archive files without controlling resource consumption is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5042",
      "Description": "Successful Zip Bomb attacks occur when an application expands untrusted archive files without controlling the size of the expanded data, which can\nlead to denial of service. A Zip bomb is usually a malicious archive file of a few kilobytes of compressed data but turned into gigabytes of\nuncompressed data. To achieve this extreme compression ratio, attackers will\ncompress irrelevant data (eg: a long string of repeated bytes).\nAsk Yourself Whether\nArchives to expand are untrusted and:\n\n   There is no validation of the number of entries in the archive. \n   There is no validation of the total size of the uncompressed data. \n   There is no validation of the ratio between the compressed and uncompressed archive entry. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Define and control the ratio between compressed and uncompressed data, in general the data compression ratio for most of the legit archives is\n  1 to 3. \n   Define and control the threshold for maximum total size of the uncompressed data. \n   Count the number of file entries extracted from the archive and abort the extraction if their number is greater than a predefined threshold, in\n  particular it’s not recommended to recursively expand archives (an entry of an archive could be also an archive). \n\nSensitive Code Example\n\nusing var zipToOpen = new FileStream(@\"ZipBomb.zip\", FileMode.Open);\nusing var archive = new ZipArchive(zipToOpen, ZipArchiveMode.Read);\nforeach (ZipArchiveEntry entry in archive.Entries)\n{\n  entry.ExtractToFile(\"./output_onlyfortesting.txt\", true); // Sensitive\n}\n\nCompliant Solution\n\nint THRESHOLD_ENTRIES = 10000;\nint THRESHOLD_SIZE = 1000000000; // 1 GB\ndouble THRESHOLD_RATIO = 10;\nint totalSizeArchive = 0;\nint totalEntryArchive = 0;\n\nusing var zipToOpen = new FileStream(@\"ZipBomb.zip\", FileMode.Open);\nusing var archive = new ZipArchive(zipToOpen, ZipArchiveMode.Read);\nforeach (ZipArchiveEntry entry in archive.Entries)\n{\n  totalEntryArchive ++;\n\n  using (Stream st = entry.Open())\n  {\n    byte[] buffer = new byte[1024];\n    int totalSizeEntry = 0;\n    int numBytesRead = 0;\n\n    do\n    {\n      numBytesRead = st.Read(buffer, 0, 1024);\n      totalSizeEntry += numBytesRead;\n      totalSizeArchive += numBytesRead;\n      double compressionRatio = totalSizeEntry / entry.CompressedLength;\n\n      if(compressionRatio &gt; THRESHOLD_RATIO) {\n        // ratio between compressed and uncompressed data is highly suspicious, looks like a Zip Bomb Attack\n        break;\n      }\n    }\n    while (numBytesRead &gt; 0);\n  }\n\n  if(totalSizeArchive &gt; THRESHOLD_SIZE) {\n      // the uncompressed data size is too much for the application resource capacity\n      break;\n  }\n\n  if(totalEntryArchive &gt; THRESHOLD_ENTRIES) {\n      // too much entries in this archive, can lead to inodes exhaustion of the system\n      break;\n  }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A6 -\n  Security Misconfiguration \n   MITRE, CWE-409 - Improper Handling of Highly Compressed Data (Data Amplification)\n  \n   bamsoftware.com - A better Zip Bomb \n\n\n"
    },
    {
      "Code": "4792",
      "Title": "Configuring loggers is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4792",
      "Description": "Configuring loggers is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2018-0285 \n   CVE-2000-1127 \n   CVE-2017-15113 \n   CVE-2015-5742 \n\nLogs are useful before, during and after a security incident.\n\n   Attackers will most of the time start their nefarious work by probing the system for vulnerabilities. Monitoring this activity and stopping it\n  is the first step to prevent an attack from ever happening. \n   In case of a successful attack, logs should contain enough information to understand what damage an attacker may have inflicted. \n\nLogs are also a target for attackers because they might contain sensitive information. Configuring loggers has an impact on the type of information\nlogged and how they are logged.\nThis rule flags for review code that initiates loggers configuration. The goal is to guide security code reviews.\nAsk Yourself Whether\n\n   unauthorized users might have access to the logs, either because they are stored in an insecure location or because the application gives\n  access to them. \n   the logs contain sensitive information on a production server. This can happen when the logger is in debug mode. \n   the log can grow without limit. This can happen when additional information is written into logs every time a user performs an action and the\n  user can perform the action as many times as he/she wants. \n   the logs do not contain enough information to understand the damage an attacker might have inflicted. The loggers mode (info, warn, error)\n  might filter out important information. They might not print contextual information like the precise time of events or the server hostname. \n   the logs are only stored locally instead of being backuped or replicated. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Check that your production deployment doesn’t have its loggers in \"debug\" mode as it might write sensitive information in logs. \n   Production logs should be stored in a secure location which is only accessible to system administrators. \n   Configure the loggers to display all warnings, info and error messages. Write relevant information such as the precise time of events and the\n  hostname. \n   Choose log format which is easy to parse and process automatically. It is important to process logs rapidly in case of an attack so that the\n  impact is known and limited. \n   Check that the permissions of the log files are correct. If you index the logs in some other service, make sure that the transfer and the\n  service are secure too. \n   Add limits to the size of the logs and make sure that no user can fill the disk with logs. This can happen even when the user does not control\n  the logged information. An attacker could just repeat a logged action many times. \n\nRemember that configuring loggers properly doesn’t make them bullet-proof. Here is a list of recommendations explaining on how to use your\nlogs:\n\n   Don’t log any sensitive information. This obviously includes passwords and credit card numbers but also any personal information such as user\n  names, locations, etc…​ Usually any information which is protected by law is good candidate for removal. \n   Sanitize all user inputs before writing them in the logs. This includes checking its size, content, encoding, syntax, etc…​ As for any user\n  input, validate using whitelists whenever possible. Enabling users to write what they want in your logs can have many impacts. It could for example\n  use all your storage space or compromise your log indexing service. \n   Log enough information to monitor suspicious activities and evaluate the impact an attacker might have on your systems. Register events such as\n  failed logins, successful logins, server side input validation failures, access denials and any important transaction. \n   Monitor the logs for any suspicious activity. \n\nSensitive Code Example\n.Net Core: configure programmatically\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Options;\nusing Microsoft.AspNetCore;\n\nnamespace MvcApp\n{\n    public class ProgramLogging\n    {\n        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;\n            WebHost.CreateDefaultBuilder(args)\n                .ConfigureLogging((hostingContext, logging) =&gt; // Sensitive\n                {\n                    // ...\n                })\n                .UseStartup&lt;StartupLogging&gt;();\n    }\n\n    public class StartupLogging\n    {\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddLogging(logging =&gt; // Sensitive\n            {\n                // ...\n            });\n        }\n\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)\n        {\n            IConfiguration config = null;\n            LogLevel level = LogLevel.Critical;\n            Boolean includeScopes = false;\n            Func&lt;string,Microsoft.Extensions.Logging.LogLevel,bool&gt; filter = null;\n            Microsoft.Extensions.Logging.Console.IConsoleLoggerSettings consoleSettings = null;\n            Microsoft.Extensions.Logging.AzureAppServices.AzureAppServicesDiagnosticsSettings azureSettings = null;\n            Microsoft.Extensions.Logging.EventLog.EventLogSettings eventLogSettings = null;\n\n            // An issue will be raised for each call to an ILoggerFactory extension methods adding loggers.\n            loggerFactory.AddAzureWebAppDiagnostics(); // Sensitive\n            loggerFactory.AddAzureWebAppDiagnostics(azureSettings); // Sensitive\n            loggerFactory.AddConsole(); // Sensitive\n            loggerFactory.AddConsole(level); // Sensitive\n            loggerFactory.AddConsole(level, includeScopes); // Sensitive\n            loggerFactory.AddConsole(filter); // Sensitive\n            loggerFactory.AddConsole(filter, includeScopes); // Sensitive\n            loggerFactory.AddConsole(config); // Sensitive\n            loggerFactory.AddConsole(consoleSettings); // Sensitive\n            loggerFactory.AddDebug(); // Sensitive\n            loggerFactory.AddDebug(level); // Sensitive\n            loggerFactory.AddDebug(filter); // Sensitive\n            loggerFactory.AddEventLog(); // Sensitive\n            loggerFactory.AddEventLog(eventLogSettings); // Sensitive\n            loggerFactory.AddEventLog(level); // Sensitive\n            loggerFactory.AddEventSourceLogger(); // Sensitive\n\n            IEnumerable&lt;ILoggerProvider&gt; providers = null;\n            LoggerFilterOptions filterOptions1 = null;\n            IOptionsMonitor&lt;LoggerFilterOptions&gt; filterOptions2 = null;\n\n            LoggerFactory factory = new LoggerFactory(); // Sensitive\n            new LoggerFactory(providers); // Sensitive\n            new LoggerFactory(providers, filterOptions1); // Sensitive\n            new LoggerFactory(providers, filterOptions2); // Sensitive\n        }\n    }\n}\n\nLog4Net\n\nusing System;\nusing System.IO;\nusing System.Xml;\nusing log4net.Appender;\nusing log4net.Config;\nusing log4net.Repository;\n\nnamespace Logging\n{\n    class Log4netLogging\n    {\n        void Foo(ILoggerRepository repository, XmlElement element, FileInfo configFile, Uri configUri, Stream configStream,\n        IAppender appender, params IAppender[] appenders) {\n            log4net.Config.XmlConfigurator.Configure(repository); // Sensitive\n            log4net.Config.XmlConfigurator.Configure(repository, element); // Sensitive\n            log4net.Config.XmlConfigurator.Configure(repository, configFile); // Sensitive\n            log4net.Config.XmlConfigurator.Configure(repository, configUri); // Sensitive\n            log4net.Config.XmlConfigurator.Configure(repository, configStream); // Sensitive\n            log4net.Config.XmlConfigurator.ConfigureAndWatch(repository, configFile); // Sensitive\n\n            log4net.Config.DOMConfigurator.Configure(); // Sensitive\n            log4net.Config.DOMConfigurator.Configure(repository); // Sensitive\n            log4net.Config.DOMConfigurator.Configure(element); // Sensitive\n            log4net.Config.DOMConfigurator.Configure(repository, element); // Sensitive\n            log4net.Config.DOMConfigurator.Configure(configFile); // Sensitive\n            log4net.Config.DOMConfigurator.Configure(repository, configFile); // Sensitive\n            log4net.Config.DOMConfigurator.Configure(configStream); // Sensitive\n            log4net.Config.DOMConfigurator.Configure(repository, configStream); // Sensitive\n            log4net.Config.DOMConfigurator.ConfigureAndWatch(configFile); // Sensitive\n            log4net.Config.DOMConfigurator.ConfigureAndWatch(repository, configFile); // Sensitive\n\n            log4net.Config.BasicConfigurator.Configure(); // Sensitive\n            log4net.Config.BasicConfigurator.Configure(appender); // Sensitive\n            log4net.Config.BasicConfigurator.Configure(appenders); // Sensitive\n            log4net.Config.BasicConfigurator.Configure(repository); // Sensitive\n            log4net.Config.BasicConfigurator.Configure(repository, appender); // Sensitive\n            log4net.Config.BasicConfigurator.Configure(repository, appenders); // Sensitive\n        }\n    }\n}\n\nNLog: configure programmatically\n\nnamespace Logging\n{\n    class NLogLogging\n    {\n        void Foo(NLog.Config.LoggingConfiguration config) {\n            NLog.LogManager.Configuration = config; // Sensitive, this changes the logging configuration.\n        }\n    }\n}\n\nSerilog\n\nnamespace Logging\n{\n    class SerilogLogging\n    {\n        void Foo() {\n            new Serilog.LoggerConfiguration(); // Sensitive\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   OWASP Top 10 2017 Category A10 -\n  Insufficient Logging &amp; Monitoring \n   MITRE, CWE-532 - Information Exposure Through Log Files \n   MITRE, CWE-117 - Improper Output Neutralization for Logs \n   MITRE, CWE-778 - Insufficient Logging \n   SANS Top 25 - Porous Defenses \n\n\n"
    },
    {
      "Code": "4790",
      "Title": "Using weak hashing algorithms is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4790",
      "Description": "Cryptographic hash algorithms such as MD2, MD4, MD5, MD6, HAVAL-128,\nHMAC-MD5, DSA (which uses SHA-1), RIPEMD, RIPEMD-128, RIPEMD-160,\nHMACRIPEMD160 and SHA-1 are no longer considered secure, because it is possible to have collisions (little\ncomputational effort is enough to find two or more different inputs that produce the same hash).\nAsk Yourself Whether\nThe hashed value is used in a security context like:\n\n   User-password storage. \n   Security token generation (used to confirm e-mail when registering on a website, reset password, etc …​). \n   To compute some message integrity. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\nSafer alternatives, such as SHA-256, SHA-512, SHA-3 are recommended, and for password hashing, it’s even\nbetter to use algorithms that do not compute too \"quickly\", like bcrypt, scrypt, argon2 or pbkdf2\nbecause it slows down brute force attacks.\nSensitive Code Example\n\nvar hashProvider1 = new MD5CryptoServiceProvider(); // Sensitive\nvar hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName(\"MD5\"); // Sensitive\nvar hashProvider3 = new SHA1Managed(); // Sensitive\nvar hashProvider4 = HashAlgorithm.Create(\"SHA1\"); // Sensitive\n\nCompliant Solution\n\nvar hashProvider1 = new SHA512Managed(); // Compliant\nvar hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName(\"SHA512Managed\"); // Compliant\nvar hashProvider3 = HashAlgorithm.Create(\"SHA512Managed\"); // Compliant\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   Mobile AppSec\n  Verification Standard - Cryptography Requirements \n   OWASP Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography \n   MITRE, CWE-327 - Use of a Broken or Risky Cryptographic Algorithm \n   MITRE, CWE-916 - Use of Password Hash With Insufficient Computational Effort\n  \n   SANS Top 25 - Porous Defenses \n\n\n"
    },
    {
      "Code": "4502",
      "Title": "Disabling CSRF protections is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4502",
      "Description": "A cross-site request forgery (CSRF) attack occurs when a trusted user of a web application can be forced, by an attacker, to perform sensitive\nactions that he didn’t intend, such as updating his profile or sending a message, more generally anything that can change the state of the\napplication.\nThe attacker can trick the user/victim to click on a link, corresponding to the privileged action, or to visit a malicious web site that embeds a\nhidden web request and as web browsers automatically include cookies, the actions can be authenticated and sensitive.\nAsk Yourself Whether\n\n   The web application uses cookies to authenticate users. \n   There exist sensitive operations in the web application that can be performed when the user is authenticated. \n   The state / resources of the web application can be modified by doing HTTP POST or HTTP DELETE requests for example. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Protection against CSRF attacks is strongly recommended:\n    \n       to be activated by default for all unsafe HTTP\n      methods. \n       implemented, for example, with an unguessable CSRF token \n      \n   Of course all sensitive operations should not be performed with safe HTTP methods like GET which are designed to be\n  used only for information retrieval. \n\nNoncompliant Code Example\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    // ...\n    services.AddControllersWithViews(options =&gt; options.Filters.Add(new IgnoreAntiforgeryTokenAttribute())); // Sensitive\n    // ...\n}\n\n\n[HttpPost, IgnoreAntiforgeryToken] // Sensitive\npublic IActionResult ChangeEmail(ChangeEmailModel model) =&gt; View(\"~/Views/...\");\n\nCompliant Solution\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    // ...\n    services.AddControllersWithViews(options =&gt; options.Filters.Add(new AutoValidateAntiforgeryTokenAttribute()));\n    // or\n    services.AddControllersWithViews(options =&gt; options.Filters.Add(new ValidateAntiForgeryTokenAttribute()));\n    // ...\n}\n\n\n[HttpPost]\n[AutoValidateAntiforgeryToken]\npublic IActionResult ChangeEmail(ChangeEmailModel model) =&gt; View(\"~/Views/...\");\n\nSee\n\n   MITRE, CWE-352 - Cross-Site Request Forgery (CSRF) \n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   OWASP: Cross-Site Request Forgery \n   SANS Top 25 - Insecure Interaction Between Components \n\n\n"
    },
    {
      "Code": "2257",
      "Title": "Using non-standard cryptographic algorithms is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2257",
      "Description": "The use of a non-standard algorithm is dangerous because a determined attacker may be able to break the algorithm and compromise whatever data has\nbeen protected. Standard algorithms like AES, RSA, SHA, …​ should be used instead.\nThis rule tracks custom implementation of these types from System.Security.Cryptography namespace:\n\n   AsymmetricAlgorithm \n   AsymmetricKeyExchangeDeformatter \n   AsymmetricKeyExchangeFormatter \n   AsymmetricSignatureDeformatter \n   AsymmetricSignatureFormatter \n   DeriveBytes \n   HashAlgorithm \n   ICryptoTransform \n   SymmetricAlgorithm \n\nRecommended Secure Coding Practices\n\n   Use a standard algorithm instead of creating a custom one. \n\nSensitive Code Example\n\npublic class CustomHash : HashAlgorithm // Noncompliant\n{\n    private byte[] result;\n\n    public override void Initialize() =&gt; result = null;\n    protected override byte[] HashFinal() =&gt; result;\n\n    protected override void HashCore(byte[] array, int ibStart, int cbSize) =&gt;\n        result ??= array.Take(8).ToArray();\n}\n\nCompliant Solution\n\nSHA256 mySHA256 = SHA256.Create()\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   CWE-327 - Use of a Broken or Risky Cryptographic Algorithm \n   SANS Top 25 - Porous Defenses \n   Derived from FindSecBugs rule MessageDigest is Custom\n  \n\n\n"
    },
    {
      "Code": "2245",
      "Title": "Using pseudorandom number generators (PRNGs) is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2245",
      "Description": "Using pseudorandom number generators (PRNGs) is security-sensitive. For example, it has led in the past to the following vulnerabilities:\n\n   CVE-2013-6386 \n   CVE-2006-3419 \n   CVE-2008-4102 \n\nWhen software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that\nwill be generated, and use this guess to impersonate another user or access sensitive information.\nAs the System.Random class relies on a pseudorandom number generator, it should not be used for security-critical applications or for\nprotecting sensitive data. In such context, the System.Cryptography.RandomNumberGenerator class which relies on a cryptographically\nstrong random number generator (RNG) should be used in place.\nAsk Yourself Whether\n\n   the code using the generated value requires it to be unpredictable. It is the case for all encryption mechanisms or when a secret value, such\n  as a password, is hashed. \n   the function you use generates a value which can be predicted (pseudo-random). \n   the generated value is used multiple times. \n   an attacker can access the generated value. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Only use random number generators which are recommended by\n  OWASP or any other trusted organization. \n   Use the generated random values only once. \n   You should not expose the generated random value. If you have to store it, make sure that the database or file is secure. \n\nSensitive Code Example\n\nvar random = new Random(); // Sensitive use of Random\nbyte[] data = new byte[16];\nrandom.NextBytes(data);\nreturn BitConverter.ToString(data); // Check if this value is used for hashing or encryption\n\nCompliant Solution\n\nusing System.Security.Cryptography;\n...\nvar randomGenerator = RandomNumberGenerator.Create(); // Compliant for security-sensitive use cases\nbyte[] data = new byte[16];\nrandomGenerator.GetBytes(data);\nreturn BitConverter.ToString(data);\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   Mobile AppSec\n  Verification Standard - Cryptography Requirements \n   OWASP Mobile Top 10 2016 Category M5 -\n  Insufficient Cryptography \n   MITRE, CWE-338 - Use of Cryptographically Weak Pseudo-Random Number Generator\n  (PRNG) \n   MITRE, CWE-330 - Use of Insufficiently Random Values \n   MITRE, CWE-326 - Inadequate Encryption Strength \n   MITRE, CWE-1241 - Use of Predictable Algorithm in Random Number Generator \n   Derived from FindSecBugs rule Predictable Pseudo Random Number\n  Generator \n\n\n"
    },
    {
      "Code": "927",
      "Title": "Parameter names should match base declaration and other partial definitions",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-927",
      "Description": "The name of a parameter in an externally visible. This rule raises an issue when method override does not match the name of the parameter in the\nbase declaration of the method, or the name of the parameter in the interface declaration of the method or the name of any other partial\ndefinition.\nNoncompliant Code Example\n\npartial class Point\n{\n  partial void MoveVertically(int z);\n}\n\npartial class Point\n{\n  int x = 0;\n  int y = 0;\n  int z = 0;\n\n  partial void MoveVertically(int y)  // Noncompliant\n  {\n    this.y = y;\n  }\n}\n\ninterface IFoo\n{\n  void Bar(int i);\n}\n\nclass Foo : IFoo\n{\n  void Bar(int z) // Noncompliant, parameter name should be i\n  {\n  }\n}\n\nCompliant Solution\n\npartial class Point\n{\n  partial void MoveVertically(int z);\n}\n\npartial class Point\n{\n  int x = 0;\n  int y = 0;\n  int z = 0;\n\n  partial void MoveVertically(int z)\n  {\n    this.z = z;\n  }\n}\n\ninterface IFoo\n{\n  void Bar(int i);\n}\n\nclass Foo : IFoo\n{\n  void Bar(int i)\n  {\n  }\n}\n\n\n"
    },
    {
      "Code": "5034",
      "Title": "\"ValueTask\" should be consumed correctly",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5034",
      "Description": "ValueTask&lt;TResult&gt; was introduced in .NET Core 2.0 to optimize memory allocation when functions\nreturn their results synchronously.\nValueTask and ValueTask&lt;TResult&gt; should never be used in the following ways as it could result in\na race condition:\n\n   Calling await multiple times on a ValueTask / ValueTask&lt;TResult&gt;*. The wrapped object may have been reused by\n  another operation. This differs from Task / Task&lt;TResult&gt;, on which you can await multiple times and always get the same result.\n  \n   Calling await concurrently on a ValueTask / ValueTask&lt;TResult&gt;*. The underlying object is not thread safe.\n  What’s more, it has the same effect as awaiting multiple times a ValueTask / ValueTask&lt;TResult&gt;. This again differs from\n  Task / Task&lt;TResult&gt;, which support concurrent await. \n   Using .Result or .GetAwaiter().GetResult() without checking if the operation completed*. IValueTaskSource /\n  IValueTaskSource&lt;TResult&gt; implementations are not required to block until the operation completes. On the other hand, Task /\n  Task&lt;TResult&gt; blocks the call until the task completes. \n\nIt is recommended to use ValueTask / ValueTask&lt;TResult&gt; either by calling \"await\" on the function returning it, optionally\ncalling ConfigureAwait(false) on it, or by calling .AsTask() on it.\nThis rule raises an issue when the following operations are performed on a ValueTask / ValueTask&lt;TResult&gt; instance:\n\n   Awaiting the instance multiple times. \n   Calling AsTask multiple times. \n   Using .Result or .GetAwaiter().GetResult() multiple times \n   Using .Result or .GetAwaiter().GetResult() when the operation has not yet completed \n   Using more than one of these ways to consume the instance. \n\nNoncompliant Code Example\n\nValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync();\nint result = await vt;\nint result2 = await vt; // Noncompliant, variable is awaited multiple times\n\nint value = SomeValueTaskReturningMethodAsync().GetAwaiter().GetResult(); // Noncompliant, uses GetAwaiter().GetResult() when it's not known to be done\n\nCompliant Solution\n\nint result = await SomeValueTaskReturningMethodAsync();\n\nint result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false);\n\nTask&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask();\n\nExceptions\nThis rule does not raise any issue when a ValueTask / ValueTask&lt;TResult&gt; is awaited multiple time in a loop.\nSee\n\n   ValueTask&lt;TResult&gt; official documentation\n  \n   Understanding the Whys,\n  Whats, and Whens of ValueTask \n\n\n"
    },
    {
      "Code": "4635",
      "Title": "String offset-based methods should be preferred for finding substrings from offsets",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4635",
      "Description": "Looking for a given substring starting from a specified offset can be achieved by such code: str.Substring(startIndex).IndexOf(char1).\nThis works well, but it creates a new string for each call to the Substring method. When this is done in a loop, a lot of\nstrings are created for nothing, which can lead to performance problems if str is large.\nTo avoid performance problems, string.Substring(startIndex) should not be chained with the following methods:\n\n   IndexOf \n   IndexOfAny \n   LastIndexOf \n   LastIndexOfAny \n\nFor each of these methods, another method with an additional parameter is available to specify an offset.\nUsing these methods gives the same result while avoiding the creation of additional String instances.\nNoncompliant Code Example\n\nstr.Substring(StartIndex).IndexOf(char1); // Noncompliant; a new string is going to be created by \"Substring\"\n\nCompliant Solution\n\nstr.IndexOf(char1, startIndex) - startIndex;\n\n\n"
    },
    {
      "Code": "4524",
      "Title": "\"default\" clauses should be first or last",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4524",
      "Description": "switch can contain a default clause for various reasons: to handle unexpected values, to show that all the cases were\nproperly considered.\nFor readability purpose, to help a developer to quickly find the default behavior of a switch statement, it is recommended to put the\ndefault clause at the end of the switch statement. This rule raises an issue if the default clause is not the\nfirst or the last one of the switch's cases.\nNoncompliant Code Example\n\nswitch (param)\n{\n    case 0:\n      DoSomething();\n      break;\n    default: // default clause should be the first or last one\n      Error();\n      break;\n    case 1:\n      DoSomethingElse();\n      break;\n}\n\nCompliant Solution\n\nswitch (param)\n{\n    case 0:\n      DoSomething();\n      break;\n    case 1:\n      DoSomethingElse();\n      break;\n    default:\n      Error();\n      break;\n}\n\n\n"
    },
    {
      "Code": "4487",
      "Title": "Unread \"private\" fields should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4487",
      "Description": "Private fields only used to store values without reading them later is a case of dead store. So changing the value of such field is useless and\nmost probably indicates a serious error in the code.\nNoncompliant Code Example\n\npublic class Rectangle\n{\n  private readonly int length;\n  private readonly int width;  // width is written but never read\n\n  public Rectangle(int length, int width)\n  {\n    this.length = length;\n    this.width = width;\n  }\n\n  public int Surface\n  {\n    get\n    {\n      return length * length;\n    }\n  }\n}\n\nCompliant Solution\n\npublic class Rectangle\n{\n  private readonly int length;\n  private readonly int width;\n\n  public Rectangle(int length, int width)\n  {\n    this.length = length;\n    this.width= width;\n  }\n\n  public int Surface\n  {\n    get\n    {\n      return length * width;\n    }\n  }\n}\n\nSee\n\n   MITRE, CWE-563 - Assignment to Variable without Use ('Unused Variable') \n\n\n"
    },
    {
      "Code": "4019",
      "Title": "Base class methods should not be hidden",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4019",
      "Description": "When a method in a derived class has the same name as a method in the base class but with a signature that only differs by types that are weakly\nderived (e.g. object vs string), the result is that the base method becomes hidden.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  class Foo\n  {\n    internal void SomeMethod(string s1, string s2) { }\n  }\n\n  class Bar : Foo\n  {\n    internal void SomeMethod(string s1, object o2) { }  // Noncompliant\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  class Foo\n  {\n    internal void SomeMethod(string s1, string s2) { }\n  }\n\n  class Bar : Foo\n  {\n    internal void SomeOtherMethod(string s1, object o2) { }\n  }\n}\n\n\n"
    },
    {
      "Code": "4015",
      "Title": "Inherited member visibility should not be decreased",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4015",
      "Description": "Changing an inherited member to private will not prevent access to the base class implementation.\nThis rule raises an issue when a private method in an unsealed type has a signature that is identical to a public method\ndeclared in a base type.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void SomeMethod(int count) { }\n  }\n  public class Bar:Foo\n  {\n    private void SomeMethod(int count) { } // Noncompliant\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void SomeMethod(int count) { }\n  }\n  public sealed class Bar : Foo\n  {\n    private void SomeMethod(int count) { }\n  }\n}\n\n\n"
    },
    {
      "Code": "3998",
      "Title": "Threads should not lock on objects with weak identity",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3998",
      "Description": "A thread acquiring a lock on an object that can be accessed across application domain boundaries runs the risk of being blocked by another thread\nin a different application domain. Objects that can be accessed across application domain boundaries are said to have weak identity. Types with weak\nidentity are:\n\n   MarshalByRefObject \n   ExecutionEngineException \n   OutOfMemoryException \n   StackOverflowException \n   String \n   MemberInfo \n   ParameterInfo \n   Thread \n\nNoncompliant Code Example\n\npublic class Sample\n{\n    string myString = \"foo\";\n\n    public void Go()\n    {\n        lock (myString) { } // Noncompliant\n    }\n}\n\nCompliant Solution\n\npublic class Sample\n{\n    private readonly static string thisLock = new object();\n\n    public void Go()\n    {\n        lock (thisLock) { }\n    }\n}\n\n\n"
    },
    {
      "Code": "3973",
      "Title": "A conditionally executed single line should be denoted by indentation",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3973",
      "Description": "In the absence of enclosing curly braces, the line immediately after a conditional is the one that is conditionally executed. By both convention\nand good practice, such lines are indented. In the absence of both curly braces and indentation the intent of the original programmer is entirely\nunclear and perhaps not actually what is executed. Additionally, such code is highly likely to be confusing to maintainers.\nNoncompliant Code Example\n\nif (condition)  // Noncompliant\nDoTheThing();\n\nDoTheOtherThing();\nSomethingElseEntirely();\n\nFoo();\n\nCompliant Solution\n\nif (condition)\n  DoTheThing();\n\nDoTheOtherThing();\nSomethingElseEntirely();\n\nFoo();\n\n\n"
    },
    {
      "Code": "3972",
      "Title": "Conditionals should start on new lines",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3972",
      "Description": "Code is clearest when each statement has its own line. Nonetheless, it is a common pattern to combine on the same line an if and its\nresulting then statement. However, when an if is placed on the same line as the closing } from a preceding\nthen, else or else if part, it is either an error - else is missing - or the invitation to a future error as\nmaintainers fail to understand that the two statements are unconnected.\nNoncompliant Code Example\n\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n\nCompliant Solution\n\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n\nOr\n\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n\n\n"
    },
    {
      "Code": "3904",
      "Title": "Assemblies should have version information",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3904",
      "Description": "If no AssemblyVersionAttribute is provided, the same default version will be used for every build. Since the version number is used by\nThe .NET Framework to uniquely identify an assembly this can lead to broken dependencies.\nNoncompliant Code Example\n\nusing System.Reflection;\n\n[assembly: AssemblyTitle(\"MyAssembly\")] // Noncompliant\n\nnamespace MyLibrary\n{\n}\n\nCompliant Solution\n\nusing System.Reflection;\n\n[assembly: AssemblyTitle(\"MyAssembly\")]\n[assembly: AssemblyVersion(\"1.2.125.0\")]\n\nnamespace MyLibrary\n{\n}\n\n\n"
    },
    {
      "Code": "3871",
      "Title": "Exception types should be \"public\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3871",
      "Description": "The point of having custom exception types is to convey more information than is available in standard types. But custom exception types must be\npublic for that to work.\nIf a method throws a non-public exception, the best you can do on the caller’s side is to catch the closest public base\nof the class. That is, you lose all that custom information you created the exception type to pass.\nNoncompliant Code Example\n\ninternal class MyException : Exception   // Noncompliant\n{\n  // ...\n}\n\nCompliant Solution\n\npublic class MyException : Exception\n{\n  // ...\n}\n\nExceptions\nThis rule ignores Exception types that are not derived directly from System.Exception, System.SystemException, or\nSystem.ApplicationException.\nSee\n\n   OWASP Top 10 2017 Category A10 -\n  Insufficient Logging &amp; Monitoring \n\n\n"
    },
    {
      "Code": "3776",
      "Title": "Cognitive Complexity of methods should not be too high",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3776",
      "Description": "Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be\ndifficult to maintain.\nSee\n\n   Cognitive Complexity \n\n\n"
    },
    {
      "Code": "3600",
      "Title": "\"params\" should not be introduced on overrides",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3600",
      "Description": "Adding params to a method override has no effect. The compiler accepts it, but the callers won’t be able to benefit from the added\nmodifier.\nNoncompliant Code Example\n\nclass Base\n{\n  public virtual void Method(int[] numbers)\n  {\n    ...\n  }\n}\nclass Derived : Base\n{\n  public override void Method(params int[] numbers) // Noncompliant, method can't be called with params syntax.\n  {\n    ...\n  }\n}\n\nCompliant Solution\n\nclass Base\n{\n  public virtual void Method(int[] numbers)\n  {\n    ...\n  }\n}\nclass Derived : Base\n{\n  public override void Method(int[] numbers)\n  {\n    ...\n  }\n}\n\n\n"
    },
    {
      "Code": "3451",
      "Title": "\"[DefaultValue]\" should not be used when \"[DefaultParameterValue]\" is meant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3451",
      "Description": "The use of [DefaultValue] with [Optional] has no more effect than [Optional] alone. That’s because\n[DefaultValue] doesn’t actually do anything; it merely indicates the intent for the value. More than likely, [DefaultValue]\nwas used in confusion instead of [DefaultParameterValue].\nNoncompliant Code Example\n\nclass MyClass\n{\n    public void DoStuff([Optional][DefaultValue(4)]int i, int j = 5)  // Noncompliant\n    {\n        Console.WriteLine(i);\n    }\n\n    public static void Main()\n    {\n        new MyClass().DoStuff(); // prints 0\n    }\n}\n\nCompliant Solution\n\nclass MyClass\n{\n    public void DoStuff([Optional][DefaultParameterValue(4)]int i, int j = 5)\n    {\n        Console.WriteLine(i);\n    }\n\n    public static void Main()\n    {\n        new MyClass().DoStuff(); // prints 4\n    }\n}\n\n\n"
    },
    {
      "Code": "3447",
      "Title": "\"[Optional]\" should not be used on \"ref\" or \"out\" parameters",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3447",
      "Description": "The use of ref or out in combination with [Optional] is both confusing and contradictory.\n[Optional] indicates that the parameter doesn’t have to be provided, while out and ref mean that the parameter\nwill be used to return data to the caller (ref additionally indicates that the parameter may also be used to pass data into the\nmethod).\nThus, making it [Optional] to provide the parameter in which you will be passing back the method results doesn’t make sense. In fact,\nthe compiler will raise an error on such code. Unfortunately, it raises the error on method calls where the [Optional] parameter has been\nomitted, not the source of the problem, the method declaration.\nNoncompliant Code Example\n\nclass MyClass\n{\n    public void DoStuff([Optional] ref int i) // Noncompliant\n    {\n        Console.WriteLine(i);\n    }\n\n    public static void Main()\n    {\n        new MyClass().DoStuff(); // This doesn't compile, CS7036 shows\n    }\n}\n\nCompliant Solution\n\nclass MyClass\n{\n  public void DoStuff(ref int i)\n  {\n    Console.WriteLine(i);\n  }\n\n  public static void Main()\n  {\n    var i = 42;\n    new MyClass().DoStuff(ref i);\n  }\n}\n\n\n"
    },
    {
      "Code": "3265",
      "Title": "Non-flags enums should not be used in bitwise operations",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3265",
      "Description": "enums are usually used to identify distinct elements in a set of values. However enums can be treated as bit fields and\nbitwise operations can be used on them to combine the values. This is a good way of specifying multiple elements of set with a single value. When\nenums are used this way, it is a best practice to mark the enum with the FlagsAttribute.\nNoncompliant Code Example\n\nenum Permissions\n{\n  None = 0,\n  Read = 1,\n  Write = 2,\n  Execute = 4\n}\n// ...\n\nvar x = Permissions.Read | Permissions.Write;  // Noncompliant; enum is not marked with [Flags]\n\nCompliant Solution\n\n[Flags]\nenum Permissions\n{\n  None = 0,\n  Read = 1,\n  Write = 2,\n  Execute = 4\n}\n// ...\n\nvar x = Permissions.Read | Permissions.Write;\n\n\n"
    },
    {
      "Code": "3218",
      "Title": "Inner class members should not shadow outer class \"static\" or type members",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3218",
      "Description": "It’s possible to name the members of an inner class the same as the static members of its enclosing class - possible, but a bad idea.\nThat’s because maintainers may be confused about which members are being used where. Instead the inner class' members should be renamed and all the\nreferences updated.\nNoncompliant Code Example\n\nclass Outer\n{\n  public static int A;\n\n  public class Inner\n  {\n    public int A; //Noncompliant\n    public int MyProp\n    {\n      get { return A; }  // Returns inner A. Was that intended?\n    }\n  }\n}\n\nAfter a rename\n\nclass Outer\n{\n  public static int A;\n\n  public class Inner\n  {\n    public int B;\n    public int MyProp\n    {\n      get { return A; }  // Still compiles and runs but functionality has changed\n    }\n  }\n}\n\nCompliant Solution\n\nclass Outer\n{\n  public static int A;\n\n  public class Inner\n  {\n    public int InnerA;\n    public int MyProp\n    {\n      get { return InnerA; }\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "3217",
      "Title": "\"Explicit\" conversions of \"foreach\" loops should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3217",
      "Description": "The foreach statement was introduced in the C# language prior to generics to make it easier to work with the non-generic collections\navailable at that time such as ArrayList. The foreach statements allows you to downcast elements of a collection of\nObjects to any other type. The problem is that to achieve the cast, the foreach statements silently performs\nexplicit type conversion, which at runtime can result in an InvalidCastException.\nC# code iterating on generic collections or arrays should not rely on foreach statement’s silent explicit\nconversions.\nNoncompliant Code Example\n\npublic class Fruit { }\npublic class Orange : Fruit { }\npublic class Apple : Fruit { }\n\nclass MyTest\n{\n  public void Test()\n  {\n    var fruitBasket = new List&lt;Fruit&gt;();\n    fruitBasket.Add(new Orange());\n    fruitBasket.Add(new Orange());\n    // fruitBasket.Add(new Apple());  // uncommenting this line will make both foreach below throw an InvalidCastException\n\n    foreach (Fruit fruit in fruitBasket)\n    {\n      var orange = (Orange)fruit; // This \"explicit\" conversion is hidden within the foreach loop below\n      ...\n    }\n\n    foreach (Orange orange in fruitBasket) // Noncompliant\n    {\n      ...\n    }\n  }\n}\n\nCompliant Solution\n\nvar fruitBasket = new List&lt;Orange&gt;();\nfruitBasket.Add(new Orange());\nfruitBasket.Add(new Orange());\n// fruitBasket.Add(new Apple());  // uncommenting this line won't compile\n\nforeach (Orange orange in fruitBasket)\n{\n  ...\n}\n\nor\n\nvar fruitBasket = new List&lt;Fruit&gt;();\nfruitBasket.Add(new Orange());\nfruitBasket.Add(new Orange());\nfruitBasket.Add(new Apple());\n\nforeach (Orange orange in fruitBasket.OfType&lt;Orange&gt;())\n{\n  ...\n}\n\nExceptions\nThe rule ignores iterations on collections of objects. This includes legacy code that uses ArrayList. Furthermore, the\nrule does not report on cases when user defined conversions are being called.\n\n"
    },
    {
      "Code": "2696",
      "Title": "Instance members should not write to \"static\" fields",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2696",
      "Description": "Correctly updating a static field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple\nclass instances and/or multiple threads in play.\nThis rule raises an issue each time a static field is updated from a non-static method or property.\nNoncompliant Code Example\n\npublic class MyClass\n{\n  private static int count = 0;\n\n  public void DoSomething()\n  {\n    //...\n    count++;  // Noncompliant\n  }\n}\n\n\n"
    },
    {
      "Code": "2692",
      "Title": "\"IndexOf\" checks should not be for positive numbers",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2692",
      "Description": "Most checks against an IndexOf value compare it with -1 because 0 is a valid index. Any checks which look for values &gt;\n0 ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a value in a string,\nList, or an array, consider using the Contains method instead.\nThis rule raises an issue when an IndexOf value retrieved from a string, List or array is tested against\n&gt; 0.\nThis rule also raises an issue when IndexOfAny, LastIndexOf or LastIndexOfAny from a string is\ntested against &gt; 0\nNoncompliant Code Example\n\nstring color = \"blue\";\nstring name = \"ishmael\";\n\nList&lt;string&gt; strings = new List&lt;string&gt;();\nstrings.Add(color);\nstrings.Add(name);\nstring[] stringArray = strings.ToArray();\n\nif (strings.IndexOf(color) &gt; 0) // Noncompliant\n{\n  // ...\n}\n\nif (name.IndexOf(\"ish\") &gt; 0) // Noncompliant\n{\n  // ...\n}\n\nif (name.IndexOf(\"ae\") &gt; 0) // Noncompliant\n{\n  // ...\n}\n\nif (Array.IndexOf(stringArray, color) &gt; 0) // Noncompliant\n{\n  // ...\n}\n\nCompliant Solution\n\nstring color = \"blue\";\nstring name = \"ishmael\";\n\nList&lt;string&gt; strings = new List&lt;string&gt; ();\nstrings.Add(color);\nstrings.Add(name);\nstring[] stringArray = strings.ToArray();\n\nif (strings.IndexOf(color) &gt; -1)\n{\n  // ...\n}\n\nif (name.IndexOf(\"ish\") &gt;= 0)\n{\n  // ...\n}\n\nif (name.Contains(\"ae\"))\n{\n  // ...\n}\n\nif (Array.IndexOf(stringArray, color) &gt;= 0)\n{\n  // ...\n}\n\n\n"
    },
    {
      "Code": "2479",
      "Title": "Whitespace and control characters in string literals should be explicit",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2479",
      "Description": "Non-encoded control characters and whitespace characters are often injected in the source code because of a bad manipulation. They are either\ninvisible or difficult to recognize, which can result in bugs when the string is not what the developer expects. If you actually need to use a control\ncharacter use their encoded version (ex: ASCII \\n,\\t,…​ or Unicode U+000D, U+0009,…​).\nThis rule raises an issue when the following characters are seen in a literal string:\n\n   ASCII control character. (character index &lt; 32 or = 127) \n   Unicode whitespace characters. \n   Unicode C0 control characters \n   Unicode characters U+200B, U+200C, U+200D, U+2060, U+FEFF, U+2028, U+2029 \n\nNo issue will be raised on the simple space character. Unicode U+0020, ASCII 32.\nNoncompliant Code Example\n\nstring tabInside = \"A\tB\";  // Noncompliant, contains a tabulation\nstring zeroWidthSpaceInside = \"foo​bar\"; // Noncompliant, it contains a U+200B character inside\nConsole.WriteLine(zeroWidthSpaceInside); // Prints \"foo?bar\"\n\nCompliant Solution\n\nstring tabInside = \"A\\tB\";  // Compliant, uses escaped value\nstring zeroWidthSpaceInside = \"foo\\u200Bbar\";  // Compliant, uses escaped value\nConsole.WriteLine(zeroWidthSpaceInside); // Prints \"foo?bar\"\n\nExceptions\nVerbatim string literals have no escape character mechanism.\n\n"
    },
    {
      "Code": "2365",
      "Title": "Properties should not make collection or array copies",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2365",
      "Description": "Most developers expect property access to be as efficient as field access. However, if a property returns a copy of an array or collection, it will\nbe much slower than simple field access, contrary to the caller’s likely expectations. Therefore, such properties should be refactored into methods so\nthat callers are not surprised by the unexpectedly poor performance.\nThis rule detects calls to ToList, ToArray and array Clone.\nNoncompliant Code Example\n\nprivate List&lt;string&gt; _foo = new List&lt;string&gt; { \"a\", \"b\", \"c\" };\npublic IEnumerable&lt;string&gt; Foo  // Noncompliant\n{\n    get\n    {\n        return _foo.ToList();\n    }\n}\n\nprivate string[] _bar = new string[] { \"a\", \"b\", \"c\" };\npublic IEnumerable&lt;string&gt; Bar // Noncompliant\n{\n    get\n    {\n        return (string[])_bar.Clone();\n    }\n}\n\nCompliant Solution\n\nprivate List&lt;string&gt; _foo = new List&lt;string&gt; { \"a\", \"b\", \"c\" };\nprivate string[] _bar = new string[] { \"a\", \"b\", \"c\" };\n\npublic IEnumerable&lt;string&gt; GetFoo()\n{\n    return _foo.ToList();\n}\n\npublic IEnumerable&lt;string&gt; GetBar()\n{\n    return (string[])_bar.Clone();\n}\n\n\n"
    },
    {
      "Code": "2346",
      "Title": "Flags enumerations zero-value members should be named \"None\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2346",
      "Description": "Consistent use of \"None\" in flags enumerations indicates that all flag values are cleared. The value 0 should not be used to indicate any other\nstate, since there is no way to check that the bit 0 is set.\nNoncompliant Code Example\n\n[Flags]\nenum FruitType\n{\n    Void = 0,        // Non-Compliant\n    Banana = 1,\n    Orange = 2,\n    Strawberry = 4\n}\n\nCompliant Solution\n\n[Flags]\nenum FruitType\n{\n    None = 0,        // Compliant\n    Banana = 1,\n    Orange = 2,\n    Strawberry = 4\n}\n\n\n"
    },
    {
      "Code": "2291",
      "Title": "Overflow checking should not be disabled for \"Enumerable.Sum\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2291",
      "Description": "Enumerable.Sum() always executes addition in a checked context, so an OverflowException will be thrown if\nthe value exceeds MaxValue even if an unchecked context was specified. Using an unchecked context anyway\nrepresents a misunderstanding of how Sum works.\nThis rule raises an issue when an unchecked context is specified for a Sum on integer types.\nNoncompliant Code Example\n\nvoid Add(List&lt;int&gt; list)\n{\n  int d = unchecked(list.Sum());  // Noncompliant\n\n  unchecked\n  {\n    int e = list.Sum();  // Noncompliant\n  }\n}\n\nCompliant Solution\n\nvoid Add(List&lt;int&gt; list)\n{\n  int d = list.Sum();\n\n  try\n  {\n    int e = list.Sum();\n  }\n  catch (System.OverflowException e)\n  {\n    // exception handling...\n  }\n}\n\nExceptions\nWhen the Sum() call is inside a try-catch block, no issues are reported.\n\nvoid Add(List&lt;int&gt; list)\n{\n  unchecked\n  {\n    try\n    {\n      int e = list.Sum();\n    }\n    catch (System.OverflowException e)\n    {\n      // exception handling...\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "2290",
      "Title": "Field-like events should not be virtual",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2290",
      "Description": "Field-like events are events that do not have explicit add and remove methods. The compiler generates a\nprivate delegate field to back the event, as well as generating the implicit add and remove\nmethods.\nWhen a virtual field-like event is overridden by another field-like event, the behavior of the C# compiler\nis to generate a new private delegate field in the derived class, separate from the parent’s field. This results in multiple\nand separate events being created, which is rarely what’s actually intended.\nTo prevent this, remove the virtual designation from the parent class event.\nNoncompliant Code Example\n\nabstract class Car\n{\n  public virtual event EventHandler OnRefueled; // Noncompliant\n\n  public void Refuel()\n  {\n    // This OnRefueled will always be null\n     if (OnRefueled != null)\n     {\n       OnRefueled(this, null);\n     }\n  }\n}\n\nclass R2 : Car\n{\n  public override event EventHandler OnRefueled;\n}\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    var r2 = new R2();\n    r2.OnRefueled += new EventHandler((o, a) =&gt;\n    {\n      Console.WriteLine(\"This event will never be called\");\n    });\n    r2.Refuel();\n  }\n}\n\nCompliant Solution\n\nabstract class Car\n{\n  public event EventHandler OnRefueled; // Compliant\n\n  public void Refuel()\n  {\n    if (OnRefueled != null)\n    {\n      OnRefueled(this, null);\n    }\n  }\n}\n\nclass R2 : Car {}\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    var r2 = new R2();\n    r2.OnRefueled += new EventHandler((o, a) =&gt;\n    {\n      Console.WriteLine(\"This event will be called\");\n    });\n    r2.Refuel();\n  }\n}\n\n\n"
    },
    {
      "Code": "2223",
      "Title": "Non-constant static fields should not be visible",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2223",
      "Description": "A static field that is neither constant nor read-only is not thread-safe. Correctly accessing these fields from different threads\nneeds synchronization with locks. Improper synchronization may lead to unexpected results, thus publicly visible static fields are best\nsuited for storing non-changing data shared by many consumers. To enforce this intent, these fields should be marked readonly or\nconverted to constants.\nNoncompliant Code Example\n\npublic class Math\n{\n  public static double Pi = 3.14;  // Noncompliant\n}\n\nor\n\npublic class Shape\n{\n  public static Shape Empty = new EmptyShape();  // Noncompliant\n\n  private class EmptyShape : Shape\n  {\n  }\n}\n\nCompliant Solution\n\npublic class Math\n{\n  public const double Pi = 3.14;\n}\n\nor\n\npublic class Shape\n{\n  public static readonly Shape Empty = new EmptyShape();\n\n  private class EmptyShape : Shape\n  {\n  }\n}\n\n\n"
    },
    {
      "Code": "1944",
      "Title": "Inappropriate casts should not be made",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1944",
      "Description": "Inappropriate casts are issues that will lead to unexpected behavior or runtime errors, such as InvalidCastExceptions. The compiler\nwill catch bad casts from one class to another, but not bad casts to interfaces. Nor will it catch nullable values that are known to be null but that\nare cast to their underlying value types anyway.\nIt is much better to use the as operator because it will return null instead of throwing an exception.\nNoncompliant Code Example\n\npublic interface IMyInterface\n{ /* ... */ }\n\npublic class Implementer : IMyInterface\n{ /* ... */ }\n\npublic class MyClass\n{ /* ... */ }\n\npublic static class Program\n{\n  public static void Main()\n  {\n    var myclass = new MyClass();\n    var x = (IMyInterface) myclass; // Noncompliant, InvalidCastException is being thrown\n    var b = myclass is IMyInterface; // Noncompliant, always false\n\n    int? i = null;\n    var ii = (int)i; // Noncompliant, InvalidOperationException is being thrown\n  }\n}\n\nCompliant Solution\n\npublic interface IMyInterface\n{ /* ... */ }\n\npublic class Implementer : IMyInterface\n{ /* ... */ }\n\npublic class MyClass\n{ /* ... */ }\n\npublic static class Program\n{\n  public static void Main()\n  {\n    var myclass = new MyClass();\n    var x = myclass as IMyInterface; // Compliant, but will always be null\n    var b = false;\n\n    int? i = null;\n    if (i.HasValue)\n    {\n      var ii = (int)i;\n    }\n  }\n}\n\nExceptions\nNo issue is reported if the interface has no implementing class in the assembly.\nSee\n\n   MITRE, CWE-588 - Attempt to Access Child of a Non-structure Pointer \n   MITRE, CWE-704 - Incorrect Type Conversion or Cast \n\n\n"
    },
    {
      "Code": "1699",
      "Title": "Constructors should only call non-overridable methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1699",
      "Description": "Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the\nmethod.\nFor example:\n\n   The subclass class constructor starts by calling the parent class constructor. \n   The parent class constructor calls the method, which has been overridden in the child class. \n   If the behavior of the child class method depends on fields that are initialized in the child class constructor, unexpected behavior (like a\n  NullReferenceException) can result, because the fields aren’t initialized yet. \n\nNoncompliant Code Example\n\npublic class Parent\n{\n  public Parent()\n  {\n    DoSomething();  // Noncompliant\n  }\n\n  public virtual void DoSomething() // can be overridden\n  {\n    ...\n  }\n}\n\npublic class Child : Parent\n{\n  private string foo;\n\n  public Child(string foo) // leads to call DoSomething() in Parent constructor which triggers a NullReferenceException as foo has not yet been initialized\n  {\n    this.foo = foo;\n  }\n\n  public override void DoSomething()\n  {\n    Console.WriteLine(this.foo.Length);\n  }\n}\n\n\n"
    },
    {
      "Code": "1215",
      "Title": "\"GC.Collect\" should not be called",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1215",
      "Description": "Calling GC.Collect is rarely necessary, and can significantly affect application performance. That’s because it triggers a blocking\noperation that examines every object in memory for cleanup. Further, you don’t have control over when this blocking cleanup will actually\nrun.\nAs a general rule, the consequences of calling this method far outweigh the benefits unless perhaps you’ve just triggered some event that is unique\nin the run of your program that caused a lot of long-lived objects to die.\nThis rule raises an issue when GC.Collect is invoked.\nNoncompliant Code Example\n\nstatic void Main(string[] args)\n{\n  // ...\n  GC.Collect(2, GCCollectionMode.Optimized); // Noncompliant\n}\n\n\n"
    },
    {
      "Code": "1186",
      "Title": "Methods should not be empty",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1186",
      "Description": "There are several reasons for a method not to have a method body:\n\n   It is an unintentional omission, and should be fixed. \n   It is not yet, or never will be, supported. In this case a NotSupportedException should be thrown. \n   The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. \n\nNoncompliant Code Example\n\npublic override void DoSomething()\n{\n}\n\npublic override void DoSomethingElse()\n{\n}\n\nCompliant Solution\n\npublic override void DoSomething()\n{\n  // Do nothing because of X and Y.\n}\n\npublic override void DoSomethingElse()\n{\n  throw new NotSupportedException();\n}\n\nExceptions\nThe following methods are ignored:\n\n   empty virtual methods, \n   empty methods that override an abstract method, \n   empty overrides in test assemblies. \n\n\n"
    },
    {
      "Code": "1163",
      "Title": "Exceptions should not be thrown in finally blocks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1163",
      "Description": "Throwing an exception from within a finally block will mask any exception which was previously thrown in the try or catch\nblock, and the masked’s exception message and stack trace will be lost.\nNoncompliant Code Example\n\ntry\n{\n  /* some work which end up throwing an exception */\n  throw new ArgumentException();\n}\nfinally\n{\n  /* clean up */\n  throw new InvalidOperationException();       // Noncompliant; will mask the ArgumentException\n}\n\nCompliant Solution\n\ntry\n{\n  /* some work which end up throwing an exception */\n  throw new ArgumentException();\n}\nfinally\n{\n  /* clean up */                       // Compliant\n}\n\n\n"
    },
    {
      "Code": "1006",
      "Title": "Method overrides should not change parameter defaults",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1006",
      "Description": "Default arguments are determined by the static type of the object. If a default argument is different for a parameter in an overriding method, the\nvalue used in the call will be different when calls are made via the base or derived object, which may be contrary to developer expectations.\nDefault parameter values are useless in explicit interface implementations, because the static type of the object will always be the implemented\ninterface. Thus, specifying default values is useless and confusing.\nNoncompliant Code Example\n\nusing System;\n\npublic class Base\n{\n    public virtual void Write(int i = 42)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class Derived : Base\n{\n    public override void Write(int i = 5) // Noncompliant\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var derived = new Derived();\n        derived.Write(); // writes 5\n        Print(derived); // writes 42; was that expected?\n    }\n\n    private static void Print(Base item)\n    {\n        item.Write();\n    }\n}\n\nCompliant Solution\n\nusing System;\n\npublic class Base\n{\n    public virtual void Write(int i = 42)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class Derived : Base\n{\n    public override void Write(int i = 42)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var derived = new Derived();\n        derived.Write(); // writes 42\n        Print(derived);  // writes 42\n    }\n\n    private static void Print(Base item)\n    {\n        item.Write();\n    }\n}\n\n\n"
    },
    {
      "Code": "5773",
      "Title": "Types allowed to be deserialized should be restricted",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5773",
      "Description": "During the deserialization process, the state of an object will be reconstructed from the serialized data stream which can contain dangerous\noperations.\nFor example, a well-known attack vector consists in serializing an object of type TempFileCollection\nwith arbitrary files (defined by an attacker) which will be deleted on the application deserializing this object (when the finalize() method of\nthe TempFileCollection object is called). This kind of types are called \"gadgets\".\nInstead of using BinaryFormatter and similar serializers, it is recommended to use safer alternatives in most of the cases, such as XmlSerializer or DataContractSerializer. If\nit’s not possible then try to mitigate the risk by restricting the types allowed to be deserialized:\n\n   by implementing an \"allow-list\" of types, but keep in mind that novel dangerous types are regularly discovered and this protection could be\n  insufficient over time. \n   or/and implementing a tamper protection, such as message authentication codes (MAC). This way\n  only objects serialized with the correct MAC hash will be deserialized. \n\nNoncompliant Code Example\nFor BinaryFormatter,\nNetDataContractSerializer,\nSoapFormatter\nserializers:\n\nvar myBinaryFormatter = new BinaryFormatter();\nmyBinaryFormatter.Deserialize(stream); // Noncompliant: a binder is not used to limit types during deserialization\n\nJavaScriptSerializer\nshould not use SimpleTypeResolver or other weak resolvers:\n\nJavaScriptSerializer serializer1 = new JavaScriptSerializer(new SimpleTypeResolver()); // Noncompliant: SimpleTypeResolver is unsecure (every types is resolved)\nserializer1.Deserialize&lt;ExpectedType&gt;(json);\n\nLosFormatter should not be used without\nMAC verification:\n\nLosFormatter formatter = new LosFormatter(); // Noncompliant\nformatter.Deserialize(fs);\n\nCompliant Solution\nBinaryFormatter,\nNetDataContractSerializer\n, SoapFormatter\nserializers should use a binder implementing a whitelist approach to limit types during deserialization (at least one exception should be thrown or a\nnull value returned):\n\nsealed class CustomBinder : SerializationBinder\n{\n   public override Type BindToType(string assemblyName, string typeName)\n   {\n       if (!(typeName == \"type1\" || typeName == \"type2\" || typeName == \"type3\"))\n       {\n          throw new SerializationException(\"Only type1, type2 and type3 are allowed\"); // Compliant\n       }\n       return Assembly.Load(assemblyName).GetType(typeName);\n   }\n}\n\nvar myBinaryFormatter = new BinaryFormatter();\nmyBinaryFormatter.Binder = new CustomBinder();\nmyBinaryFormatter.Deserialize(stream);\n\nJavaScriptSerializer\nshould use a resolver implementing a whitelist to limit types during deserialization (at least one exception should be thrown or a null value\nreturned):\n\npublic class CustomSafeTypeResolver : JavaScriptTypeResolver\n{\n   public override Type ResolveType(string id)\n   {\n      if(id != \"ExpectedType\") {\n         throw new ArgumentNullException(\"Only ExpectedType is allowed during deserialization\"); // Compliant\n      }\n      return Type.GetType(id);\n   }\n}\n\nJavaScriptSerializer serializer = new JavaScriptSerializer(new CustomSafeTypeResolver()); // Compliant\nserializer.Deserialize&lt;ExpectedType&gt;(json);\n\nLosFormatter serializer with MAC\nverification:\n\nLosFormatter formatter = new LosFormatter(true, secret); // Compliant\nformatter.Deserialize(fs);\n\nSee\n\n   docs.microsoft.com -\n  BinaryFormatter security guide \n   OWASP Top 10 2017 Category A8 - Insecure Deserialization\n  \n   MITRE, CWE-134 - Use of Externally-Controlled Format String \n   MITRE, CWE-502 - Deserialization of Untrusted Data \n   SANS Top 25 - Risky Resource Management \n   OWASP Deserialization Cheat\n  Sheet \n\n\n"
    },
    {
      "Code": "5144",
      "Title": "Server-side requests should not be vulnerable to forging attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5144",
      "Description": "User supplied data, such as URL parameters, POST data payloads, or cookies, should always be considered untrusted and tainted. Performing requests\nfrom user-controlled data could allow attackers to make arbitrary requests on the internal network or to change their original meaning and thus to\nretrieve or delete sensitive information.\nThe problem could be mitigated in any of the following ways:\n\n   Validate the user provided data, such as the URL and headers, used to construct the request. \n   Redesign the application to not send requests based on user provided data. \n\nNoncompliant Code Example\n\nusing System.IO;\nusing System.Net;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC5144SSRFNoncompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult ReadContentOfURL(string url)\n        {\n            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); // Noncompliant\n\n            HttpWebResponse response = (HttpWebResponse)request.GetResponse();\n            Stream dataStream = response.GetResponseStream();\n            StreamReader reader = new StreamReader(dataStream);\n            string responseFromServer = reader.ReadToEnd();\n\n            reader.Close();\n            dataStream.Close();\n            response.Close();\n            return Content(responseFromServer);\n        }\n    }\n}\n\nCompliant Solution\n\nusing System.Linq;\nusing System.IO;\nusing System.Net;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC5144SSRFCompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        private readonly string[] whiteList = { \"https://www.sonarsource.com\" };\n\n        public IActionResult ReadContentOfURL(string url)\n        {\n            // Match the incoming URL against a whitelist\n            if (!whiteList.Contains(url))\n            {\n                return BadRequest();\n            }\n\n            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); // Noncompliant\n\n            HttpWebResponse response = (HttpWebResponse)request.GetResponse();\n            Stream dataStream = response.GetResponseStream();\n            StreamReader reader = new StreamReader(dataStream);\n            string responseFromServer = reader.ReadToEnd();\n\n            reader.Close();\n            dataStream.Close();\n            response.Close();\n            return Content(responseFromServer);\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A10 - Server-Side Request\n  Forgery (SSRF) \n   OWASP Attack Category - Server Side Request Forgery \n   OWASP Top 10 2017 Category A5 - Broken Access Control \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-641 - Improper Restriction of Names for Files and Other Resources\n  \n   MITRE, CWE-918 - Server-Side Request Forgery (SSRF) \n   SANS Top 25 - Risky Resource Management \n\n\n"
    },
    {
      "Code": "4211",
      "Title": "Members should not have conflicting transparency annotations",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4211",
      "Description": "Transparency attributes, SecurityCriticalAttribute and SecuritySafeCriticalAttribute are used to identify code that\nperforms security-critical operations. The second one indicates that it is safe to call this code from transparent, while the first one does not.\nSince the transparency attributes of code elements with larger scope take precedence over transparency attributes of code elements that are contained\nin the first element a class, for instance, with a SecurityCriticalAttribute can not contain a method with a\nSecuritySafeCriticalAttribute.\nThis rule raises an issue when a member is marked with a System.Security security attribute that has a different transparency than the\nsecurity attribute of a container of the member.\nNoncompliant Code Example\n\nusing System;\nusing System.Security;\n\nnamespace MyLibrary\n{\n\n    [SecurityCritical]\n    public class Foo\n    {\n        [SecuritySafeCritical] // Noncompliant\n        public void Bar()\n        {\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Security;\n\nnamespace MyLibrary\n{\n\n    [SecurityCritical]\n    public class Foo\n    {\n        public void Bar()\n        {\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n\n\n"
    },
    {
      "Code": "4428",
      "Title": "\"PartCreationPolicyAttribute\" should be used with \"ExportAttribute\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4428",
      "Description": "The PartCreationPolicyAttribute attribute, which is part of the Managed Extensibility Framework (MEF), is used to specify how the\nexported object will be created. Therefore it doesn’t make sense not to export this a class with this attribute using the ExportAttribute\nattribute.\nThis rule raises an issue when a class is marked as shared with a PartCreationPolicyAttribute but lacks a\nExportAttribute.\nNoncompliant Code Example\n\n[PartCreationPolicy(CreationPolicy.Any)] // Noncompliant\npublic class FooBar : IFooBar\n{\n}\n\nCompliant Solution\n\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Any)]\npublic class FooBar : IFooBar\n{\n}\n\n\n"
    },
    {
      "Code": "4260",
      "Title": "\"ConstructorArgument\" parameters should exist in constructors",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4260",
      "Description": "When creating a custom Markup Extension that accepts parameters in WPF, the ConstructorArgument markup must be used to identify the\ndiscrete properties that match these parameters. However since this is done via a string, the compiler will not notice if there are typos.\nThis rule raises an issue when the string argument to ConstructorArgumentAttribute doesn’t match any parameter of any constructor.\nNoncompliant Code Example\n\nusing System;\n\nnamespace myLibrary\n{\n  public class MyExtension : MarkupExtension\n  {\n    public MyExtension() { }\n\n    public MyExtension(object value1)\n    {\n      Value1 = value1;\n    }\n\n    [ConstructorArgument(\"value2\")]   // Noncompliant\n    public object Value1 { get; set; }\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace myLibrary\n{\n  public class MyExtension : MarkupExtension\n  {\n    public MyExtension() { }\n\n    public MyExtension(object value1)\n    {\n      Value1 = value1;\n    }\n\n    [ConstructorArgument(\"value1\")]\n    public object Value1 { get; set; }\n  }\n}\n\n\n"
    },
    {
      "Code": "4210",
      "Title": "Windows Forms entry points should be marked with STAThread",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4210",
      "Description": "When an assembly uses Windows Forms (classes and interfaces from the System.Windows.Forms namespace) its entry point should be marked\nwith the STAThreadAttribute to indicate that the threading model should be \"Single-Threaded Apartment\" (STA) which is the only one\nsupported by Windows Forms.\nThis rule raises an issue when the entry point (static void Main method) of an assembly using Windows Forms is not marked as STA.\nNoncompliant Code Example\n\nusing System;\nusing System.Windows.Forms;\n\nnamespace MyLibrary\n{\n    public class MyForm: Form\n    {\n        public MyForm()\n        {\n            this.Text = \"Hello World!\";\n        }\n\n        public static void Main()  // Noncompliant\n        {\n            var form = new MyForm();\n            Application.Run(form);\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Windows.Forms;\n\nnamespace MyLibrary\n{\n    public class MyForm: Form\n    {\n        public MyForm()\n        {\n            this.Text = \"Hello World!\";\n        }\n\n        [STAThread]\n        public static void Main()\n        {\n            var form = new MyForm();\n            Application.Run(form);\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "4143",
      "Title": "Collection elements should not be replaced unconditionally",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4143",
      "Description": "It is highly suspicious when a value is saved for a key or index and then unconditionally overwritten. Such replacements are likely errors.\nNoncompliant Code Example\n\nlist[index] = \"value 1\";\nlist[index] = \"value 2\";  // Noncompliant\n\ndictionary.Add(key, \"value 1\");\ndictionary[key] = \"value 2\"; // Noncompliant\n\n\n"
    },
    {
      "Code": "3984",
      "Title": "Exceptions should not be created without being thrown",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3984",
      "Description": "Creating a new Exception without actually throwing it is useless and is probably due to a mistake.\nNoncompliant Code Example\n\nif (x &lt; 0)\n{\n  new ArgumentException(\"x must be nonnegative\");\n}\n\nCompliant Solution\n\nif (x &lt; 0)\n{\n  throw new ArgumentException(\"x must be nonnegative\");\n}\n\n\n"
    },
    {
      "Code": "3981",
      "Title": "Collection sizes and array length comparisons should make sense",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3981",
      "Description": "The size of a collection and the length of an array are always greater than or equal to zero. So testing that a size or length is greater than or\nequal to zero doesn’t make sense, since the result is always true. Similarly testing that it is less than zero will always return\nfalse. Perhaps the intent was to check the non-emptiness of the collection or array instead.\nNoncompliant Code Example\n\nif(collection.Count &gt;= 0){...}\n\nif(enumerable.Count() &lt; 0){...}\n\nif(array.Length &gt;= 0){...}\n\nbool result = array.Length &gt;=0;\n\nCompliant Solution\n\nif (list.Any()) { ... }\n\nif (list.Count &gt; 0) { ... }\n\nif (array.Length &gt;= 42) { ... }\n\n\n"
    },
    {
      "Code": "3927",
      "Title": "Serialization event handlers should be implemented correctly",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3927",
      "Description": "Serialization event handlers that don’t have the correct signature will simply not be called, thus bypassing any attempts to augment the automated\nde/serialization.\nThis rule raises an issue when a method marked with one of the following attributes is public, static, does not return\nvoid, has type parameters, or does not have a single parameter of type System.Runtime.Serialization.StreamingContext:\n\n   System.Runtime.Serialization.OnSerializingAttribute \n   System.Runtime.Serialization.OnSerializedAttribute \n   System.Runtime.Serialization.OnDeserializingAttribute \n   System.Runtime.Serialization.OnDeserializedAttribute \n\nNoncompliant Code Example\n\n[Serializable]\npublic class Foo\n{\n    [OnSerializing]\n    public void OnSerializing(StreamingContext context) {} // Noncompliant should be private\n\n    [OnSerialized]\n    int OnSerialized(StreamingContext context) {} // Noncompliant should return void\n\n    [OnDeserializing]\n    void OnDeserializing() {} // Noncompliant should have a single parameter of type StreamingContext\n\n    [OnSerializing]\n    public void OnSerializing2&lt;T&gt;(StreamingContext context) {} // Noncompliant should have no type parameters\n\n    [OnDeserialized]\n    void OnDeserialized(StreamingContext context, string str) {} // Noncompliant should have a single parameter of type StreamingContext\n}\n\nCompliant Solution\n\n[Serializable]\npublic class Foo\n{\n    [OnSerializing]\n    private void OnSerializing(StreamingContext context) {}\n\n    [OnSerialized]\n    private void OnSerialized(StreamingContext context) {}\n\n    [OnDeserializing]\n    private void OnDeserializing(StreamingContext context) {}\n\n    [OnDeserialized]\n    private void OnDeserialized(StreamingContext context) {}\n}\n\n\n"
    },
    {
      "Code": "3926",
      "Title": "Deserialization methods should be provided for \"OptionalField\" members",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3926",
      "Description": "Fields marked with System.Runtime.Serialization.OptionalFieldAttribute are serialized just like any other field. But such fields are\nignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to\nset such fields during the deserialization process.\nThis rule raises when at least one field with the System.Runtime.Serialization.OptionalFieldAttribute attribute is declared but one\n(or both) of the following event handlers System.Runtime.Serialization.OnDeserializingAttribute or\nSystem.Runtime.Serialization.OnDeserializedAttribute are not present.\nNoncompliant Code Example\n\n[Serializable]\npublic class Foo\n{\n    [OptionalField(VersionAdded = 2)]\n    int optionalField = 5;\n}\n\nCompliant Solution\n\n[Serializable]\npublic class Foo\n{\n    [OptionalField(VersionAdded = 2)]\n    int optionalField = 5;\n\n    [OnDeserializing]\n    void OnDeserializing(StreamingContext context)\n    {\n\t    optionalField = 5;\n    }\n\n    [OnDeserialized]\n    void OnDeserialized(StreamingContext context)\n    {\n        // Set optionalField if dependent on other deserialized values.\n    }\n}\n\n\n"
    },
    {
      "Code": "3923",
      "Title": "All branches in a conditional structure should not have exactly the same implementation",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3923",
      "Description": "Having all branches in a switch or if chain with the same implementation is an error. Either a copy-paste error was made\nand something different should be executed, or there shouldn’t be a switch/if chain at all.\nNoncompliant Code Example\n\nif (b == 0)  // Noncompliant\n{\n    DoTheThing();\n}\nelse\n{\n    DoTheThing();\n}\n\nint b = a &gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) // Noncompliant\n{\n    case 1:\n        DoSomething();\n        break;\n    case 2:\n        DoSomething();\n        break;\n    case 3:\n        DoSomething();\n        break;\n    default:\n        DoSomething();\n}\n\nExceptions\nThis rule does not apply to if chains without else-s, or to switch-es without default\nclauses.\n\nif (b == 0)    //no issue, this could have been done on purpose to make the code more readable\n{\n    DoSomething();\n}\nelse if (b == 1)\n{\n    DoSomething();\n}\n\n\n"
    },
    {
      "Code": "3903",
      "Title": "Types should be defined in named namespaces",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3903",
      "Description": "Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are\ndefined outside any named namespace are in a global namespace that cannot be referenced in code.\nNoncompliant Code Example\n\npublic class Foo // Noncompliant\n{\n}\n\npublic struct Bar // Noncompliant\n{\n}\n\nCompliant Solution\n\nnamespace SomeSpace\n{\n    public class Foo\n    {\n    }\n\n    public struct Bar\n    {\n    }\n}\n\n\n"
    },
    {
      "Code": "3655",
      "Title": "Empty nullable value should not be accessed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3655",
      "Description": "Nullable value types can hold either a value or null. The value held in the nullable type can be accessed with the Value\nproperty, but .Value throws an InvalidOperationException when the value is null. To avoid the exception, a\nnullable type should always be tested before .Value is accessed.\nNoncompliant Code Example\n\nint? nullable = null;\n...\nUseValue(nullable.Value); // Noncompliant\n\nCompliant Solution\n\nint? nullable = null;\n...\nif (nullable.HasValue)\n{\n  UseValue(nullable.Value);\n}\n\nor\n\nint? nullable = null;\n...\nif (nullable != null)\n{\n  UseValue(nullable.Value);\n}\n\nSee\n\n   MITRE, CWE-476 - NULL Pointer Dereference \n\n\n"
    },
    {
      "Code": "3610",
      "Title": "Nullable type comparison should not be redundant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3610",
      "Description": "Calling GetType() on a nullable object returns the underlying value type. Thus, comparing the returned Type object to\ntypeof(Nullable&lt;SomeType&gt;) doesn’t make sense. The comparison either throws an exception or the result can be known at compile\ntime.\nNoncompliant Code Example\n\nint? nullable = 42;\nbool comparison = nullable.GetType() == typeof(Nullable&lt;int&gt;); // Noncompliant, always false\ncomparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, always true\n\nnullable = null;\ncomparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, calling GetType on a null always throws an exception\n\n\n"
    },
    {
      "Code": "3603",
      "Title": "Methods with \"Pure\" attribute should return a value ",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3603",
      "Description": "Marking a method with the Pure attribute specifies that the method doesn’t make any visible changes; thus, the method should return a\nresult, otherwise the call to the method should be equal to no-operation. So Pure on a void method is either a mistake, or\nthe method doesn’t do any meaningful task.\nNoncompliant Code Example\n\nclass Person\n{\n  private int age;\n  [Pure] // Noncompliant. In this case the method makes a possibly visible state change\n  void ConfigureAge(int age)\n  {\n    ...\n    this.age = age;\n  }\n  ...\n}\n\nCompliant Solution\n\nclass Person\n{\n  private int age;\n\n  void ConfigureAge(int age)\n  {\n    ...\n    this.age = age;\n  }\n  ...\n}\n\n\n"
    },
    {
      "Code": "3598",
      "Title": "One-way \"OperationContract\" methods should have \"void\" return type",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3598",
      "Description": "When declaring a Windows Communication Foundation (WCF) OperationContract method one-way, that service method won’t return any result,\nnot even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return\ntype therefore does not make sense.\nNoncompliant Code Example\n\n[ServiceContract]\ninterface IMyService\n{\n  [OperationContract(IsOneWay = true)]\n  int SomethingHappened(int parameter); // Noncompliant\n}\n\nCompliant Solution\n\n[ServiceContract]\ninterface IMyService\n{\n  [OperationContract(IsOneWay = true)]\n  void SomethingHappened(int parameter);\n}\n\nExceptions\nThe rule doesn’t report if OperationContractAttribute.AsyncPattern is set to true.\n\n"
    },
    {
      "Code": "3466",
      "Title": "Optional parameters should be passed to \"base\" calls",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3466",
      "Description": "Generally, writing the least code that will readably do the job is a good thing, so omitting default parameter values seems to make sense.\nUnfortunately, when you omit them from the base call in an override, you’re not actually getting the job done thoroughly, because you’re\nignoring the value the caller passed in. The result will likely not be what the caller expected.\nNoncompliant Code Example\n\npublic class BaseClass\n{\n    public virtual void MyMethod(int i = 1)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public override void MyMethod(int i = 1)\n    {\n        // ...\n        base.MyMethod(); // Noncompliant; caller's value is ignored\n    }\n\n    static int Main(string[] args)\n    {\n        DerivedClass dc = new DerivedClass();\n        dc.MyMethod(12);  // prints 1\n    }\n}\n\nCompliant Solution\n\npublic class BaseClass\n{\n    public virtual void MyMethod(int i = 1)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public override void MyMethod(int i = 1)\n    {\n        // ...\n        base.MyMethod(i);\n    }\n\n    static int Main(string[] args)\n    {\n        DerivedClass dc = new DerivedClass();\n        dc.MyMethod(12);  // prints 12\n    }\n}\n\n\n"
    },
    {
      "Code": "3453",
      "Title": "Classes should not have only \"private\" constructors",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3453",
      "Description": "A class with only private constructors can’t be instantiated, thus, it seems to be pointless code.\nNoncompliant Code Example\n\npublic class MyClass // Noncompliant\n{\n  private MyClass() { ... }\n}\n\nCompliant Solution\n\npublic class MyClass\n{\n  public MyClass() { ... }\n}\n\nExceptions\nClasses that themselves access their private constructors (singletons or smart enums) are ignored. Classes with only static members\nare also ignored because they are covered by Rule {rule:csharpsquid:S1118}.\n\n"
    },
    {
      "Code": "3346",
      "Title": "Expressions used in \"Debug.Assert\" should not produce side effects",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3346",
      "Description": "An assertion is a piece of code that’s used during development when the compilation debug mode is activated. It allows a program to check itself as\nit runs. When an assertion is true, that means everything is operating as expected.\nIn non-debug mode, all Debug.Assert are automatically left out. So, by contract, the boolean expressions that are evaluated by those\nassertions must absolutely not contain any side effects. Otherwise, when leaving the Debug mode, the functional behavior of the application is not the\nsame anymore.\nThe rule will raise if the method name starts with any of the following remove, delete, add,\npop, update, retain, insert, push, append, clear,\ndequeue, enqueue, dispose, put, or set, although SetEquals will be\nignored.\nNoncompliant Code Example\n\nDebug.Assert(list.Remove(\"dog\"));\n\nCompliant Solution\n\nbool result = list.Remove(\"dog\");\nDebug.Assert(result);\n\n\n"
    },
    {
      "Code": "3343",
      "Title": "Caller information parameters should come at the end of the parameter list",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3343",
      "Description": "Caller information attributes (CallerFilePathAttribute, CallerLineNumberAttribute, and\nCallerMemberNameAttribute) provide a way to get information about the caller of a method through optional parameters. But they only work\nright if their values aren’t provided explicitly. So if you define a method with caller info attributes in the middle of the parameter list, you put\nyour callers in a bad position: they are forced to use named arguments if they want to use the method properly.\nNoncompliant Code Example\n\nvoid TraceMessage([CallerMemberName] string memberName = \"\",\n  [CallerFilePath] string filePath = \"\",\n  [CallerLineNumber] int lineNumber = 0,\n  string message = null)  // Noncompliant\n{\n  /* ... */\n}\n\nCompliant Solution\n\nvoid TraceMessage(string message = null,\n  [CallerMemberName] string memberName = \"\",\n  [CallerFilePath] string filePath = \"\",\n  [CallerLineNumber] int lineNumber = 0)\n{\n  /* ... */\n}\n\n\n"
    },
    {
      "Code": "3263",
      "Title": "Static fields should appear in the order they must be initialized ",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3263",
      "Description": "Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class\nabove the field or fields required for its initialization will yield unexpected results.\nNoncompliant Code Example\n\nclass MyClass\n{\n  public static int X = Y; // Noncompliant; Y at this time is still assigned default(int), i.e. 0\n  public static int Y = 42;\n}\n\nCompliant Solution\n\nclass MyClass\n{\n  public static int Y = 42;\n  public static int X = Y;\n}\n\nor\n\nclass MyClass\n{\n  public static int X;\n  public static int Y = 42;\n\n  static MyClass()\n  {\n    X = Y;\n  }\n}\n\n\n"
    },
    {
      "Code": "3249",
      "Title": "Classes directly extending \"object\" should not call \"base\" in \"GetHashCode\" or \"Equals\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3249",
      "Description": "Making a base call in an overriding method is generally a good idea, but not in GetHashCode and Equals for\nclasses that directly extend object because those methods are based on the object reference. Meaning that no two objects\nthat use those base methods will ever be equal or have the same hash.\nNoncompliant Code Example\n\npublic class Point\n{\n  private readonly int x;\n  public MyClass(int x)\n  {\n    this.x = x;\n  }\n  public override int GetHashCode()\n  {\n    return x.GetHashCode() ^ base.GetHashCode(); //Noncompliant\n  }\n}\n\nCompliant Solution\n\npublic class Point\n{\n  private readonly int x;\n  public MyClass(int x)\n  {\n    this.x = x;\n  }\n  public override int GetHashCode()\n  {\n    return x.GetHashCode();\n  }\n}\n\nExceptions\nThis rule doesn’t report on guard conditions checking for reference equality.\n\npublic class Point\n{\n  public override bool Equals(object obj)\n  {\n    if (base.Equals(obj)) // Compliant, although it could be replaced with object.ReferenceEquals(obj, this), which is clearer\n    {\n      return true;\n    }\n    ...\n  }\n}\n\n\n"
    },
    {
      "Code": "3244",
      "Title": "Anonymous delegates should not be used to unsubscribe from Events",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3244",
      "Description": "It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them. That’s because the\nprocess of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove this item from the subscription\nlist. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries to remove a different item from the list than was added.\nThe result: NOOP.\nInstead, save the delegate to a variable and use the variable to subscribe and unsubscribe.\nNoncompliant Code Example\n\nlistView.PreviewTextInput += (obj,args) =&gt;\n        listView_PreviewTextInput(obj,args,listView);\n\n// ...\n\nlistView.PreviewTextInput -= (obj, args) =&gt;\n        listView_PreviewTextInput(obj, args, listView); // Noncompliant; this delegate was never subscribed\n\nCompliant Solution\n\nEventHandler func = (obj,args) =&gt; listView_PreviewTextInput(obj,args,listView);\n\nlistView.PreviewTextInput += func;\n\n// ...\n\nlistView.PreviewTextInput -= func;\n\n\n"
    },
    {
      "Code": "3172",
      "Title": "Delegates should not be subtracted",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3172",
      "Description": "In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.\nSubtracting a chain of delegates from another one might yield unexpected results as shown hereunder - and is likely to be a bug.\nNoncompliant Code Example\n\nMyDelegate first, second, third, fourth;\nfirst = () =&gt; Console.Write(\"1\");\nsecond = () =&gt; Console.Write(\"2\");\nthird = () =&gt; Console.Write(\"3\");\nfourth = () =&gt; Console.Write(\"4\");\n\nMyDelegate chain1234 = first + second + third + fourth; // Compliant - chain sequence = \"1234\"\nMyDelegate chain12 = chain1234 - third - fourth; // Compliant - chain sequence = \"12\"\n\n\nMyDelegate chain14 = first + fourth; // creates a new MyDelegate instance which is a list under the covers\nMyDelegate chain23 = chain1234 - chain14; // Noncompliant; (first + fourth) doesn't exist in chain1234\n\n\n// The chain sequence of \"chain23\" will be \"1234\" instead of \"23\"!\n// Indeed, the sequence \"1234\" does not contain the subsequence \"14\", so nothing is subtracted\n// (but note that \"1234\" contains both the \"1\" and \"4\" subsequences)\nchain23 = chain1234 - (first + fourth); // Noncompliant\n\nchain23(); // will print \"1234\"!\n\nCompliant Solution\n\nMyDelegate chain23 = chain1234 - first - fourth; // Compliant - \"1\" is first removed, followed by \"4\"\n\nchain23(); // will print \"23\"\n\n\n"
    },
    {
      "Code": "3168",
      "Title": "\"async\" methods should not return \"void\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3168",
      "Description": "An async method with a void return type is a \"fire and forget\" method best reserved for event handlers because there’s no\nway to wait for the method’s execution to complete and respond accordingly. There’s also no way to catch exceptions thrown from the\nmethod.\nHaving an async void method that is not an event handler could mean your program works some times and not others because of timing\nissues. Instead, async methods should return Task.\nThis rule raises an issue when non-event handler methods are both async and void.\nNoncompliant Code Example\n\nclass HttpPrinter\n{\n  private string content;\n\n  public async void CallNetwork(string url) //Noncompliant\n  {\n    var client = new HttpClient();\n    var response = await client.GetAsync(url);\n    content = await response.Content.ReadAsStringAsync();\n  }\n\n  public async Task PrintContent(string url)  // works correctly if web request finishes in under 1 second, otherwise content will be null\n  {\n    CallNetwork(url);\n    await Task.Delay(1000);\n    Console.Write(content);\n  }\n}\n\nCompliant Solution\n\nclass HttpPrinter\n{\n  private string content;\n\n  public async Task CallNetwork(string url)\n  {\n    var client = new HttpClient();\n    var response = await client.GetAsync(url);\n    content = await response.Content.ReadAsStringAsync();\n  }\n\n  public async Task PrintContent(string url)\n  {\n    await CallNetwork(url); // &lt;----- call changed here. If await is not added warning CS4014 will be triggered\n    await Task.Delay(1000);\n    Console.Write(content);\n  }\n}\n\nExceptions\nEvent handlers, i.e. methods with two arguments, first one matching type object or name sender and the second being or\ninheriting from EventArgs, are ignored.\nMethods named as OnSomething are also ignored.\n\n"
    },
    {
      "Code": "3005",
      "Title": "\"ThreadStatic\" should not be used on non-static fields",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3005",
      "Description": "When a non-static class field is annotated with ThreadStatic, the code seems to show that the field can have different\nvalues for different calling threads, but that’s not the case, since the ThreadStatic attribute is simply ignored on\nnon-static fields.\nSo ThreadStatic should either be removed or replaced with a use of the ThreadLocal&lt;T&gt; class, which gives a similar\nbehavior for non-static fields.\nNoncompliant Code Example\n\npublic class MyClass\n{\n  [ThreadStatic]  // Noncompliant\n  private int count = 0;\n\n  // ...\n}\n\nCompliant Solution\n\npublic class MyClass\n{\n  private int count = 0;\n\n  // ...\n}\n\nor\n\npublic class MyClass\n{\n  private readonly ThreadLocal&lt;int&gt; count = new ThreadLocal&lt;int&gt;();\n  public int Count\n  {\n    get { return count.Value; }\n    set { count.Value = value; }\n  }\n  // ...\n}\n\n\n"
    },
    {
      "Code": "2997",
      "Title": "\"IDisposables\" created in a \"using\" statement should not be returned",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2997",
      "Description": "Typically you want to use using to create a local IDisposable variable; it will trigger disposal of the object when\ncontrol passes out of the block’s scope. The exception to this rule is when your method returns that IDisposable. In that case\nusing disposes of the object before the caller can make use of it, likely causing exceptions at runtime. So you should either remove\nusing or avoid returning the IDisposable.\nNoncompliant Code Example\n\npublic FileStream WriteToFile(string path, string text)\n{\n  using (var fs = File.Create(path)) // Noncompliant\n  {\n    var bytes = Encoding.UTF8.GetBytes(text);\n    fs.Write(bytes, 0, bytes.Length);\n    return fs;\n  }\n}\n\nCompliant Solution\n\npublic FileStream WriteToFile(string path, string text)\n{\n  var fs = File.Create(path);\n  var bytes = Encoding.UTF8.GetBytes(text);\n  fs.Write(bytes, 0, bytes.Length);\n  return fs;\n}\n\n\n"
    },
    {
      "Code": "2996",
      "Title": "\"ThreadStatic\" fields should not be initialized",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2996",
      "Description": "When an object has a field annotated with ThreadStatic, that field is shared within a given thread, but unique across threads. Since a\nclass' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial\nvalues.\nInstead, allow such fields to be initialized to their default values or make the initialization lazy.\nNoncompliant Code Example\n\npublic class Foo\n{\n  [ThreadStatic]\n  public static object PerThreadObject = new object(); // Noncompliant. Will be null in all the threads except the first one.\n}\n\nCompliant Solution\n\npublic class Foo\n{\n  [ThreadStatic]\n  public static object _perThreadObject;\n  public static object PerThreadObject\n  {\n    get\n    {\n      if (_perThreadObject == null)\n      {\n        _perThreadObject = new object();\n      }\n      return _perThreadObject;\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "2995",
      "Title": "\"Object.ReferenceEquals\" should not be used for value types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2995",
      "Description": "Using Object.ReferenceEquals to compare the references of two value types simply won’t return the expected results most of the time\nbecause such types are passed by value, not by reference.\nNoncompliant Code Example\n\npublic class MyClass\n{\n  private MyStruct myStruct;\n\n  public void DoSomething(MyStruct s1) {\n    int a = 1;\n    int b = 1;\n\n    if (Object.ReferenceEquals(myStruct, s1))  // Noncompliant; this can never be true\n    {\n      // ...\n    }\n    else if (Object.ReferenceEquals(a,b)) // Noncompliant\n    {\n      // ...\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "2761",
      "Title": "Doubled prefix operators \"!!\" and \"~~\" should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2761",
      "Description": "Calling the ! or ~ prefix operator twice does nothing: the second invocation undoes the first. Such mistakes are\ntypically caused by accidentally double-tapping the key in question without noticing.\nEither this is a bug, if the operator was actually meant to be called once, or misleading if done on purpose.\nNoncompliant Code Example\n\nint v1 = 0;\nbool v2 = false;\n\nvar v3 = !!v1; // Noncompliant\nvar v4 = ~~v2; // Noncompliant\n\nCompliant Solution\n\nint v1 = 0;\nbool v2 = false;\n\nvar v3 = !v1;\nvar v4 = ~v2;\n\n\n"
    },
    {
      "Code": "2757",
      "Title": "\"=+\" should not be used instead of \"+=\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2757",
      "Description": "The use of operators pairs ( =+, =- or =! ) where the reversed, single operator was meant (+=,\n-= or !=) will compile and run, but not produce the expected results.\nThis rule raises an issue when =+, =-, or =! is used without any spacing between the two operators and when\nthere is at least one whitespace character after.\nNoncompliant Code Example\n\nint target = -5;\nint num = 3;\n\ntarget =- num;  // Noncompliant; target = -3. Is that really what's meant?\ntarget =+ num; // Noncompliant; target = 3\n\nCompliant Solution\n\nint target = -5;\nint num = 3;\n\ntarget = -num;  // Compliant; intent to assign inverse value of num is clear\ntarget += num;\n\n\n"
    },
    {
      "Code": "2688",
      "Title": "\"NaN\" should not be used in comparisons",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2688",
      "Description": "NaN is not equal to anything, even itself. Testing for equality or inequality against NaN will yield predictable results,\nbut probably not the ones you want.\nInstead, the best way to see whether a variable is equal to NaN is to use Number.isNaN(), since ES2015, or (perhaps\ncounter-intuitively) to compare it to itself. Since NaN !== NaN, when a !== a, you know it must equal NaN.\nNoncompliant Code Example\n\nvar a = double.NaN;\n\nif (a == double.NaN) // Noncompliant; always false\n{\n  Console.WriteLine(\"a is not a number\");  // this is dead code\n}\nif (a != double.NaN)  // Noncompliant; always true\n{\n  Console.WriteLine(\"a is not NaN\"); // this statement is not necessarily true\n}\n\nCompliant Solution\n\nif (double.IsNaN(a))\n{\n  console.log(\"a is not a number\");\n}\n\n\n"
    },
    {
      "Code": "2583",
      "Title": "Conditionally executed code should be reachable",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2583",
      "Description": "Conditional expressions which are always true or false can lead to dead code. Such code is always buggy and should never\nbe used in production.\nNoncompliant Code Example\n\npublic void Sample(bool b)\n{\n    bool a = false;\n    if (a) // Noncompliant\n    {\n        DoSomething(); // never executed\n    }\n\n    if (!a || b) // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n    {\n        DoSomething();\n    }\n    else\n    {\n        DoSomethingElse(); // never executed\n    }\n\n    var d = \"xxx\";\n    var res = d ?? \"value\"; // Noncompliant, d is always not null, \"value\" is never used\n}\n\nCompliant Solution\n\npublic void Sample(bool b)\n{\n    bool a = false;\n    if (Foo(a))\n    {\n        DoSomething();\n    }\n\n    if (b)\n    {\n        DoSomething();\n    }\n    else\n    {\n        DoSomethingElse();\n    }\n\n    var d = \"xxx\";\n    var res = d;\n}\n\nExceptions\nThis rule will not raise an issue in either of these cases:\n\n   When the condition is a single const bool \n\n\nconst bool debug = false;\n//...\nif (debug)\n{\n  // Print something\n}\n\n\n   When the condition is the literal true or false. \n\nIn these cases it is obvious the code is as intended.\nSee\n\n   MITRE, CWE-570 - Expression is Always False \n   MITRE, CWE-571 - Expression is Always True \n\n\n"
    },
    {
      "Code": "2259",
      "Title": "Null pointers should not be dereferenced",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2259",
      "Description": "A reference to null should never be dereferenced/accessed. Doing so will cause a NullReferenceException to be thrown. At\nbest, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or\nit could allow an attacker to bypass security measures.\nNoncompliant Code Example\n\nobject o = null;\nif (condition)\n{\n  M1(o.ToString()); // Noncompliant, always null\n}\nelse\n{\n  o = new object();\n}\nM2(o.ToString());\n\nExceptions\nCalls to extension methods are not reported because they can still operate on null values.\nTo create a custom null validation method declare an attribute with name ValidatedNotNullAttribute and mark the parameter that is\nvalidated for null in your method declaration with it:\n\nusing System;\n\npublic sealed class ValidatedNotNullAttribute : Attribute { }\n\npublic static class Guard\n{\n    public static void NotNull&lt;T&gt;([ValidatedNotNull] this T value, string name) where T : class\n    {\n        if (value == null)\n            throw new ArgumentNullException(name);\n    }\n}\n\npublic static class Utils\n{\n    public static string ToUpper(string value)\n    {\n        Guard.NotNull(value, nameof(value));\n        if (value == null)\n        {\n            return value.ToString(); // Compliant, this code is not reachable\n        }\n        return value.ToUpper();\n    }\n}\n\nSee\n\n   MITRE, CWE-476 - NULL Pointer Dereference \n\n\n"
    },
    {
      "Code": "2252",
      "Title": "For-loop conditions should be true at least once",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2252",
      "Description": "If a for loop’s condition is false before the first loop iteration, the loop will never be executed. Such loops are almost always\nbugs, particularly when the initial value and stop conditions are hard-coded.\nNoncompliant Code Example\n\nfor (int i = 10; i &lt; 10; i++)  // Noncompliant\n{\n    // ...\n}\n\nCompliant Solution\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    // ...\n}\n\n\n"
    },
    {
      "Code": "2251",
      "Title": "A \"for\" loop update clause should move the counter in the right direction",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2251",
      "Description": "A for loop with a counter that moves in the wrong direction is not an infinite loop. Because of wraparound, the loop will eventually\nreach its stop condition, but in doing so, it will run many, many more times than anticipated, potentially causing unexpected behavior.\nNoncompliant Code Example\n\npublic void DoSomething(string[] strings)\n{\n  for (int i = 0; i &lt; strings.Length; i--)  // Noncompliant\n  {\n    string s = strings[i];  // IndexOutOfRangeException  when i reaches -1\n    // do stuff\n  }\n}\n\nCompliant Solution\n\npublic void DoSomething(string[] strings)\n{\n  for (int i = 0; i &lt; strings.Length; i++)\n  {\n    string s = strings[i];\n    // do stuff\n  }\n}\n\n\n"
    },
    {
      "Code": "2225",
      "Title": "\"ToString()\" method should not return null",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2225",
      "Description": "Calling ToString() on an object should always return a string. Returning null instead contravenes the method’s implicit\ncontract.\nNoncompliant Code Example\n\npublic override string ToString ()\n{\n  if (this.collection.Count == 0)\n  {\n    return null; // Noncompliant\n  }\n  else\n  {\n    // ...\n  }\n}\n\nCompliant Solution\n\npublic override string ToString ()\n{\n  if (this.collection.Count == 0)\n  {\n    return string.Empty;\n  }\n  else\n  {\n    // ...\n  }\n}\n\nSee\n\n   MITRE CWE-476 - NULL Pointer Dereference \n\n\n"
    },
    {
      "Code": "2201",
      "Title": "Return values from functions without side effects should not be ignored",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2201",
      "Description": "When the call to a function doesn’t have any side effects, what is the point of making the call if the results are ignored? In such case, either\nthe function call is useless and should be dropped or the source code doesn’t behave as expected.\nThis rule raises an issue when the results of the following methods are ignored:\n\n   LINQ method, \n   [Pure] method, \n   any method on string, int, …​, System.Collections.Immutable.ImmutableArray&lt;T&gt;,\n  ImmutableHashSet&lt;T&gt;, …​ \n\nNotes:\n\n   although string.Intern has a side effect, ignoring its return value is still suspicious as it is the only reference ensured to\n  point to the intern pool. \n   Link methods can have side effects if they are misused. Example: \n\n\ntests.All(c =&gt; { c.myfield = \"foo\"; return true; });\n\nSuch code should be rewritten as a normal loop.\nNoncompliant Code Example\n\ncoll.Where(i =&gt; i &gt; 5).Select(i =&gt; i*i); // Noncompliant\n\"this string\".Equals(\"other string\"); // Noncompliant\n\nCompliant Solution\n\nvar res = coll.Where(i =&gt; i &gt; 5).Select(i =&gt; i*i);\nvar isEqual = \"this string\".Equals(\"other string\");\n\nExceptions\nThis rule doesn’t report issues on method calls with out or ref arguments.\n\n"
    },
    {
      "Code": "2123",
      "Title": "Values should not be uselessly incremented",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2123",
      "Description": "A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.\nNoncompliant Code Example\n\npublic int PickNumber()\n{\n  int i = 0;\n  int j = 0;\n\n  i = i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n\nCompliant Solution\n\npublic int PickNumber()\n{\n  int i = 0;\n  int j = 0;\n\n  i++;\n  return ++j;\n}\n\n\n"
    },
    {
      "Code": "2114",
      "Title": "Collections should not be passed as arguments to their own methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2114",
      "Description": "Passing a collection as an argument to the collection’s own method is either an error - some other argument was intended - or simply nonsensical\ncode.\nFurther, because some methods require that the argument remain unmodified during the execution, passing a collection to itself can result in an\nunexpected behavior.\nNoncompliant Code Example\n\nvar list = new List&lt;int&gt;();\n\nlist.AddRange(list); // Noncompliant\nlist.Concat(list); // Noncompliant\n\nlist.Union(list); // Noncompliant; always returns list\nlist.Except(list); // Noncompliant; always empty\nlist.Intersect(list); // Noncompliant; always list\nlist.SequenceEqual(list); // Noncompliant; always true\n\nvar set = new HashSet&lt;int&gt;();\nset.UnionWith(set); // Noncompliant; no changes\nset.ExceptWith(set); // Noncompliant; always empty\nset.IntersectWith(set); // Noncompliant; no changes\nset.IsProperSubsetOf(set); // Noncompliant; always false\nset.IsProperSupersetOf(set); // Noncompliant; always false\nset.IsSubsetOf(set); // Noncompliant; always true\nset.IsSupersetOf(set); // Noncompliant; always true\nset.Overlaps(set); // Noncompliant; always true\nset.SetEquals(set); // Noncompliant; always true\nset.SymmetricExceptWith(set); // Noncompliant; always empty\n\n\n"
    },
    {
      "Code": "1862",
      "Title": "Related \"if/else if\" statements should not have the same condition",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1862",
      "Description": "A chain of if/else if statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to true.\nTherefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it’s simply dead code and\nat worst, it’s a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.\nNoncompliant Code Example\n\nif (param == 1)\n{\n  OpenWindow();\n}\nelse if (param == 2)\n{\n  CloseWindow();\n}\nelse if (param == 1) // Noncompliant\n{\n  MoveWindowToTheBackground();\n}\n\nCompliant Solution\n\nif (param == 1)\n{\n  OpenWindow();\n}\nelse if (param == 2)\n{\n  CloseWindow();\n}\nelse if (param == 3)\n{\n  MoveWindowToTheBackground();\n}\n\n\n"
    },
    {
      "Code": "1848",
      "Title": "Objects should not be created to be dropped immediately without being used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1848",
      "Description": "There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.\nIf it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate, static method and\ncalled directly.\nNoncompliant Code Example\n\nif (x &lt; 0)\n  new ArgumentException(\"x must be nonnegative\");\n\nCompliant Solution\n\nif (x &lt; 0)\n  throw new ArgumentException(\"x must be nonnegative\");\n\n\n"
    },
    {
      "Code": "1764",
      "Title": "Identical expressions should not be used on both sides of a binary operator",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1764",
      "Description": "Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.\nNoncompliant Code Example\n\nif ( a == a ) // always true\n{\n  doZ();\n}\nif ( a != a ) // always false\n{\n  doY();\n}\nif ( a == b &amp;&amp; a == b ) // if the first one is true, the second one is too\n{\n  doX();\n}\nif ( a == b || a == b ) // if the first one is true, the second one is too\n{\n  doW();\n}\n\nint j = 5 / 5; //always 1\nint k = 5 - 5; // always 0\n\nc.Equals(c);    //always true\nObject.Equals(c, c); //always true\n\nExceptions\nThis rule ignores *, +, =, &lt;&lt;, and &gt;&gt;.\nSee\n\n   {rule:csharpsquid:S1656} - Implements a check on =. \n\n\n"
    },
    {
      "Code": "1751",
      "Title": "Loops with at most one iteration should be refactored",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1751",
      "Description": "A loop with at most one iteration is equivalent to the use of an if statement to conditionally execute one piece of code. If the\ninitial intention of the author was really to conditionally execute one piece of code, an if statement should be used instead. If that\nwas not the initial intention of the author, the body of the loop should be fixed to use the nested return, break or\nthrow statements in a more appropriate way.\nNoncompliant Code Example\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(i);\n    break;  // Noncompliant, loop only executes once\n}\n...\nforeach (var item in items)\n{\n    return item;  // Noncompliant, loop only executes once\n}\n...\n\nCompliant Solution\n\nfor (int i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(i);\n}\n...\nvar item = items.FirstOrDefault();\nif (item != null)\n{\n    return item;\n}\n...\n\n\n"
    },
    {
      "Code": "1656",
      "Title": "Variables should not be self-assigned",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1656",
      "Description": "There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.\nNoncompliant Code Example\n\npublic void SetName(string name)\n{\n  name = name;\n}\n\nCompliant Solution\n\npublic void SetName(string name)\n{\n  this.name = name;\n}\n\n\n"
    },
    {
      "Code": "6350",
      "Title": "Constructing arguments of system commands from user input is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-6350",
      "Description": "Constructing arguments of system commands from user input is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2016-9920 \n   CVE-2021-29472 \n\nArguments of system commands are processed by the executed program. The arguments are usually used to configure and influence the behavior of the\nprograms. Control over a single argument might be enough for an attacker to trigger dangerous features like executing arbitrary commands or writing\nfiles into specific directories.\nAsk Yourself Whether\n\n   Malicious arguments can result in undesired behavior in the executed command. \n   Passing user input to a system command is not necessary. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Avoid constructing system commands from user input when possible. \n   Ensure that no risky arguments can be injected for the given program, e.g., type-cast the argument to an integer. \n   Use a more secure interface to communicate with other programs, e.g., the standard input stream (stdin). \n\nSensitive Code Example\nArguments like -delete or -exec for the find command can alter the expected behavior and result in\nvulnerabilities:\n\nusing System.Diagnostics;\nProcess p = new Process();\np.StartInfo.FileName = \"/usr/bin/find\";\np.StartInfo.ArgumentList.Add(input); // Sensitive\n\nCompliant Solution\nUse an allow-list to restrict the arguments to trusted values:\n\nusing System.Diagnostics;\nProcess p = new Process();\np.StartInfo.FileName = \"/usr/bin/find\";\nif (allowed.Contains(input)) {\n  p.StartInfo.ArgumentList.Add(input);\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-88 - Argument Injection or Modification \n   SANS Top 25 - Insecure Interaction Between Components \n   CVE-2021-29472 - PHP Supply Chain Attack on Composer \n\n\n"
    },
    {
      "Code": "5766",
      "Title": "Deserializing objects without performing data validation is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5766",
      "Description": "Deserialization process extracts data from the serialized representation of an object and reconstruct it directly, without calling constructors.\nThus, data validation implemented in constructors can be bypassed if serialized objects are controlled by an attacker.\nAsk Yourself Whether\n\n   The data validation implemented in constructors enforces a relevant security check. \n   Objects instantiated via deserialization don’t run the same security checks as the ones executed when objects are created through constructors.\n  \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   At the end of the deserialization process it is recommended to perform the same validation checks as the ones performed in constructors,\n  especially when the serialized object can be controlled by an attacker. \n\nSensitive Code Example\nWhen a serializable class doesn’t inherit from ISerializable or IDeserializationCallback\ntypes and has a constructor using its parameters in conditions:\n\n[Serializable]\npublic class InternalUrl\n{\n    private string url;\n\n    public InternalUrl(string tmpUrl) // Sensitive\n    {\n       if(!tmpUrl.StartsWith(\"http://localhost/\")) // there is some input validation\n       {\n          url= \"http://localhost/default\";\n       }\n       else\n       {\n          url= tmpUrl;\n       }\n    }\n}\n\nWhen a class inherit from ISerializable type, has a\nregular constructor using its parameters in conditions, but doesn’t perform the same validation after deserialization:\n\n[Serializable]\npublic class InternalUrl : ISerializable\n{\n    private string url;\n\n    public InternalUrl(string tmpUrl) // Sensitive\n    {\n        if(!tmpUrl.StartsWith(\"http://localhost/\")) // there is some input validation\n        {\n            url= \"http://localhost/default\";\n        }\n        else\n        {\n            url= tmpUrl;\n        }\n    }\n\n    // special constructor used during deserialization\n    protected InternalUrl(SerializationInfo info, StreamingContext context) // Sensitive\n    {\n       url= (string) info.GetValue(\"url\", typeof(string));\n       // the same validation as seen in the regular constructor is not performed\n     }\n\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        info.AddValue(\"url\", url);\n    }\n}\n\nWhen a class inherit from IDeserializationCallback\ntype, has a constructor using its parameters in conditions but the IDeserializationCallback.OnDeserialization method doesn’t perform any\nconditional checks:\n\n[Serializable]\npublic class InternalUrl : IDeserializationCallback\n{\n    private string url;\n\n    public InternalUrl(string tmpUrl) // Sensitive\n    {\n        if(!tmpUrl.StartsWith(\"http://localhost/\")) // there is some input validation\n        {\n            url= \"http://localhost/default\";\n        }\n        else\n        {\n            url= tmpUrl;\n        }\n    }\n\n    void IDeserializationCallback.OnDeserialization(object sender) // Sensitive\n    {\n       // the same validation as seen in the constructor is not performed\n    }\n}\n\nCompliant Solution\nWhen using ISerializable\ntype to control deserialization, perform the same checks inside regular constructors than in the special constructor SerializationInfo info,\nStreamingContext context used during deserialization:\n\n[Serializable]\npublic class InternalUrl : ISerializable\n{\n    private string url;\n\n    public InternalUrl(string tmpUrl)\n    {\n        if(!tmpUrl.StartsWith(\"http://localhost/\")) // there is some input validation\n        {\n            url= \"http://localhost/default\";\n        }\n        else\n        {\n            url= tmpUrl;\n        }\n    }\n\n    // special constructor used during deserialization\n    protected InternalUrl(SerializationInfo info, StreamingContext context)\n    {\n       string tmpUrl= (string) info.GetValue(\"url\", typeof(string));\n\n       if(!tmpUrl.StartsWith(\"http://localhost/\") { // Compliant\n          url= \"http://localhost/default\";\n       }\n       else {\n          url= tmpUrl;\n       }\n     }\n\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        info.AddValue(\"url\", url);\n    }\n}\n\nWhen using IDeserializationCallback\ntype to control deserialization, perform the same checks inside regular constructors than after deserialization with\nIDeserializationCallback.OnDeserialization method:\n\n[Serializable]\npublic class InternalUrl : IDeserializationCallback\n{\n    private string url;\n\n    public InternalUrl(string tmpUrl)\n    {\n       if(!tmpUrl.StartsWith(\"http://localhost/\")) // there is some input validation\n       {\n          url= \"http://localhost/default\";\n       }\n       else\n       {\n          url= tmpUrl;\n       }\n    }\n\n    void IDeserializationCallback.OnDeserialization(object sender) // Compliant\n    {\n        if(!url.StartsWith(\"http://localhost/\"))\n        {\n            url= \"http://localhost/default\";\n        }\n        else\n        {\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A8 - Insecure Deserialization\n  \n   docs.microsoft.com - security-and-serialization\n  \n   MITRE, CWE-502 - Deserialization of Untrusted Data \n\n\n"
    },
    {
      "Code": "5753",
      "Title": "Disabling ASP.NET \"Request Validation\" feature is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5753",
      "Description": "ASP.NET 1.1+ comes with a feature called Request Validation, preventing the server to accept content containing un-encoded HTML. This\nfeature comes as a first protection layer against Cross-Site Scripting (XSS) attacks and act as a simple Web Application Firewall (WAF) rejecting\nrequests potentially containing malicious content.\nWhile this feature is not a silver bullet to prevent all XSS attacks, it helps to catch basic ones. It will for example prevent &lt;script\ntype=\"text/javascript\" src=\"https://malicious.domain/payload.js\"&gt; to reach your Controller.\nNote: Request Validation feature being only available for ASP.NET, no Security Hotspot is raised on ASP.NET Core applications.\nAsk Yourself Whether\n\n   the developer doesn’t know the impact to deactivate the Request Validation feature \n   the web application accepts user supplied data \n   all user supplied data are not validated \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Activate the Request Validation feature for all HTTP requests \n\nSensitive Code Example\nAt Controller level:\n\n[ValidateInput(false)]\npublic ActionResult Welcome(string name)\n{\n  ...\n}\n\nAt application level, configured in the Web.config file:\n\n&lt;configuration&gt;\n   &lt;system.web&gt;\n      &lt;pages validateRequest=\"false\" /&gt;\n      ...\n      &lt;httpRuntime requestValidationMode=\"0.0\" /&gt;\n   &lt;/system.web&gt;\n&lt;/configuration&gt;\n\nCompliant Solution\nAt Controller level:\n\n[ValidateInput(true)]\npublic ActionResult Welcome(string name)\n{\n  ...\n}\n\nor\n\npublic ActionResult Welcome(string name)\n{\n  ...\n}\n\nAt application level, configured in the Web.config file:\n\n&lt;configuration&gt;\n   &lt;system.web&gt;\n      &lt;pages validateRequest=\"true\" /&gt;\n      ...\n      &lt;httpRuntime requestValidationMode=\"4.5\" /&gt;\n   &lt;/system.web&gt;\n&lt;/configuration&gt;\n\nSee\n\n   HttpRuntimeSection.RequestValidationMode Property \n   OWASP ASP.NET Request Validation \n   OWASP Cheat Sheet - XSS\n  Prevention Cheat Sheet \n   OWASP Top 10 2017 Category A7 - Cross-Site Scripting\n  (XSS) \n   MITRE, CWE-79 - Improper Neutralization of Input During Web Page Generation\n  ('Cross-site Scripting') \n   MITRE, CWE-80 - Improper Neutralization of Script-Related HTML Tags in a Web Page\n  (Basic XSS) \n\n\n"
    },
    {
      "Code": "5693",
      "Title": "Allowing requests with excessive content length is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5693",
      "Description": "Rejecting requests with significant content length is a good practice to control the network traffic intensity and thus resource consumption in\norder to prevents DoS attacks.\nAsk Yourself Whether\n\n   size limits are not defined for the different resources of the web application. \n   the web application is not protected by rate limiting features. \n   the web application infrastructure has limited resources. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   For most of the features of an application, it is recommended to limit the size of requests to:\n    \n       lower or equal to 8mb for file uploads. \n       lower or equal to 2mb for other requests. \n      \n\nIt is recommended to customize the rule with the limit values that correspond to the web application.\nSensitive Code Example\n\nusing Microsoft.AspNetCore.Mvc;\n\npublic class MyController : Controller\n{\n    [HttpPost]\n    [DisableRequestSizeLimit] // Sensitive: No size  limit\n    [RequestSizeLimit(10000000)] // Sensitive: 10MB is more than the recommended limit of 8MB\n    public IActionResult PostRequest(Model model)\n    {\n    // ...\n    }\n\n    [HttpPost]\n    [RequestFormLimits(MultipartBodyLengthLimit = 8000000)] // Sensitive: 10MB is more than the recommended limit of 8MB\n    public IActionResult MultipartFormRequest(Model model)\n    {\n    // ...\n    }\n}\n\nIn Web.config:\n\n&lt;configuration&gt;\n    &lt;system.web&gt;\n        &lt;httpRuntime maxRequestLength=\"81920\" executionTimeout=\"3600\" /&gt;\n        &lt;!-- Sensitive: maxRequestLength is exprimed in KB, so 81920KB = 80MB  --&gt;\n    &lt;/system.web&gt;\n    &lt;system.webServer&gt;\n        &lt;security&gt;\n            &lt;requestFiltering&gt;\n                &lt;requestLimits maxAllowedContentLength=\"83886080\" /&gt;\n                &lt;!-- Sensitive: maxAllowedContentLength is exprimed in bytes, so 83886080B = 80MB  --&gt;\n            &lt;/requestFiltering&gt;\n        &lt;/security&gt;\n    &lt;/system.webServer&gt;\n&lt;/configuration&gt;\n\nCompliant Solution\n\nusing Microsoft.AspNetCore.Mvc;\n\npublic class MyController : Controller\n{\n    [HttpPost]\n    [RequestSizeLimit(8000000)] // Compliant: 8MB\n    public IActionResult PostRequest(Model model)\n    {\n    // ...\n    }\n\n    [HttpPost]\n    [RequestFormLimits(MultipartBodyLengthLimit = 8000000)] // Compliant: 8MB\n    public IActionResult MultipartFormRequest(Model model)\n    {\n    // ...\n    }\n}\n\nIn Web.config:\n\n&lt;configuration&gt;\n    &lt;system.web&gt;\n        &lt;httpRuntime maxRequestLength=\"8192\" executionTimeout=\"3600\" /&gt;\n        &lt;!-- Compliant: maxRequestLength is exprimed in KB, so 8192KB = 8MB  --&gt;\n    &lt;/system.web&gt;\n    &lt;system.webServer&gt;\n        &lt;security&gt;\n            &lt;requestFiltering&gt;\n                &lt;requestLimits maxAllowedContentLength=\"8388608\" /&gt;\n                &lt;!-- Comliant: maxAllowedContentLength is exprimed in bytes, so 8388608B = 8MB  --&gt;\n            &lt;/requestFiltering&gt;\n        &lt;/security&gt;\n    &lt;/system.webServer&gt;\n&lt;/configuration&gt;\n\nSee\n\n   Owasp Cheat Sheet - Owasp Denial of Service\n  Cheat Sheet \n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   CWE-770 - Allocation of Resources Without Limits or Throttling \n   CWE-400 - Uncontrolled Resource Consumption \n   Web.config - XML-formatted config file for IIS\n  applications \n\n\n"
    },
    {
      "Code": "2612",
      "Title": "Setting loose file permissions is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2612",
      "Description": "In Unix, \"others\" class refers to all users except the owner of the file and the members of the group assigned to this file.\nIn Windows, \"Everyone\" group is similar and includes all members of the Authenticated Users group as well as the built-in Guest account, and\nseveral other built-in security accounts.\nGranting permissions to these groups can lead to unintended access to files.\nAsk Yourself Whether\n\n   The application is designed to be run on a multi-user environment. \n   Corresponding files and directories may contain confidential information. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\nThe most restrictive possible permissions should be assigned to files and directories.\nSensitive Code Example\n.Net Framework:\n\nvar unsafeAccessRule = new FileSystemAccessRule(\"Everyone\", FileSystemRights.FullControl, AccessControlType.Allow);\n\nvar fileSecurity = File.GetAccessControl(\"path\");\nfileSecurity.AddAccessRule(unsafeAccessRule); // Sensitive\nfileSecurity.SetAccessRule(unsafeAccessRule); // Sensitive\nFile.SetAccessControl(\"fileName\", fileSecurity);\n\n.Net / .Net Core\n\nvar fileInfo = new FileInfo(\"path\");\nvar fileSecurity = fileInfo.GetAccessControl();\n\nfileSecurity.AddAccessRule(new FileSystemAccessRule(\"Everyone\", FileSystemRights.Write, AccessControlType.Allow)); // Sensitive\nfileInfo.SetAccessControl(fileSecurity);\n\n.Net / .Net Core using Mono.Posix.NETStandard\n\nvar fileSystemEntry = UnixFileSystemInfo.GetFileSystemEntry(\"path\");\nfileSystemEntry.FileAccessPermissions = FileAccessPermissions.OtherReadWriteExecute; // Sensitive\n\nCompliant Solution\n.Net Framework\n\nvar safeAccessRule = new FileSystemAccessRule(\"Everyone\", FileSystemRights.FullControl, AccessControlType.Deny);\n\nvar fileSecurity = File.GetAccessControl(\"path\");\nfileSecurity.AddAccessRule(safeAccessRule);\nFile.SetAccessControl(\"path\", fileSecurity);\n\n.Net / .Net Core\n\nvar safeAccessRule = new FileSystemAccessRule(\"Everyone\", FileSystemRights.FullControl, AccessControlType.Deny);\n\nvar fileInfo = new FileInfo(\"path\");\nvar fileSecurity = fileInfo.GetAccessControl();\nfileSecurity.SetAccessRule(safeAccessRule);\nfileInfo.SetAccessControl(fileSecurity);\n\n.Net / .Net Core using Mono.Posix.NETStandard\n\nvar fs = UnixFileSystemInfo.GetFileSystemEntry(\"path\");\nfs.FileAccessPermissions = FileAccessPermissions.UserExecute;\n\nSee\n\n   OWASP Top 10 2017 Category A5 - Broken Access Control \n   OWASP File Permission \n   MITRE, CWE-732 - Incorrect Permission Assignment for Critical Resource \n   MITRE, CWE-266 - Incorrect Privilege Assignment \n   SANS Top 25 - Porous Defenses \n\n\n"
    },
    {
      "Code": "2077",
      "Title": "Formatting SQL queries is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2077",
      "Description": "Formatted SQL queries can be difficult to maintain, debug and can increase the risk of SQL injection when concatenating untrusted values into the\nquery. However, this rule doesn’t detect SQL injections (unlike rule {rule:csharpsquid:S3649}), the goal is only to highlight complex/formatted\nqueries.\nAsk Yourself Whether\n\n   Some parts of the query come from untrusted values (like user inputs). \n   The query is repeated/duplicated in other parts of the code. \n   The application must support different types of relational databases. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Use parameterized queries, prepared statements, or stored\n  procedures and bind variables to SQL query parameters. \n   Consider using ORM frameworks if there is a need to have an abstract layer to access data. \n\nSensitive Code Example\n\npublic void Foo(DbContext context, string query, string param)\n{\n    string sensitiveQuery = string.Concat(query, param);\n    context.Database.ExecuteSqlCommand(sensitiveQuery); // Sensitive\n    context.Query&lt;User&gt;().FromSql(sensitiveQuery); // Sensitive\n\n    context.Database.ExecuteSqlCommand($\"SELECT * FROM mytable WHERE mycol={value}\", param); // Sensitive, the FormattableString is evaluated and converted to RawSqlString\n    string query = $\"SELECT * FROM mytable WHERE mycol={param}\";\n    context.Database.ExecuteSqlCommand(query); // Sensitive, the FormattableString has already been evaluated, it won't be converted to a parametrized query.\n}\n\npublic void Bar(SqlConnection connection, string param)\n{\n    SqlCommand command;\n    string sensitiveQuery = string.Format(\"INSERT INTO Users (name) VALUES (\\\"{0}\\\")\", param);\n    command = new SqlCommand(sensitiveQuery); // Sensitive\n\n    command.CommandText = sensitiveQuery; // Sensitive\n\n    SqlDataAdapter adapter;\n    adapter = new SqlDataAdapter(sensitiveQuery, connection); // Sensitive\n}\n\nCompliant Solution\n\npublic void Foo(DbContext context, string query, string param)\n{\n    context.Database.ExecuteSqlCommand(\"SELECT * FROM mytable WHERE mycol=@p0\", param); // Compliant, it's a parametrized safe query\n}\n\nSee\n\n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-89 - Improper Neutralization of Special Elements used in an SQL Command\n  \n   MITRE, CWE-564 - SQL Injection: Hibernate \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-943 - Improper Neutralization of Special Elements in Data Query Logic\n  \n   SANS Top 25 - Insecure Interaction Between Components \n   Derived from FindSecBugs rules Potential SQL/JPQL Injection\n  (JPA), Potential SQL/JDOQL Injection (JDO), Potential SQL/HQL Injection (Hibernate) \n\n\n"
    },
    {
      "Code": "1313",
      "Title": "Using hardcoded IP addresses is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1313",
      "Description": "Hardcoding IP addresses is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2006-5901 \n   CVE-2005-3725 \n\nToday’s services have an ever-changing architecture due to their scaling and redundancy needs. It is a mistake to think that a service will always\nhave the same IP address. When it does change, the hardcoded IP will have to be modified too. This will have an impact on the product development,\ndelivery, and deployment:\n\n   The developers will have to do a rapid fix every time this happens, instead of having an operation team change a configuration file. \n   It misleads to use the same address in every environment (dev, sys, qa, prod). \n\nLast but not least it has an effect on application security. Attackers might be able to decompile the code and thereby discover a potentially\nsensitive address. They can perform a Denial of Service attack on the service, try to get access to the system, or try to spoof the IP address to\nbypass security checks. Such attacks can always be possible, but in the case of a hardcoded IP address solving the issue will take more time, which\nwill increase an attack’s impact.\nAsk Yourself Whether\nThe disclosed IP address is sensitive, e.g.:\n\n   Can give information to an attacker about the network topology. \n   It’s a personal (assigned to an identifiable person) IP address. \n\nThere is a risk if you answered yes to any of these questions.\nRecommended Secure Coding Practices\nDon’t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\nSensitive Code Example\n\nvar ip = \"192.168.12.42\";\nvar address = IPAddress.Parse(ip);\n\nCompliant Solution\n\nvar ip = ConfigurationManager.AppSettings[\"myapplication.ip\"];\nvar address = IPAddress.Parse(ip);\n\nExceptions\nNo issue is reported for the following cases because they are not considered sensitive:\n\n   Loopback addresses 127.0.0.0/8 in CIDR notation (from 127.0.0.0 to 127.255.255.255) \n   Broadcast address 255.255.255.255 \n   Non routable address 0.0.0.0 \n   Strings of the form 2.5.&lt;number&gt;.&lt;number&gt; as they often match\n  Object Identifiers (OID). \n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n\n\n"
    },
    {
      "Code": "907",
      "Title": "\"goto\" statement should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-907",
      "Description": "goto is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such\nas if, for, while, continue or break should be used instead.\n\n"
    },
    {
      "Code": "4581",
      "Title": "\"new Guid()\" should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4581",
      "Description": "When the syntax new Guid() (i.e. parameterless instantiation) is used, it must be that one of three things is wanted:\n\n   An empty GUID, in which case Guid.Empty is clearer. \n   A randomly-generated GUID, in which case Guid.NewGuid() should be used. \n   A new GUID with a specific initialization, in which case the initialization parameter is missing. \n\nThis rule raises an issue when a parameterless instantiation of the Guid struct is found.\nNoncompliant Code Example\n\npublic void Foo()\n{\n    var g = new Guid(); // Noncompliant - what's the intent?\n}\n\nCompliant Solution\n\npublic void Foo(byte[] bytes)\n{\n    var g1 = Guid.Empty;\n    var g2 = Guid.NewGuid();\n    var g3 = new Guid(bytes);\n}\n\n\n"
    },
    {
      "Code": "4457",
      "Title": "Parameter validation in \"async\"/\"await\" methods should be wrapped",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4457",
      "Description": "Because of the way async/await methods are rewritten by the compiler, any exceptions thrown during the parameters check will happen\nonly when the task is observed. That could happen far away from the source of the buggy code or never happen for fire-and-forget tasks.\nTherefore it is recommended to split the method into two: an outer method handling the parameter checks (without being async/await)\nand an inner method to handle the iterator block with the async/await pattern.\nThis rule raises an issue when an async method throws any exception derived from ArgumentException and contains\nawait keyword.\nNoncompliant Code Example\n\npublic static async Task SkipLinesAsync(this TextReader reader, int linesToSkip) // Noncompliant\n{\n    if (reader == null) { throw new ArgumentNullException(nameof(reader)); }\n    if (linesToSkip &lt; 0) { throw new ArgumentOutOfRangeException(nameof(linesToSkip)); }\n\n    for (var i = 0; i &lt; linesToSkip; ++i)\n    {\n        var line = await reader.ReadLineAsync().ConfigureAwait(false);\n        if (line == null) { break; }\n    }\n}\n\nCompliant Solution\n\npublic static Task SkipLinesAsync(this TextReader reader, int linesToSkip)\n{\n    if (reader == null) { throw new ArgumentNullException(nameof(reader)); }\n    if (linesToSkip &lt; 0) { throw new ArgumentOutOfRangeException(nameof(linesToSkip)); }\n\n    return reader.SkipLinesInternalAsync(linesToSkip);\n}\n\nprivate static async Task SkipLinesInternalAsync(this TextReader reader, int linesToSkip)\n{\n    for (var i = 0; i &lt; linesToSkip; ++i)\n    {\n        var line = await reader.ReadLineAsync().ConfigureAwait(false);\n        if (line == null) { break; }\n    }\n}\n\n\n"
    },
    {
      "Code": "4456",
      "Title": "Parameter validation in yielding methods should be wrapped",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4456",
      "Description": "Because of the way yield methods are rewritten by the compiler (they become lazily evaluated state machines) any exceptions thrown\nduring the parameters check will happen only when the collection is iterated over. That could happen far away from the source of the buggy code.\nTherefore it is recommended to split the method into two: an outer method handling the validation (no longer lazy) and an inner (lazy) method to\nhandle the iteration.\nThis rule raises an issue when a method throws any exception derived from ArgumentException and contains the yield\nkeyword.\nNoncompliant Code Example\n\npublic static IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate) // Noncompliant\n{\n    if (source == null) { throw new ArgumentNullException(nameof(source)); }\n    if (predicate == null) { throw new ArgumentNullException(nameof(predicate)); }\n\n    foreach (var element in source)\n    {\n        if (!predicate(element)) { break; }\n        yield return element;\n    }\n}\n\nCompliant Solution\n\npublic static IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)\n{\n    if (source == null) { throw new ArgumentNullException(nameof(source)); }\n    if (predicate == null) { throw new ArgumentNullException(nameof(predicate)); }\n    return TakeWhileIterator&lt;TSource&gt;(source, predicate);\n}\n\nprivate static IEnumerable&lt;TSource&gt; TakeWhileIterator&lt;TSource&gt;(IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate)\n{\n    foreach (TSource element in source)\n    {\n        if (!predicate(element)) break;\n        yield return element;\n    }\n}\n\n\n"
    },
    {
      "Code": "4220",
      "Title": "Events should have proper arguments",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4220",
      "Description": "When raising an event, two arguments are expected by the EventHandler delegate: Sender and event-data. There are three guidelines\nregarding these parameters:\n\n   Do not pass null as the sender when raising a non-static event. \n   Do pass null as the sender when raising a static event. \n   Do not pass null as the event-data. If no data should be passed, then EventArgs.Empty should be used. \n\nThis rule raises an issue when any of these guidelines is not met.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  class Foo\n  {\n    public event EventHandler ThresholdReached;\n\n    protected virtual void OnThresholdReached(EventArgs e)\n    {\n        ThresholdReached?.Invoke(null, e); // Noncompliant\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  class Foo\n  {\n    public event EventHandler ThresholdReached;\n\n    protected virtual void OnThresholdReached(EventArgs e)\n    {\n        ThresholdReached?.Invoke(this, e);\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "4214",
      "Title": "\"P/Invoke\" methods should not be visible",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4214",
      "Description": "Methods marked with the System.Runtime.InteropServices.DllImportAttribute attribute use Platform Invocation Services to access\nunmanaged code and should not be exposed. Keeping them private or internal makes sure that their access is controlled and properly managed.\nThis rule raises an issue when a method declared with DllImport is public or protected.\nNoncompliant Code Example\n\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode)]\n        public static extern bool RemoveDirectory(string name);  // Noncompliant\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode)]\n        private static extern bool RemoveDirectory(string name);\n    }\n}\n\n\n"
    },
    {
      "Code": "4200",
      "Title": "Native methods should be wrapped",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4200",
      "Description": "Native methods are functions that reside in libraries outside the virtual machine. Being able to call them is useful for interoperability with\napplications and libraries written in other programming languages, in particular when performing platform-specific operations. However doing so comes\nwith extra risks since it means stepping out of the security model of the virtual machine. It is therefore highly recommended to take extra steps,\nlike input validation, when invoking native methods. This is best done by making the native method private and by providing a wrapper\nthat performs these extra steps and verifications.\nThis rule raises an issue when a native method is declared public or its wrapper is too trivial.\nNoncompliant Code Example\n\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace MyLibrary\n{\n  class Foo\n  {\n    [DllImport(\"mynativelib\")]\n    extern public static void Bar(string s, int x); // Noncompliant\n  }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace MyLibrary\n{\n  class Foo\n  {\n    [DllImport(\"mynativelib\")]\n    extern private static void Bar(string s, int x);\n\n    public void BarWrapper(string s, int x)\n    {\n      if (s != null &amp;&amp; x &gt;= 0  &amp;&amp; x &lt; s.Length)\n      {\n        bar(s, x);\n      }\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "4144",
      "Title": "Methods should not have identical implementations",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4144",
      "Description": "When two methods have the same implementation, either it was a mistake - something else was intended - or the duplication was intentional, but may\nbe confusing to maintainers. In the latter case, one implementation should invoke the other.\nNoncompliant Code Example\n\nprivate const string CODE = \"bounteous\";\nprivate int callCount = 0;\n\npublic string GetCode()\n{\n  callCount++;\n  return CODE;\n}\n\npublic string GetName()  // Noncompliant\n{\n  callCount++;\n  return CODE;\n}\n\nCompliant Solution\n\nprivate const string CODE = \"bounteous\";\nprivate int callCount = 0;\n\npublic string GetCode()\n{\n  callCount++;\n  return CODE;\n}\n\npublic string GetName()\n{\n  return GetCode();\n}\n\nExceptions\nEmpty methods, methods with only one line of code and methods with the same name (overload) are ignored.\n\n"
    },
    {
      "Code": "4070",
      "Title": "Non-flags enums should not be marked with \"FlagsAttribute\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4070",
      "Description": "This rule raises an issue when an externally visible enumeration is marked with FlagsAttribute and one, or more, of its values is not\na power of 2 or a combination of the other defined values.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n    [FlagsAttribute]\n    public enum Color // Noncompliant, Orange is neither a power of two, nor a combination of any of the defined values\n    {\n        None    = 0,\n        Red     = 1,\n        Orange  = 3,\n        Yellow  = 4\n    }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n    public enum Color // Compliant - no FlagsAttribute attribute\n    {\n        None = 0,\n        Red = 1,\n        Orange = 3,\n        Yellow = 4\n    }\n\n    [FlagsAttribute]\n    public enum Days\n    {\n        None = 0,\n        Monday = 1,\n        Tuesday = 2,\n        Wednesday = 4,\n        Thursday = 8,\n        Friday = 16,\n        All = Monday| Tuesday | Wednesday | Thursday | Friday    // Compliant - combination of other values\n    }\n}\n\n\n"
    },
    {
      "Code": "4035",
      "Title": "Classes implementing \"IEquatable\" should be sealed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4035",
      "Description": "When a class implements the IEquatable&lt;T&gt; interface, it enters a contract that, in effect, states \"I know how to compare two\ninstances of type T or any type derived from T for equality.\". However if that class is derived, it is very unlikely that the base class will know how\nto make a meaningful comparison. Therefore that implicit contract is now broken.\nAlternatively IEqualityComparer&lt;T&gt; provides a safer interface and is used by collections or Equals could be made\nvirtual.\nThis rule raises an issue when a unsealed, public or protected class implements IEquitable&lt;T&gt; and the\nEquals is neither virtual nor abstract.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  class Base : IEquatable&lt;Base&gt; // Noncompliant\n  {\n    bool Equals(Base other)\n    {\n      if (other == null) { return false };\n      // do comparison of base properties\n    }\n\n    override bool Equals(object other)  =&gt; Equals(other as Base);\n  }\n\n  class A : Base\n  {\n    bool Equals(A other)\n    {\n      if (other == null) { return false };\n      // do comparison of A properties\n      return base.Equals(other);\n    }\n\n    override bool Equals(object other)  =&gt; Equals(other as A);\n  }\n\n  class B : Base\n  {\n    bool Equals(B other)\n    {\n      if (other == null) { return false };\n      // do comparison of B properties\n     return base.Equals(other);\n    }\n\n    override bool Equals(object other)  =&gt; Equals(other as B);\n  }\n\n  static void Main() {\n    A a = new A();\n    B b = new B();\n\n    Console.WriteLine(a.Equals(b)); // This calls the WRONG equals. This causes Base::Equals(Base)\n    //  to be called which only compares the properties in Base and ignores the fact that\n    // a and b are different types. In the working example A::Equals(Object) would have been\n    // called and Equals would return false because it correctly recognizes that a and b are\n    // different types. If a and b have the same base properties they will  be returned as equal.\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n    public sealed class Foo : IEquatable&lt;Foo&gt;\n    {\n        public bool Equals(Foo other)\n        {\n            // Your code here\n        }\n    }\n}\n\nSee\nIEqualityComparer&lt;T&gt; Interface\n\n"
    },
    {
      "Code": "3971",
      "Title": "\"GC.SuppressFinalize\" should not be called",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3971",
      "Description": "GC.SuppressFinalize requests that the system not call the finalizer for the specified object. This should only be done when\nimplementing Dispose as part of the Dispose Pattern.\nThis rule raises an issue when GC.SuppressFinalize is called outside that pattern.\n\n"
    },
    {
      "Code": "3966",
      "Title": "Objects should not be disposed more than once",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3966",
      "Description": "Disposing an object twice, either with the using keyword or by calling Dispose directly, in the same method is at best\nconfusing and at worst error-prone. The next developer might see only one of the Dispose/using and try to use an\nalready-disposed object.\nIn addition, even if the documentation of\nDisposable explicitly states that calling the Dispose method multiple times should not throw an exception, some\nimplementation still do it. Thus it is safer to not dispose an object twice when possible.\nThis rule raises an issue when, in the same method, the Dispose method is explicitly called twice on the same object, or when\nusing is used with a direct call to Dispose().\nNoncompliant Code Example\n\nusing (var d = new Disposable()) // Noncompliant\n{\n    d.Dispose();\n}\n\n\nusing var d = new Disposable();\nd.Dispose(); // Noncompliant {{Refactor this code to make sure 'd' is disposed only once.}}\n\nCompliant Solution\n\nusing var d = new Disposable();\n\n\n"
    },
    {
      "Code": "3928",
      "Title": "Parameter names used into ArgumentException constructors should match an existing one ",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3928",
      "Description": "Some constructors of the ArgumentException, ArgumentNullException, ArgumentOutOfRangeException and\nDuplicateWaitObjectException classes must be fed with a valid parameter name. This rule raises an issue in two cases:\n\n   When this parameter name doesn’t match any existing ones. \n   When a call is made to the default (parameterless) constructor \n\nNoncompliant Code Example\n\npublic void Foo(Bar a, int[] b)\n{\n  throw new ArgumentException(); // Noncompliant\n  throw new ArgumentException(\"My error message\", \"c\"); // Noncompliant\n  throw new ArgumentException(\"My error message\", \"c\", innerException); // Noncompliant\n  throw new ArgumentNullException(\"c\"); // Noncompliant\n  throw new ArgumentNullException(\"My error message\",\u2002\"c\"); // Noncompliant\n  throw new ArgumentOutOfRangeException(\"c\");\n  throw new ArgumentOutOfRangeException(\"c\", \"My error message\"); // Noncompliant\n  throw new ArgumentOutOfRangeException(\"c\",\u2002b,\u2002\"My error message\"); // Noncompliant\n  throw new DuplicateWaitObjectException(\"c\", \"My error message\");  // Noncompliant\n}\n\nCompliant Solution\n\npublic void Foo(Bar a, Bar b)\n{\n  throw new ArgumentException(\"My error message\", \"a\");\n  throw new ArgumentException(\"My error message\", \"b\", innerException);\n  throw new ArgumentNullException(\"a\");\n  throw new ArgumentNullException(nameof(a));\n  throw new ArgumentNullException(\"a\", \"My error message\");\n  throw new ArgumentOutOfRangeException(\"b\");\n  throw new ArgumentOutOfRangeException(\"b\", \"My error message\");\n  throw new ArgumentOutOfRangeException(\"b\",\u2002b,\u2002\"My error message\");\n  throw new DuplicateWaitObjectException(\"b\", \"My error message\");\n}\n\nExceptions\nThe rule won’t raise an issue if the parameter name is not a constant value (inline declaration, nameof() or const variable).\n\n"
    },
    {
      "Code": "3925",
      "Title": "\"ISerializable\" should be implemented correctly",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3925",
      "Description": "The ISerializable interface is the mechanism to control the type serialization process. If not implemented correctly this could result\nin an invalid serialization and hard to detect bugs.\nThis rules raises an issue on types that implement ISerializable without following the serialization pattern recommended by\nMicrosoft.\nSpecifically this rule checks for these problems:\n\n   The System.SerializableAttribute attribute is missing. \n   Non-serializable fields are not marked with the System.NonSerializedAttribute attribute. \n   There is no serialization constructor. \n   An unsealed type has a serialization constructor that is not protected. \n   A sealed type has a serialization constructor that is not private. \n   An unsealed type has a ISerializable.GetObjectData that is not both public and virtual. \n   A derived type has a serialization constructor that does not call the base constructor. \n   A derived type has a ISerializable.GetObjectData method that does not call the base method. \n   A derived type has serializable fields but the ISerializable.GetObjectData method is not overridden. \n\nClasses which inherit from Exception are implementing ISerializable. Make sure [Serializable] attribute is\nused and that ISerializable&nbsp;is correctly implemented.&nbsp;Even it you don’t plan to explicitly serialize the object yourself, it\nmight still require serialization, for instance when crossing the boundary of an AppDomain.\nNoncompliant Code Example\n\npublic class Foo : ISerializable // Noncompliant the [Serializable] attribute is missing\n{\n}\n\nor\n\npublic class Bar\n{\n}\n\n[Serializable]\npublic class Foo : ISerializable // Noncompliant the serialization constructor is missing\n{\n    private readonly Bar bar; // Noncompliant the field is not marked with [NonSerialized]\n}\n\nCompliant Solution\n\npublic class Bar\n{\n}\n\n[Serializable]\npublic class Foo : ISerializable\n{\n    [NonSerialized]\n    private readonly Bar bar;\n\n    public Foo()\n    {\n        // ...\n    }\n\n    protected Foo(SerializationInfo info, StreamingContext context)\n    {\n        // ...\n    }\n\n    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        // ...\n    }\n}\n\n[Serializable]\npublic sealed class SubFoo : Foo\n{\n    private int val;\n\n    public SubFoo()\n    {\n        // ...\n    }\n\n    private SubFoo(SerializationInfo info, StreamingContext context)\n        : base(info, context)\n    {\n        // ...\n    }\n\n    public override void GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        base.GetObjectData(info, context);\n        // ...\n    }\n}\n\nExceptions\n\n   Classes in test projects are not checked. \n\n\n"
    },
    {
      "Code": "3885",
      "Title": "\"Assembly.Load\" should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3885",
      "Description": "The parameter to Assembly.Load includes the full specification of the dll to be loaded. Use another method, and you might end up with\na dll other than the one you expected.\nThis rule raises an issue when Assembly.LoadFrom, Assembly.LoadFile, or Assembly.LoadWithPartialName is\ncalled.\nNoncompliant Code Example\n\nstatic void Main(string[] args)\n{\n    Assembly.LoadFrom(...); // Noncompliant\n    Assembly.LoadFile(...); // Noncompliant\n    Assembly.LoadWithPartialName(...); // Noncompliant + deprecated\n}\n\n\n"
    },
    {
      "Code": "3881",
      "Title": "\"IDisposable\" should be implemented correctly",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3881",
      "Description": "The IDisposable interface is a mechanism to release unmanaged resources, if not implemented correctly this could result in resource\nleaks or more severe bugs.\nThis rule raises an issue when the recommended dispose pattern, as defined by Microsoft, is not adhered to. See the Compliant\nSolution section for examples.\nSatisfying the rule’s conditions will enable potential derived classes to correctly dispose the members of your class:\n\n   sealed classes are not checked. \n   If a base class implements IDisposable your class should not have IDisposable in the list of its interfaces. In such\n  cases it is recommended to override the base class’s protected virtual void Dispose(bool) method or its equivalent. \n   The class should not implement IDisposable explicitly, e.g. the Dispose() method should be public. \n   The class should contain protected virtual void Dispose(bool) method. This method allows the derived classes to correctly dispose\n  the resources of this class. \n   The content of the Dispose() method should be invocation of Dispose(true) followed by\n  GC.SuppressFinalize(this) \n   If the class has a finalizer, i.e. a destructor, the only code in its body should be a single invocation of Dispose(false). \n   If the class inherits from a class that implements IDisposable it must call the Dispose, or\n  Dispose(bool) method of the base class from within its own implementation of Dispose or Dispose(bool),\n  respectively. This ensures that all resources from the base class are properly released. \n\nNoncompliant Code Example\n\npublic class Foo1 : IDisposable // Noncompliant - provide protected overridable implementation of Dispose(bool) on Foo or mark the type as sealed.\n{\n    public void Dispose() // Noncompliant - should contain only a call to Dispose(true) and then GC.SuppressFinalize(this)\n    {\n        // Cleanup\n    }\n}\n\npublic class Foo2 : IDisposable\n{\n    void IDisposable.Dispose() // Noncompliant - Dispose() should be public\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    public virtual void Dispose() // Noncompliant - Dispose() should be sealed\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n}\n\npublic class Foo3 : IDisposable\n{\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        // Cleanup\n    }\n\n    ~Foo3() // Noncompliant - Modify Foo.~Foo() so that it calls Dispose(false) and then returns.\n    {\n        // Cleanup\n    }\n}{code}\n\nCompliant Solution\n\n// Sealed class\npublic sealed class Foo1 : IDisposable\n{\n    public void Dispose()\n    {\n        // Cleanup\n    }\n}\n\n// Simple implementation\npublic class Foo2 : IDisposable\n{\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        // Cleanup\n    }\n}\n\n// Implementation with a finalizer\npublic class Foo3 : IDisposable\n{\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        // Cleanup\n    }\n\n    ~Foo3()\n    {\n        Dispose(false);\n    }\n}\n\n// Base disposable class\npublic class Foo4 : DisposableBase\n{\n    protected override void Dispose(bool disposing)\n    {\n        // Cleanup\n        // Do not forget to call base\n        base.Dispose(disposing);\n    }\n}\n\nSee\nRefer to\n\n   MSDN for complete documentation on the dispose pattern. \n   Stephen Cleary for excellent Q&amp;A about\n  IDisposable \n   Pragma Geek for additional\n  usages of IDisposable, beyond releasing resources. \n   IDisposable documentation \n\n\n"
    },
    {
      "Code": "3597",
      "Title": "\"ServiceContract\" and \"OperationContract\" attributes should be used together",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3597",
      "Description": "The ServiceContract attribute specifies that a class or interface defines the communication contract of a Windows Communication\nFoundation (WCF) service. The service operations of this class or interface are defined by OperationContract attributes added to methods.\nIt doesn’t make sense to define a contract without any service operations; thus, in a ServiceContract class or interface at least one\nmethod should be annotated with OperationContract. Similarly, WCF only serves OperationContract methods that are defined\ninside ServiceContract classes or interfaces; thus, this rule also checks that ServiceContract is added to the containing\ntype of OperationContract methods.\nNoncompliant Code Example\n\n[ServiceContract]\ninterface IMyService // Noncompliant\n{\n  int MyServiceMethod();\n}\n\nCompliant Solution\n\n[ServiceContract]\ninterface IMyService\n{\n  [OperationContract]\n  int MyServiceMethod();\n}\n\n\n"
    },
    {
      "Code": "3457",
      "Title": "Composite format strings should be used correctly",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3457",
      "Description": "Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected\nbehaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of\nString.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine,\nTextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String,\u2002Object[]),\nTrace.TraceError(String,\u2002Object[]), Trace.TraceInformation(String,\u2002Object[]),\nTrace.TraceWarning(String,\u2002Object[]) and TraceSource.TraceInformation(String,\u2002Object[]).\nNoncompliant Code Example\n\ns = string.Format(\"{0}\", arg0, arg1); // Noncompliant, arg1 is declared but not used.\ns = string.Format(\"{0} {2}\", arg0, arg1, arg2); // Noncompliant, the format item with index 1 is missing so arg1 will not be used.\ns = string.Format(\"foo\"); // Noncompliant, there is no need to use string.Format here.\n\nCompliant Solution\n\ns = string.Format(\"{0}\", arg0);\ns = string.Format(\"{0} {1}\", arg0, arg2);\ns = \"foo\";\n\nExceptions\n\n   No issue is raised if the format string is not a const. \n\n\nvar pattern = \"{0} {1} {2}\";\nvar res = string.Format(pattern, 1, 2); // Compliant, not const string are not recognized\n\n\n   No issue is raised if the argument is not an inline creation array. \n\n\nvar array = new int[] {};\nvar res = string.Format(\"{0} {1}\", array); // Compliant we don't know the size of the array\n\n\n   This rule doesn’t check whether the format specifier (defined after the :) is actually valid. \n\n\n"
    },
    {
      "Code": "3445",
      "Title": "Exceptions should not be explicitly rethrown",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3445",
      "Description": "When rethrowing an exception, you should do it by simply calling throw; and not throw exc;, because the stack trace is\nreset with the second syntax, making debugging a lot harder.\nNoncompliant Code Example\n\ntry\n{}\ncatch(ExceptionType1 exc)\n{\n  Console.WriteLine(exc);\n  throw exc; // Noncompliant; stacktrace is reset\n}\ncatch (ExceptionType2 exc)\n{\n  throw new Exception(\"My custom message\", exc);  // Compliant; stack trace preserved\n}\n\nCompliant Solution\n\ntry\n{}\ncatch(ExceptionType1 exc)\n{\n  Console.WriteLine(exc);\n  throw;\n}\ncatch (ExceptionType2 exc)\n{\n  throw new Exception(\"My custom message\", exc);\n}\n\n\n"
    },
    {
      "Code": "3442",
      "Title": "\"abstract\" classes should not have \"public\" constructors",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3442",
      "Description": "Since abstract classes can’t be instantiated, there’s no point in their having public or internal\nconstructors. If there is basic initialization logic that should run when an extending class instance is created, you can by all means put it in a\nconstructor, but make that constructor private or protected.\nNoncompliant Code Example\n\nabstract class Base\n{\n    public Base() // Noncompliant, should be private or protected\n    {\n      //...\n    }\n}\n\nCompliant Solution\n\nabstract class Base\n{\n    protected Base()\n    {\n      //...\n    }\n}\n\n\n"
    },
    {
      "Code": "3415",
      "Title": "Assertion arguments should be passed in the correct order",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3415",
      "Description": "The standard assertions library methods such as AreEqual and AreSame in MSTest and\nNUnit, or Equal and Same in XUnit, expect the first argument to be the expected value and\nthe second argument to be the actual value. Swap them, and your test will still have the same outcome (succeed/fail when it should) but the error\nmessages will be confusing.\nThis rule raises an issue when the second argument to an assertions library method is a hard-coded value and the first argument is not.\nNoncompliant Code Example\n\nAssert.AreEqual(runner.ExitCode, 0, \"Unexpected exit code\"); // Noncompliant; Yields error message like: Expected:&lt;-1&gt;. Actual:&lt;0&gt;.\n\nCompliant Solution\n\nAssert.AreEqual(0, runner.ExitCode, \"Unexpected exit code\");\n\n\n"
    },
    {
      "Code": "3358",
      "Title": "Ternary operators should not be nested",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3358",
      "Description": "Just because you can do something, doesn’t mean you should, and that’s the case with nested ternary operations. Nesting ternary operators\nresults in the kind of code that may seem clear as day when you write it, but six months later will leave maintainers (or worse - future you)\nscratching their heads and cursing.\nInstead, err on the side of clarity, and use another line to express the nested operation as a separate statement.\nNoncompliant Code Example\n\npublic string GetReadableStatus(Job j)\n{\n  return j.IsRunning ? \"Running\" : j.HasErrors ? \"Failed\" : \"Succeeded\";  // Noncompliant\n}\n\nCompliant Solution\n\npublic string GetReadableStatus(Job j)\n{\n  if (j.IsRunning)\n  {\n    return \"Running\";\n  }\n  return j.HasErrors ? \"Failed\" : \"Succeeded\";\n}\n\n\n"
    },
    {
      "Code": "3267",
      "Title": "Loops should be simplified with \"LINQ\" expressions",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3267",
      "Description": "When a loop is filtering, selecting or aggregating, those functions can be handled with a clearer, more concise LINQ expression instead.\nNoncompliant Code Example\n\nvar result = new List&lt;string&gt;();\nforeach (var element in collection)  // Noncompliant\n{\n  if (condition(element))\n  {\n    result.Add(element);\n  }\n}\n\nforeach (var element in collection2) // Noncompliant\n{\n  var someValue = element.Property;\n  if (someValue != null)\n  {\n    result.Add(someValue);\n  }\n}\n\nCompliant Solution\n\nvar result = new List&lt;string&gt;();\n\nforeach (var element in collection.Where(x =&gt; condition(x)))\n{\n  result.Add(element);\n}\n\nforeach (var someValue in collection2.Select(x =&gt; x.Property).Where(y =&gt; y != null))\n{\n  result.Add(someValue);\n}\n\n\n"
    },
    {
      "Code": "3264",
      "Title": "Events should be invoked",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3264",
      "Description": "Events that are not invoked anywhere are dead code, and there’s no good reason to keep them in the source.\nNoncompliant Code Example\n\nclass UninvokedEventSample\n{\n    private event Action&lt;object, EventArgs&gt; Happened; //Noncompliant\n\n    public void RegisterEventHandler(Action&lt;object, EventArgs&gt; handler)\n    {\n        Happened += handler; //we register some event handlers\n    }\n\n    public void RaiseEvent()\n    {\n        if (Happened != null)\n        {\n            // Happened(this, null); // the event is never triggered, because this line is commented out.\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "3262",
      "Title": "\"params\" should be used on overrides",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3262",
      "Description": "Overriding methods automatically inherit the params behavior. To ease readability, this modifier should be explicitly used in the\noverriding method as well.\nNoncompliant Code Example\n\nclass Base\n{\n  public virtual void Method(params int[] numbers)\n  {\n    ...\n  }\n}\nclass Derived : Base\n{\n  public override void Method(int[] numbers) // Noncompliant, the params is missing.\n  {\n    ...\n  }\n}\n\nCompliant Solution\n\nclass Base\n{\n  public virtual void Method(params int[] numbers)\n  {\n    ...\n  }\n}\nclass Derived : Base\n{\n  public override void Method(params int[] numbers)\n  {\n    ...\n  }\n}\n\n\n"
    },
    {
      "Code": "3246",
      "Title": "Generic type parameters should be co/contravariant when possible",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3246",
      "Description": "In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the out and\nin modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively.\nThe out keyword can be used when the type parameter is used only as a return type in the interface or delegate. Doing so makes the\nparameter covariant, and allows interface and delegate instances created with a sub-type to be used as instances created with a base type. The most\nnotable example of this is IEnumerable&lt;out T&gt;, which allows the assignment of an IEnumerable&lt;string&gt; instance to\nan IEnumerable&lt;object&gt; variable, for instance.\nThe in keyword can be used when the type parameter is used only as a method parameter in the interface or a parameter in the delegate.\nDoing so makes the parameter contravariant, and allows interface and delegate instances created with a base type to be used as instances created with\na sub-type. I.e. this is the inversion of covariance. The most notable example of this is the Action&lt;in T&gt; delegate, which allows\nthe assignment of an Action&lt;object&gt; instance to a Action&lt;string&gt; variable, for instance.\nNoncompliant Code Example\n\ninterface IConsumer&lt;T&gt;  // Noncompliant\n{\n    bool Eat(T fruit);\n}\n\nCompliant Solution\n\ninterface IConsumer&lt;in T&gt;\n{\n    bool Eat(T fruit);\n}\n\n\n"
    },
    {
      "Code": "3169",
      "Title": "Multiple \"OrderBy\" calls should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3169",
      "Description": "There’s no point in chaining multiple OrderBy calls in a LINQ; only the last one will be reflected in the result because each\nsubsequent call completely reorders the list. Thus, calling OrderBy multiple times is a performance issue as well, because all of the\nsorting will be executed, but only the result of the last sort will be kept.\nInstead, use ThenBy for each call after the first.\nNoncompliant Code Example\n\nvar x = personList\n  .OrderBy(person =&gt; person.Age)\n  .OrderBy(person =&gt; person.Name)  // Noncompliant\n  .ToList();  // x is sorted by Name, not sub-sorted\n\nCompliant Solution\n\nvar x = personList\n  .OrderBy(person =&gt; person.Age)\n  .ThenBy(person =&gt; person.Name)\n  .ToList();\n\n\n"
    },
    {
      "Code": "3011",
      "Title": "Reflection should not be used to increase accessibility of classes, methods, or fields",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3011",
      "Description": "This rule raises an issue when reflection is used to change the visibility of a class, method or field, and when it is used to directly update a\nfield value. Altering or bypassing the accessibility of classes, methods, or fields violates the encapsulation principle and could lead to run-time\nerrors.\nNoncompliant Code Example\n\nusing System.Reflection;\n\nType dynClass = Type.GetType(\"MyInternalClass\");\n// Noncompliant. Using BindingFlags.NonPublic will return non-public members\nBindingFlags bindingAttr = BindingFlags.NonPublic | BindingFlags.Static;\nMethodInfo dynMethod = dynClass.GetMethod(\"mymethod\", bindingAttr);\nobject result = dynMethod.Invoke(dynClass, null);\n\n\n"
    },
    {
      "Code": "3010",
      "Title": "Static fields should not be updated in constructors",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3010",
      "Description": "Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all\ninstances of the class.\nInstead remove the field’s static modifier, or initialize it statically.\nNoncompliant Code Example\n\npublic class Person\n{\n  private static DateTime dateOfBirth;\n  private static int expectedFingers;\n\n  public Person(DateTime birthday)\n  {\n    dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday\n    expectedFingers = 10;  // Noncompliant\n  }\n}\n\nCompliant Solution\n\npublic class Person\n{\n  private DateTime dateOfBirth;\n  private static int expectedFingers = 10;\n\n  public Person(DateTime birthday)\n  {\n    this.dateOfBirth = birthday;\n  }\n}\n\n\n"
    },
    {
      "Code": "2971",
      "Title": "\"IEnumerable\" LINQs should be simplified",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2971",
      "Description": "In the interests of readability, code that can be simplified should be simplified. To that end, there are several ways IEnumerable\nlanguage integrated queries (LINQ) can be simplified\n\n   Use OfType instead of using Select with as to type cast elements and then null-checking in a query\n  expression to choose elements based on type. \n   Use OfType instead of using Where and the is operator, followed by a cast in a Select \n   Use an expression in Any instead of Where(element =&gt; [expression]).Any(). \n   Use Count instead of Count() when it’s available. \n   Don’t call ToArray() or ToList() in the middle of a query chain. \n\nUsing EntityFramework may require enforcing client evaluations. Such queries should use AsEnumerable() instead of\nToArray() or ToList() in the middle of a query chain.\nNoncompliant Code Example\n\nseq1.Select(element =&gt; element as T).Any(element =&gt; element != null);  // Noncompliant; use OfType\nseq2.Select(element =&gt; element as T).Any(element =&gt; element != null &amp;&amp; CheckCondition(element));  // Noncompliant; use OfType\nseq3.Where(element =&gt; element is T).Select(element =&gt; element as T); // Noncompliant; use OfType\nseq4.Where(element =&gt; element is T).Select(element =&gt; (T)element); // Noncompliant; use OfType\nseq5.Where(element =&gt; [expression]).Any();  // Noncompliant; use Any([expression])\n\nvar num = seq6.Count(); // Noncompliant\nvar arr = seq.ToList().ToArray(); //Noncompliant\nvar count = seq.ToList().Count(x=&gt;[condition]); //Noncompliant\n\nCompliant Solution\n\nseq1.OfType&lt;T&gt;().Any();\nseq2.OfType&lt;T&gt;().Any(element =&gt; CheckCondition(element));\nseq3.OfType&lt;T&gt;();\nseq4.OfType&lt;T&gt;();\nseq5.Any(element =&gt; [expression])\n\nvar num = seq6.Count;\nvar arr = seq.ToArray();\nvar count = seq.Count(x=&gt;[condition]);\n\n\n"
    },
    {
      "Code": "2933",
      "Title": "Fields that are only assigned in the constructor should be \"readonly\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2933",
      "Description": "readonly fields can only be assigned in a class constructor. If a class has a field that’s not marked readonly but is\nonly set in the constructor, it could cause confusion about the field’s intended use. To avoid confusion, such fields should be marked\nreadonly to make their intended use explicit, and to prevent future maintainers from inadvertently changing their use.\nNoncompliant Code Example\n\npublic class Person\n{\n    private int _birthYear;  // Noncompliant\n\n    Person(int birthYear)\n    {\n        _birthYear = birthYear;\n    }\n}\n\nCompliant Solution\n\npublic class Person\n{\n    private readonly int _birthYear;\n\n    Person(int birthYear)\n    {\n        _birthYear = birthYear;\n    }\n}\n\nExceptions\n\n   Fields with attributes are ignored. \n   Fields of type struct that are not primitive or pointer types are also ignored because of possible unwanted behavior. \n\nSee\n\n   Mutating readonly structs \n\n\n"
    },
    {
      "Code": "2743",
      "Title": "Static fields should not be used in generic types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2743",
      "Description": "A static field in a generic type is not shared among instances of different closed constructed types, thus\nLengthLimitedSingletonCollection&lt;int&gt;.instances and LengthLimitedSingletonCollection&lt;string&gt;.instances will\npoint to different objects, even though instances is seemingly shared among all LengthLimitedSingletonCollection&lt;&gt;\ngeneric classes.\nIf you need to have a static field shared among instances with different generic arguments, define a non-generic base class to store your static\nmembers, then set your generic type to inherit from the base class.\nNoncompliant Code Example\n\npublic class LengthLimitedSingletonCollection&lt;T&gt; where T : new()\n{\n  protected const int MaxAllowedLength = 5;\n  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); // Noncompliant\n\n  public static T GetInstance()\n  {\n    object instance;\n\n    if (!instances.TryGetValue(typeof(T), out instance))\n    {\n      if (instances.Count &gt;= MaxAllowedLength)\n      {\n        throw new Exception();\n      }\n      instance = new T();\n      instances.Add(typeof(T), instance);\n    }\n    return (T)instance;\n  }\n}\n\nCompliant Solution\n\npublic class SingletonCollectionBase\n{\n  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;();\n}\n\npublic class LengthLimitedSingletonCollection&lt;T&gt; : SingletonCollectionBase where T : new()\n{\n  protected const int MaxAllowedLength = 5;\n\n  public static T GetInstance()\n  {\n    object instance;\n\n    if (!instances.TryGetValue(typeof(T), out instance))\n    {\n      if (instances.Count &gt;= MaxAllowedLength)\n      {\n        throw new Exception();\n      }\n      instance = new T();\n      instances.Add(typeof(T), instance);\n    }\n    return (T)instance;\n  }\n}\n\nExceptions\nIf the static field or property uses a type parameter, then the developer is assumed to understand that the static member is not shared among the\nclosed constructed types.\n\npublic class Cache&lt;T&gt;\n{\n   private static Dictionary&lt;string, T&gt; CacheDictionary { get; set; } // Compliant\n}\n\n\n"
    },
    {
      "Code": "2681",
      "Title": "Multiline blocks should be enclosed in curly braces",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2681",
      "Description": "Curly braces can be omitted from a one-line block, such as with an if statement or for loop, but doing so can be\nmisleading and induce bugs.\nThis rule raises an issue when the whitespacing of the lines after a one line block indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.\nNote that this rule considers tab characters to be equivalent to 1 space. If you mix spaces and tabs you will sometimes see issues in code which\nlook fine in your editor but are confusing when you change the size of tabs.\nNoncompliant Code Example\n\nif (condition)\n  FirstActionInBlock();\n  SecondAction();  // Noncompliant; executed unconditionally\nThirdAction();\n\nif(condition) FirstActionInBlock(); SecondAction();  // Noncompliant; secondAction executed unconditionally\n\nif(condition) FirstActionInBlock();  // Noncompliant\n  SecondAction();  // Executed unconditionally\n\nstring str = null;\nfor (int i = 0; i &lt; array.Length; i++)\n  str = array[i];\n  DoTheThing(str);  // Noncompliant; executed only on last array element\n\nCompliant Solution\n\nif (condition)\n{\n  FirstActionInBlock();\n  SecondAction();\n}\nThirdAction();\n\nstring str = null;\nfor (int i = 0; i &lt; array.Length; i++)\n{\n  str = array[i];\n  DoTheThing(str);\n}\n\nSee\n\n   MITRE, CWE-483 - Incorrect Block Delimitation \n\n\n"
    },
    {
      "Code": "2589",
      "Title": "Boolean expressions should not be gratuitous",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2589",
      "Description": "If a boolean expression doesn’t change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous\nbecause it does not match the programmer’s intent, then it’s a bug and the expression should be fixed.\nNoncompliant Code Example\n\npublic void Sample(bool b, bool c, string s)\n{\n    var a = true;\n    if (a) // Noncompliant\n    {\n        DoSomething();\n    }\n\n    if (b &amp;&amp; a) // Noncompliant; \"a\" is always \"true\"\n    {\n        DoSomething();\n    }\n\n    if (c || !a) // Noncompliant; \"!a\" is always \"false\"\n    {\n        DoSomething();\n    }\n\n    string d = null;\n    var v1 = d ?? \"value\"; // Noncompliant, d is always null\n    var v2 = s ?? d; // Noncompliant, d is always null and the produced value is always equal to s. The condition to check the value of s is gratuitous.\n}\n\nCompliant Solution\n\npublic void Sample(bool b, bool c, string s)\n{\n    var a = true;\n    if (Foo(a))\n    {\n        DoSomething();\n    }\n\n    if (b)\n    {\n        DoSomething();\n    }\n\n    if (c)\n    {\n        DoSomething();\n    }\n\n    var v1 = \"value\";\n    var v2 = s;\n}\n\nSee\n\n   MITRE, CWE-571 - Expression is Always True \n   MITRE, CWE-570 - Expression is Always False \n\n\n"
    },
    {
      "Code": "2436",
      "Title": "Types and methods should not have too many generic parameters",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2436",
      "Description": "A method or class with too many type parameters has likely aggregated too many responsibilities and should be split.\nNoncompliant Code Example\nWith the default parameter value of 2:\n\n&lt;S, T, U, V&gt; void foo() {} // Noncompliant; not really readable\n&lt;String, Integer, Object, String&gt;foo(); // especially on invocations\n\n\n"
    },
    {
      "Code": "2376",
      "Title": "Write-only properties should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2376",
      "Description": "Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or the property should be\nreplaced with a setter method.\nNoncompliant Code Example\n\nclass Program\n{\n    public int Foo  //Non-Compliant\n    {\n        set\n        {\n            // ... some code ...\n        }\n    }\n}\n\nCompliant Solution\n\nclass Program\n{\n    private int foo;\n\n    public void SetFoo(int value)\n    {\n        // ... some code ...\n        foo = value;\n    }\n}\n\nor\n\nclass Program\n{\n  public int Foo { get; set; } // Compliant\n}\n\n\n"
    },
    {
      "Code": "2372",
      "Title": "Exceptions should not be thrown from property getters",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2372",
      "Description": "Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a\nmethod.\nIt is valid to throw exceptions from indexed property getters and from property setters, which are not detected by this rule.\nNoncompliant Code Example\n\npublic int Foo\n{\n    get\n    {\n        throw new Exception(); // Noncompliant\n    }\n}\n\nCompliant Solution\n\npublic int Foo\n{\n    get\n    {\n        return 42;\n    }\n}\n\nExceptions\nNo issue is raised when the thrown exception derives from or is of type NotImplementedException, NotSupportedException or\nInvalidOperationException.\n\n"
    },
    {
      "Code": "2326",
      "Title": "Unused type parameters should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2326",
      "Description": "Type parameters that aren’t used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type\nparameters should be removed.\nNoncompliant Code Example\n\npublic class MoreMath&lt;T&gt;   // Noncompliant; &lt;T&gt; is ignored\n{\n  public int Add&lt;T&gt;(int a, int b) // Noncompliant; &lt;T&gt; is ignored\n  {\n    return a + b;\n  }\n}\n\nCompliant Solution\n\npublic class MoreMath\n{\n  public int Add (int a, int b)\n  {\n    return a + b;\n  }\n}\n\n\n"
    },
    {
      "Code": "2234",
      "Title": "Parameters should be passed in the correct order",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2234",
      "Description": "When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.\nNoncompliant Code Example\n\npublic double Divide(int divisor, int dividend)\n{\n    return divisor/dividend;\n}\n\npublic void DoTheThing()\n{\n    int divisor = 15;\n    int dividend = 5;\n\n    double result = Divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n    //...\n}\n\nCompliant Solution\n\npublic double Divide(int divisor, int dividend)\n{\n    return divisor/dividend;\n}\n\npublic void DoTheThing()\n{\n    int divisor = 15;\n    int dividend = 5;\n\n    double result = Divide(divisor, dividend);\n    //...\n}\n\n\n"
    },
    {
      "Code": "1871",
      "Title": "Two branches in a conditional structure should not have exactly the same implementation",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1871",
      "Description": "Having two cases in the same switch statement or branches in the same if structure with the same\nimplementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an\nif structure they should be combined, or for a switch, one should fall through to the other.\nNoncompliant Code Example\n\nswitch (i)\n{\n  case 1:\n    DoFirst();\n    DoSomething();\n    break;\n  case 2:\n    DoSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1's implementation\n    DoFirst();\n    DoSomething();\n    break;\n  default:\n    DoTheRest();\n}\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10)\n{\n  DoFirst();\n  DoTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20)\n{\n  DoTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50)   // Noncompliant; duplicates first condition\n{\n  DoFirst();\n  DoTheThing();\n}\n\nExceptions\nBlocks in an if chain that contain a single line of code are ignored, as are blocks in a switch statement that contain a\nsingle line of code with or without a following break.\n\nif (a &gt;= 0 &amp;&amp; a &lt; 10)\n{\n  DoTheThing();\n}\nelse if (a &gt;= 10 &amp;&amp; a &lt; 20)\n{\n  DoTheOtherThing();\n}\nelse if (a &gt;= 20 &amp;&amp; a &lt; 50)    //no issue, usually this is done on purpose to increase the readability\n{\n  DoTheThing();\n}\n\nBut this exception does not apply to if chains without else-s, or to switch-es without default clauses when\nall branches have the same single line of code. In case of if chains with else-s, or of switch-es with default\nclauses, rule {rule:csharpsquid:S3923} raises a bug.\n\nif(a == 1)\n{\n  doSomething();  //Noncompliant, this might have been done on purpose but probably not\n}\nelse if (a == 2)\n{\n  doSomething();\n}\n\n\n"
    },
    {
      "Code": "1854",
      "Title": "Unused assignments should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1854",
      "Description": "A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value\nonly to then overwrite it or throw it away, could indicate a serious error in the code. Even if it’s not an error, it is at best a waste of resources.\nTherefore all calculated values should be used.\nNoncompliant Code Example\n\ni = a + b; // Noncompliant; calculation result not used before value is overwritten\ni = compute();\n\nCompliant Solution\n\ni = a + b;\ni += compute();\n\nExceptions\nNo issue is reported when\n\n   the analyzed method body contains try blocks, \n   a lambda expression captures the local variables, or \n   the variable is unused (case covered by Rule {rule:csharpsquid:S1481}) \n   initializations to -1, 0, 1, null, true, false, \"\"\n  and string.Empty. \n\nSee\n\n   MITRE, CWE-563 - Assignment to Variable without Use ('Unused Variable') \n\n\n"
    },
    {
      "Code": "1607",
      "Title": "Tests should not be ignored",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1607",
      "Description": "When a test fails due, for example, to infrastructure issues, you might want to ignore it temporarily. But without some kind of notation about why\nthe test is being ignored, it may never be reactivated. Such tests are difficult to address without comprehensive knowledge of the project, and end up\npolluting their projects.\nThis rule raises an issue for each ignored test that does not have a WorkItem attribute nor a comment about why it is being skipped on\nthe right side of the Ignore attribute.\nNoncompliant Code Example\n\n[TestMethod]\n[Ignore]\npublic void Test_DoTheThing()\n{\n  // ...\n}\n\nCompliant Solution\n\n[TestMethod]\n[Ignore]  // renable when TCKT-1234 is fixed\npublic void Test_DoTheThing()\n{\n  // ...\n}\n\nor\n\n[TestMethod]\n[Ignore]\n[WorkItem(1234)]\npublic void Test_DoTheThing()\n{\n  // ...\n}\n\nExceptions\nThe rule doesn’t raise an issue if:\n\n   the test method is also marked with WorkItem attribute \n   there is a comment on the right side of the Ignore attribute \n\n\n"
    },
    {
      "Code": "1479",
      "Title": "\"switch\" statements should not have too many \"case\" clauses",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1479",
      "Description": "When switch statements have large sets of case clauses, it is usually an attempt to map two sets of data. A Dictionary\nshould be used instead to make the code more readable and maintainable.\nNoncompliant Code Example\nWith a \"Maximum number of case\" set to 4\n\npublic class TooManyCase\n{\n    public int switchCase(char ch)\n    {\n        switch(ch) {  // Noncompliant\n            case 'a':\n                return 1;\n            case 'b':\n            case 'c':\n                return 2;\n            case 'd':\n                return 3;\n            case 'e':\n                return 4;\n            case 'f':\n            case 'g':\n            case 'h':\n                return 5;\n            default:\n                return 6;\n        }\n    }\n}\n\nCompliant Solution\n\nusing System.Collections.Generic;\n\npublic class TooManyCase\n{\n    Dictionary&lt;char, int&gt; matching = new Dictionary&lt;char, int&gt;()\n    {\n        {'a', 1}, {'b', 2}, {'c', 2}, {'d', 3},\n        {'e', 4}, {'f', 5}, {'g', 5}, {'h', 5}\n    };\n\n    public int withDictionary(char ch)\n    {\n        int value;\n        if (this.matching.TryGetValue(ch, out value)) {\n            return value;\n        } else {\n            return 6;\n        }\n    }\n}\n\nExceptions\nThis rule ignores switches over Enums and empty, fall-through cases.\n\n"
    },
    {
      "Code": "125",
      "Title": "Sections of code should not be commented out",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-125",
      "Description": "Programmers should not comment out code as it bloats programs and reduces readability.\nUnused code should be deleted and can be retrieved from source control history if required.\n\n"
    },
    {
      "Code": "1172",
      "Title": "Unused method parameters should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1172",
      "Description": "Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.\nThis rule raises an issue when a private method of a class/struct takes a parameter without using it.\nNoncompliant Code Example\n\nprivate void DoSomething(int a, int b) // \"b\" is unused\n{\n    Compute(a);\n}\n\nprivate void DoSomething2(int a) // value of \"a\" is unused\n{\n    a = 10;\n    Compute(a);\n}\n\nCompliant Solution\n\nprivate void DoSomething(int a)\n{\n    Compute(a);\n}\n\nprivate void DoSomething2()\n{\n    var a = 10;\n    Compute(a);\n}\n\nExceptions\nThis rule doesn’t raise any issue in the following contexts:\n\n   The this parameter of extension methods. \n   Methods decorated with attributes. \n   Empty methods. \n   Methods which only throw NotImplementedException. \n   Main methods. \n   virtual, override methods. \n   interface implementations. \n\n\n"
    },
    {
      "Code": "1168",
      "Title": "Empty arrays and collections should be returned instead of null",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1168",
      "Description": "Returning null instead of an actual array, collection or map forces callers of the method to explicitly test for nullity, making them\nmore complex and less readable.\nMoreover, in many cases, null is used as a synonym for empty.\nNoncompliant Code Example\n\npublic Result[] GetResults()\n{\n    return null; // Noncompliant\n}\n\npublic IEnumerable&lt;Result&gt; GetResults()\n{\n    return null; // Noncompliant\n}\n\npublic IEnumerable&lt;Result&gt; GetResults() =&gt; null; // Noncompliant\n\npublic IEnumerable&lt;Result&gt; Results\n{\n    get\n    {\n        return null; // Noncompliant\n    }\n}\n\npublic IEnumerable&lt;Result&gt; Results =&gt; null; // Noncompliant\n\nCompliant Solution\n\npublic Result[] GetResults()\n{\n    return new Result[0];\n}\n\npublic IEnumerable&lt;Result&gt; GetResults()\n{\n    return Enumerable.Empty&lt;Result&gt;();\n}\n\npublic IEnumerable&lt;Result&gt; GetResults() =&gt; Enumerable.Empty&lt;Result&gt;();\n\npublic IEnumerable&lt;Result&gt; Results\n{\n    get\n    {\n        return Enumerable.Empty&lt;Result&gt;();\n    }\n}\n\npublic IEnumerable&lt;Result&gt; Results =&gt; Enumerable.Empty&lt;Result&gt;();\n\nExceptions\nAlthough string is a collection, the rule won’t report on it.\n\n"
    },
    {
      "Code": "1144",
      "Title": "Unused private types or members should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1144",
      "Description": "private or internal types or private members that are never executed or referenced are dead code:\nunnecessary, inoperative code that should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it easier to\nunderstand the program and preventing bugs from being introduced.\nNoncompliant Code Example\n\npublic class Foo\n{\n    private void UnusedPrivateMethod() {...} // Noncompliant\n\n    private class UnusedClass {...} // Noncompliant\n}\n\nCompliant Solution\n\npublic class Foo\n{\n    public Foo()\n    {\n        UsedPrivateMethod();\n    }\n\n    private void UsedPrivateMethod()\n    {\n        var c = new UsedClass();\n    }\n\n    private class UsedClass {...}\n}\n\nExceptions\nThis rule doesn’t raise issues on:\n\n   Empty constructors \n   Attributed members \n   Main method \n   Methods with event handler signature void Foo(object, EventArgs) that are declared in partial class \n   Empty serialization constructor on type with System.SerializableAttribute attribute. \n   Internals in assemblies that have a System.Runtime.CompilerServices.InternalsVisibleToAttribute attribute. \n\n\n"
    },
    {
      "Code": "1134",
      "Title": "Track uses of \"FIXME\" tags",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1134",
      "Description": "FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.\nSometimes the developer will not have the time or will simply forget to get back to that tag.\nThis rule is meant to track those tags and to ensure that they do not go unnoticed.\nNoncompliant Code Example\n\nprivate int Divide(int numerator, int denominator)\n{\n    return numerator / denominator;  // FIXME denominator value might be  0\n}\n\nSee\n\n   MITRE, CWE-546 - Suspicious Comment \n\n\n"
    },
    {
      "Code": "1123",
      "Title": "\"Obsolete\" attributes should include explanations",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1123",
      "Description": "The Obsolete attribute can be applied with or without arguments, but marking something Obsolete without including advice\nas to why it’s obsolete or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time the\nwarning is encountered.\nNoncompliant Code Example\n\npublic class Car\n{\n\n  [Obsolete]  // Noncompliant\n  public void CrankEngine(int turnsOfCrank)\n  { ... }\n}\n\nCompliant Solution\n\npublic class Car\n{\n\n  [Obsolete(\"Replaced by the automatic starter\")]\n  public void CrankEngine(int turnsOfCrank)\n  { ... }\n}\n\n\n"
    },
    {
      "Code": "1121",
      "Title": "Assignments should not be made from within sub-expressions",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1121",
      "Description": "Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have\nside-effects.\nNoncompliant Code Example\n\nif (string.IsNullOrEmpty(result = str.Substring(index, length))) // Noncompliant\n{\n  //...\n}\n\nCompliant Solution\n\nvar result = str.Substring(index, length);\nif (string.IsNullOrEmpty(result))\n{\n  //...\n}\n\nExceptions\nAssignments inside lambda and delegate expressions are allowed.\nFurthermore, the following patterns are also accepted:\n\nvar a = b = c = 10;\n\n\nwhile ((val = GetNewValue()) &gt; 0)\n{\n...\n}\n\n\nprivate MyClass instance;\npublic MyClass Instance\n{\n  get\n  {\n    return instance ?? (instance = new MyClass());\n  }\n}\n\nSee\n\n   MITRE, CWE-481 - Assigning instead of Comparing \n\n\n"
    },
    {
      "Code": "112",
      "Title": "General exceptions should never be thrown",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-112",
      "Description": "Throwing such general exceptions as Exception, SystemException, ApplicationException,\nIndexOutOfRangeException, NullReferenceException, OutOfMemoryException and\nExecutionEngineException prevents calling methods from handling true, system-generated exceptions differently than application-generated\nerrors.\nNoncompliant Code Example\n\npublic void DoSomething(object obj)\n{\n  if (obj == null)\n  {\n    throw new NullReferenceException(\"obj\");  // Noncompliant\n  }\n  // ...\n}\n\nCompliant Solution\n\npublic void DoSomething(object obj)\n{\n  if (obj == null)\n  {\n    throw new ArgumentNullException(\"obj\");\n  }\n  // ...\n}\n\nSee\n\n   MITRE, CWE-397 - Declaration of Throws for Generic Exception \n\n\n"
    },
    {
      "Code": "1118",
      "Title": "Utility classes should not have public constructors",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1118",
      "Description": "Utility classes, which are collections of static members, are not meant to be instantiated.\nC# adds an implicit public constructor to every class which does not explicitly define at least one constructor. Hence, at least one\nprotected constructor should be defined if you wish to subclass this utility class. Or the static keyword should be added to\nthe class declaration to prevent subclassing.\nNoncompliant Code Example\n\npublic class StringUtils // Noncompliant\n{\n  public static string Concatenate(string s1, string s2)\n  {\n    return s1 + s2;\n  }\n}\n\nCompliant Solution\n\npublic static class StringUtils\n{\n  public static string Concatenate(string s1, string s2)\n  {\n    return s1 + s2;\n  }\n}\n\nor\n\npublic class StringUtils\n{\n  protected StringUtils()\n  {\n  }\n  public static string Concatenate(string s1, string s2)\n  {\n    return s1 + s2;\n  }\n}\n\n\n"
    },
    {
      "Code": "1117",
      "Title": "Local variables should not shadow class fields",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1117",
      "Description": "Overriding or shadowing a variable declared in an outer scope can strongly impact the readability, and therefore the maintainability, of a piece of\ncode. Further, it could lead maintainers to introduce bugs because they think they’re using one variable but are really using another.\nNoncompliant Code Example\n\nclass Foo\n{\n  public int myField;\n\n  public void DoSomething()\n  {\n    int myField = 0;  // Noncompliant\n    ...\n  }\n}\n\n\n"
    },
    {
      "Code": "1110",
      "Title": "Redundant pairs of parentheses should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1110",
      "Description": "The use of parentheses, even those not required to enforce a desired order of operations, can clarify the intent behind a piece of code. But\nredundant pairs of parentheses could be misleading, and should be removed.\nNoncompliant Code Example\n\nif (a &amp;&amp; ((x + y &gt; 0))) // Noncompliant\n{\n  //...\n}\n\nreturn ((x + 1));  // Noncompliant\n\nCompliant Solution\n\nif (a &amp;&amp; (x + y &gt; 0))\n{\n  //...\n}\n\nreturn x + 1;\n\nreturn (x + 1);\n\n\n"
    },
    {
      "Code": "110",
      "Title": "Inheritance tree of classes should not be too deep",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-110",
      "Description": "Inheritance is certainly one of the most valuable concepts in object-oriented programming. It’s a way to compartmentalize and reuse code by\ncreating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating\na deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object\noriented design which has led to systematically use 'inheritance' when for instance 'composition' would suit better.\nThis rule raises an issue when the inheritance tree, starting from Object has a greater depth than is allowed.\n\n"
    },
    {
      "Code": "108",
      "Title": "Nested blocks of code should not be left empty",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-108",
      "Description": "Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.\nNoncompliant Code Example\n\nfor (int i = 0; i &lt; 42; i++){}  // Empty on purpose or missing piece of code ?\n\nExceptions\nWhen a block contains a comment, this block is not considered to be empty.\n\n"
    },
    {
      "Code": "107",
      "Title": "Methods should not have too many parameters",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-107",
      "Description": "A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many\nthings.\nNoncompliant Code Example\nWith a maximum number of 4 parameters:\n\npublic void doSomething(int param1, int param2, int param3, string param4, long param5)\n{\n...\n}\n\nCompliant Solution\n\npublic void doSomething(int param1, int param2, int param3, string param4)\n{\n...\n}\n\n\n"
    },
    {
      "Code": "1066",
      "Title": "Collapsible \"if\" statements should be merged",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1066",
      "Description": "Merging collapsible if statements increases the code’s readability.\nNoncompliant Code Example\n\nif (condition1)\n{\n    if (condition2)\n    {\n        // ...\n    }\n}\n\nCompliant Solution\n\nif (condition1 &amp;&amp; condition2)\n{\n    // ...\n}\n\n\n"
    },
    {
      "Code": "5883",
      "Title": "OS commands should not be vulnerable to argument injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5883",
      "Description": "Applications that allow execution of operating system commands from user-controlled data should control the arguments passed to the command,\notherwise an attacker can inject additional arbitrary arguments which can change the behavior of the command.\nUser-controlled arguments should be sanitized by neutralizing argument delimiters (eg: ', space, -) and thus preventing\ninjection of unwanted additional arguments. A single user-controlled argument may still lead to vulnerabilities if it corresponds to a dangerous\noption supported by the command, such as -exec available with find, in that case, mark end\nof option processing on the command line using -- (double-dash) or restrict the options to only trusted values.\nNoncompliant Code Example\n\nusing System.Diagnostics;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class NoncompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult Run(string args)\n        {\n            Process p = new Process();\n            p.StartInfo.FileName = \"/usr/bin/file.exe\"\";\n            p.StartInfo.Arguments = args; // Noncompliant\n            p.StartInfo.RedirectStandardOutput = true;\n            p.Start();\n            string output = p.StandardOutput.ReadToEnd();\n            p.Dispose();\n\n            return View();\n        }\n    }\n}\n\nCompliant Solution\n\nusing System.Diagnostics;\nusing System.Text.RegularExpressions;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class CompliantController : Controller\n    {\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public IActionResult Run(string arg)\n        {\n            Process p = new Process();\n            p.StartInfo.FileName = \"/usr/bin/file.exe\"\";\n            p.StartInfo.ArgumentList.Add(arg); // Compliant\n            p.StartInfo.RedirectStandardOutput = true;\n            p.Start();\n            string output = p.StandardOutput.ReadToEnd();\n            p.Dispose();\n\n            return View();\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP OS Command Injection Defense Cheat\n  Sheet \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-88 - Argument Injection or Modification \n   SANS Top 25 - Insecure Interaction Between Components \n\n\n"
    },
    {
      "Code": "5145",
      "Title": "Logging should not be vulnerable to injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5145",
      "Description": "User provided data, such as URL parameters, POST data payloads or cookies, should always be considered untrusted and tainted. Applications logging\ntainted data could enable an attacker to inject characters that would break the log file pattern. This could be used to block monitors and SIEM\n(Security Information and Event Management) systems from detecting other malicious events.\nThis problem could be mitigated by sanitizing the user provided data before logging it.\nNoncompliant Code Example\n\nusing System;\nusing Microsoft.AspNetCore.Mvc;\n\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC5145LogInjectionLog4NetNoncompliantController : Controller\n    {\n        private static readonly log4net.ILog _logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);\n\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public void LogSomething(string id)\n        {\n            if (id != null)\n            {\n                _logger.Info(\"ID: \" + id);\n            }\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing Microsoft.AspNetCore.Mvc;\n\nnamespace WebApplicationDotNetCore.Controllers\n{\n    public class RSPEC5145LogInjectionLog4NetCompliantController : Controller\n    {\n        private static readonly log4net.ILog _logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);\n\n        public IActionResult Index()\n        {\n            return View();\n        }\n\n        public void LogSomething(string id)\n        {\n\n            if (id != null)\n            {\n                // Replace pattern-breaking characters\n                id = id.Replace('\\n', '_').Replace('\\r', '_').Replace('\\t', '_');\n                _logger.Info(\"ID: \" + id);\n            }\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2021 Category A9 - Security Logging and\n  Monitoring Failures \n   OWASP Cheat Sheet - Logging \n   OWASP Attack Category - Log Injection \n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-117 - Improper Output Neutralization for Logs \n   SANS Top 25 - Insecure Interaction Between Components \n\n\n"
    },
    {
      "Code": "4158",
      "Title": "Empty collections should not be accessed or iterated",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4158",
      "Description": "When a collection is empty it makes no sense to access or iterate it. Doing so anyway is surely an error; either population was accidentally\nomitted or the developer doesn’t understand the situation.\nThis rule raises an issue when any use is made of an empty collection other than the following ignored calls: Add,\nAddRange, Equals, GetHashCode.\nNoncompliant Code Example\n\nvar strings = new List&lt;string&gt;();\n\nstrings.Remove(\"bar\");  // Noncompliant\n\nif (strings.Contains(\"foo\")) {}  // Noncompliant\n\nforeach (var str in strings) {}  // Noncompliant\n\n\n"
    },
    {
      "Code": "3887",
      "Title": "Mutable, non-private fields should not be \"readonly\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3887",
      "Description": "Using the readonly keyword on a field means that it can’t be changed after initialization. However, when applied to collections or\narrays, that’s only partly true. readonly enforces that another instance can’t be assigned to the field, but it cannot keep the contents\nfrom being updated. That means that in practice, the field value really can be changed, and the use of readonly on such a field is\nmisleading, and you’re likely to not be getting the behavior you expect.\nThis rule raises an issue when a non-private, readonly field is an array or collection.\nNoncompliant Code Example\n\npublic class MyClass\n{\n  public readonly string[] strings;  // Noncompliant\n\n  // ...\n\nCompliant Solution\n\npublic class MyClass\n{\n  public string[] strings;\n\n  // ...\n\nor\n\npublic class MyClass\n{\n  public readonly ImmutableArray&lt;string&gt; strings;\n\n  // ...\n\nor\n\npublic class MyClass\n{\n  private readonly string[] strings;\n\n  // ...\n\n\n"
    },
    {
      "Code": "3456",
      "Title": "\"string.ToCharArray()\" should not be called redundantly",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3456",
      "Description": "ToCharArray can be omitted when the operation on the array could have been done directly on the string, such as when iterating over\nthe characters in a string, and when accessing a character in a string via an array index. In those cases, explicit ToCharArray calls\nshould be omitted.\nNoncompliant Code Example\n\nstring str = \"some string\";\nforeach (var c in str.ToCharArray()) // Noncompliant\n{\n  // ...\n}\n\nCompliant Solution\n\nstring str = \"some string\";\nforeach (var c in str)\n{\n  // ...\n}\n\n\n"
    },
    {
      "Code": "3397",
      "Title": "\"base.Equals\" should not be used to check for reference equality in \"Equals\" if \"base\" is not \"object\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3397",
      "Description": "object.Equals() overrides can be optimized by checking first for reference equality between this and the parameter. This\ncheck can be implemented by calling object.ReferenceEquals() or base.Equals(), where base is\nobject. However, using base.Equals() is a maintenance hazard because while it works if you extend Object\ndirectly, if you introduce a new base class that overrides Equals, it suddenly stops working.\nThis rule raises an issue if base.Equals() is used but base is not object.\nNoncompliant Code Example\n\nclass Base\n{\n  private int baseField;\n\n  public override bool Equals(object other)\n  {\n    if (base.Equals(other)) // Okay; base is object\n    {\n      return true;\n    }\n\n    return this.baseField == ((Base)other).baseField;\n  }\n}\n\nclass Derived : Base\n{\n  private int derivedField;\n\n  public override bool Equals(object other)\n  {\n    if (base.Equals(other))  // Noncompliant\n    {\n      return true;\n    }\n\n    return this.derivedField == ((Derived)other).derivedField;\n  }\n}\n\nCompliant Solution\n\nclass Base\n{\n  private int baseField;\n\n  public override bool Equals(object other)\n  {\n    if (object.ReferenceEquals(this, other))  // base.Equals is okay here, but object.ReferenceEquals is better\n    {\n      return true;\n    }\n\n    return this.baseField == ((Base)other).baseField;\n  }\n}\n\nclass Derived : Base\n{\n  private int derivedField;\n\n  public override bool Equals(object other)\n  {\n    if (object.ReferenceEquals(this, other))\n    {\n      return true;\n    }\n\n    return base.Equals(other) &amp;&amp; this.derivedField == ((Derived)other).derivedField;\n  }\n}\n\n\n"
    },
    {
      "Code": "2934",
      "Title": "Property assignments should not be made for \"readonly\" fields not constrained to reference types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2934",
      "Description": "While the properties of a readonly reference type field can still be changed after initialization, those of a readonly\nvalue field, such as a struct, cannot.\nIf the member could be either a class or a struct then assignment to its properties could be unreliable, working\nsometimes but not others.\nNoncompliant Code Example\n\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T: IPoint\n{\n  readonly T point;  // this could be a struct\n  public PointManager(T point)\n  {\n    this.point = point;\n  }\n\n  public void MovePointVertically(int newX)\n  {\n    point.X = newX; //Noncompliant; if point is a struct, then nothing happened\n    Console.WriteLine(point.X);\n  }\n}\n\nCompliant Solution\n\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T : IPoint\n{\n  readonly T point;  // this could be a struct\n  public PointManager(T point)\n  {\n    this.point = point;\n  }\n\n  public void MovePointVertically(int newX) // assignment has been removed\n  {\n    Console.WriteLine(point.X);\n  }\n}\n\nor\n\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T : class, IPoint\n{\n  readonly T point;  // this can only be a class\n  public PointManager(T point)\n  {\n    this.point = point;\n  }\n\n  public void MovePointVertically(int newX)\n  {\n    point.X = newX;  // this assignment is guaranteed to work\n    Console.WriteLine(point.X);\n  }\n}\n\n\n"
    },
    {
      "Code": "2345",
      "Title": "Flags enumerations should explicitly initialize all their members",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2345",
      "Description": "Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization will set the first member to\n0, and increment the value by one for each subsequent member. This implicit behavior does not allow members to be combined using the bitwise or\noperator in a useful way.\nInstead, 0 and powers of two (i.e. 1, 2, 4, 8, 16, …​) should be used to explicitly initialize all the members.\nNoncompliant Code Example\n\n[Flags]\nenum FruitType    // Noncompliant\n{\n  None,\n  Banana,\n  Orange,\n  Strawberry\n}\nclass Program\n{\n    static void Main()\n    {\n        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;\n        // Will display only Strawberry!\n        Console.WriteLine(bananaAndStrawberry.ToString());\n    }\n}\n\nCompliant Solution\n\n[Flags]\nenum FruitType\n{\n  None = 0,\n  Banana = 1,\n  Orange = 2,\n  Strawberry = 4\n}\nclass Program\n{\n    static void Main()\n    {\n        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;\n        // Will display Banana and Strawberry, as expected.\n        Console.WriteLine(bananaAndStrawberry.ToString());\n    }\n}\n\nExceptions\nThe default initialization of 0, 1, 2, 3, 4, …​ matches 0, 1, 2, 4, 8 …​ in the first three values, so no issue is reported if the first three\nmembers of the enumeration is not initialized.\n\n"
    },
    {
      "Code": "2328",
      "Title": "\"GetHashCode\" should not reference mutable fields",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2328",
      "Description": "GetHashCode is used to file an object in a Dictionary or Hashtable. If GetHashCode uses\nnon-readonly fields and those fields change after the object is stored, the object immediately becomes mis-filed in the\nHashtable. Any subsequent test to see if the object is in the Hashtable will return a false negative.\nNoncompliant Code Example\n\npublic class Person\n{\n  public int age;\n  public string name;\n\n  public override int GetHashCode()\n  {\n    int hash = 12;\n    hash += this.age.GetHashCode(); // Noncompliant\n    hash += this.name.GetHashCode(); // Noncompliant\n    return hash;\n  }\n\nCompliant Solution\n\npublic class Person\n{\n  public readonly DateTime birthday;\n  public string name;\n\n  public override int GetHashCode()\n  {\n    int hash = 12;\n    hash += this.birthday.GetHashCode();\n    return hash;\n  }\n\n\n"
    },
    {
      "Code": "2184",
      "Title": "Results of integer division should not be assigned to floating point variables",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2184",
      "Description": "When division is performed on ints, the result will always be an int. You can assign that result to a\ndouble, float or decimal with automatic type conversion, but having started as an int, the result\nwill likely not be what you expect. If the result of int division is assigned to a floating-point variable, precision will have been lost\nbefore the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place.\nNoncompliant Code Example\n\nstatic void Main()\n{\n  decimal dec = 3/2; // Noncompliant\n  Method(3/2); // Noncompliant\n}\n\nstatic void Method(float f) { }\n\nCompliant Solution\n\nstatic void Main()\n{\n  decimal dec = (decimal)3/2;\n  Method(3.0F/2);\n}\n\nstatic void Method(float f) { }\n\nSee\n\n   MITRE, CWE-190 - Integer Overflow or Wraparound \n   SANS Top 25 - Risky Resource Management \n\n\n"
    },
    {
      "Code": "2183",
      "Title": "Integral numbers should not be shifted by zero or more than their number of bits-1",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2183",
      "Description": "Shifting an integral number by 0 is equivalent to doing nothing but makes the code confusing for maintainers.\nIf the first operand is an int or uint (32-bit quantity), the shift count is given by the low-order five bits of the\nsecond operand. That is, the actual shift count is 0 to 31 bits.\nNote that integral number with a less than 32-bit quantity (e.g. short, ushort…​) are implicitly converted to\nint before the shifting operation and so the rule for int/uint applies.\nIf the first operand is a long or ulong (64-bit quantity), the shift count is given by the low-order six bits of the\nsecond operand. That is, the actual shift count is 0 to 63 bits.\nNoncompliant Code Example\n\npublic void Main()\n{\n    short s = 1;\n    short shortShift1 = (short)(s &lt;&lt; 0); // Noncompliant\n    short shortShift1 = (short)(s &lt;&lt; 16); // Compliant as short will be cast to int (16 is between 0 and 31)\n    short shortShift3 = (short)(s &lt;&lt; 32); // Noncompliant, this is equivalent to shifting by 1\n\n    int i = 1;\n    int intShift1 = i &lt;&lt; 0; // Noncompliant\n    int intShift2 = i &lt;&lt; 32; // Noncompliant, this is equivalent to shifting by 1\n\n    long lg = 1;\n    long longShift1 = lg &lt;&lt; 0; // Noncompliant\n    long longShift2 = lg &lt;&lt; 64; // Noncompliant, this is equivalent to shifting by 1\n}\n\nCompliant Solution\n\npublic void Main()\n{\n    short s = 1;\n    short shortShift1 = s;\n    short shortShift1 = (short)(s &lt;&lt; 16);\n    short shortShift3 = (short)(s &lt;&lt; 1);\n\n    int i = 1;\n    var intShift1 = i;\n    var intShift2 = i &lt;&lt; 1;\n\n    long lg = 1;\n    var longShift1 = lg;\n    var longShift2 = lg &lt;&lt; 1;\n}\n\nExceptions\nThis rule doesn’t raise an issue when the shift by zero is obviously for cosmetic reasons:\n\n   When the value shifted is a literal. \n   When there is a similar shift at the same position on line before or after. E.g.: \n\n\nbytes[loc+0] = (byte)(value &gt;&gt; 8);\nbytes[loc+1] = (byte)(value &gt;&gt; 0);\n\nSee\n\n   Microsoft\n  documentation - Bitwise and shift operators \n\n\n"
    },
    {
      "Code": "1206",
      "Title": "\"Equals(Object)\" and \"GetHashCode()\" should be overridden in pairs",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1206",
      "Description": "There is a contract between Equals(object) and GetHashCode(): If two objects are equal according to the\nEquals(object) method, then calling GetHashCode() on each of them must yield the same result. If this is not the case, many\ncollections won’t handle class instances correctly.\nIn order to comply with the contract, Equals(object) and GetHashCode() should be either both inherited, or both\noverridden.\nNoncompliant Code Example\n\nclass MyClass   // Noncompliant - should also override \"GetHashCode()\"\n{\n    public override bool Equals(object obj)\n    {\n        // ...\n    }\n}\n\nCompliant Solution\n\nclass MyClass\n{\n    public override bool Equals(object obj)\n    {\n        // ...\n    }\n\n    public override int GetHashCode()\n    {\n        // ...\n    }\n}\n\nSee\n\n   MITRE, CWE-581 - Object Model Violation: Just One of Equals and Hashcode Defined\n  \n\n\n"
    },
    {
      "Code": "5122",
      "Title": "Having a permissive Cross-Origin Resource Sharing policy is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5122",
      "Description": "Having a permissive Cross-Origin Resource Sharing policy is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2018-0269 \n   CVE-2017-14460 \n\nSame origin policy in browsers prevents, by default and for\nsecurity-reasons, a javascript frontend to perform a cross-origin HTTP request to a resource that has a different origin (domain, protocol, or port)\nfrom its own. The requested target can append additional HTTP headers in response, called CORS, that act like directives for the browser and change the access control policy\n/ relax the same origin policy.\nAsk Yourself Whether\n\n   You don’t trust the origin specified, example: Access-Control-Allow-Origin: untrustedwebsite.com. \n   Access control policy is entirely disabled: Access-Control-Allow-Origin: * \n   Your access control policy is dynamically defined by a user-controlled input like origin header. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   The Access-Control-Allow-Origin header should be set only for a trusted origin and for specific resources. \n   Allow only selected, trusted domains in the Access-Control-Allow-Origin header. Prefer whitelisting domains over blacklisting or\n  allowing any domain (do not use * wildcard nor blindly return the Origin header content without any checks). \n\nSensitive Code Example\nASP.NET Core MVC\n\n[HttpGet]\npublic string Get()\n{\n    Response.Headers.Add(\"Access-Control-Allow-Origin\", \"*\"); // Sensitive\n    Response.Headers.Add(HeaderNames.AccessControlAllowOrigin, \"*\"); // Sensitive\n}\n\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddCors(options =&gt;\n    {\n        options.AddDefaultPolicy(builder =&gt;\n        {\n            builder.WithOrigins(\"*\"); // Sensitive\n        });\n\n        options.AddPolicy(name: \"EnableAllPolicy\", builder =&gt;\n        {\n            builder.WithOrigins(\"*\"); // Sensitive\n        });\n\n        options.AddPolicy(name: \"OtherPolicy\", builder =&gt;\n        {\n            builder.AllowAnyOrigin(); // Sensitive\n        });\n    });\n\n    services.AddControllers();\n}\n\nASP.NET MVC\n\npublic class HomeController : ApiController\n{\n    public HttpResponseMessage Get()\n    {\n        var response = HttpContext.Current.Response;\n\n        response.Headers.Add(\"Access-Control-Allow-Origin\", \"*\"); // Sensitive\n        response.Headers.Add(HeaderNames.AccessControlAllowOrigin, \"*\"); // Sensitive\n        response.AppendHeader(HeaderNames.AccessControlAllowOrigin, \"*\"); // Sensitive\n    }\n}\n\n\n[EnableCors(origins: \"*\", headers: \"*\", methods: \"GET\")] // Sensitive\npublic HttpResponseMessage Get() =&gt; new HttpResponseMessage()\n{\n    Content = new StringContent(\"content\")\n};\n\nCompliant Solution\nASP.NET Core MVC\n\n[HttpGet]\npublic string Get()\n{\n    Response.Headers.Add(\"Access-Control-Allow-Origin\", \"https://trustedwebsite.com\"); // Safe\n    Response.Headers.Add(HeaderNames.AccessControlAllowOrigin, \"https://trustedwebsite.com\"); // Safe\n}\n\n\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddCors(options =&gt;\n    {\n        options.AddDefaultPolicy(builder =&gt;\n        {\n            builder.WithOrigins(\"https://trustedwebsite.com\", \"https://anothertrustedwebsite.com\"); // Safe\n        });\n\n        options.AddPolicy(name: \"EnableAllPolicy\", builder =&gt;\n        {\n            builder.WithOrigins(\"https://trustedwebsite.com\"); // Safe\n        });\n    });\n\n    services.AddControllers();\n}\n\nASP.Net MVC\n\npublic class HomeController : ApiController\n{\n    public HttpResponseMessage Get()\n    {\n        var response = HttpContext.Current.Response;\n\n        response.Headers.Add(\"Access-Control-Allow-Origin\", \"https://trustedwebsite.com\");\n        response.Headers.Add(HeaderNames.AccessControlAllowOrigin, \"https://trustedwebsite.com\");\n        response.AppendHeader(HeaderNames.AccessControlAllowOrigin, \"https://trustedwebsite.com\");\n    }\n}\n\n\n[EnableCors(origins: \"https://trustedwebsite.com\", headers: \"*\", methods: \"GET\")]\npublic HttpResponseMessage Get() =&gt; new HttpResponseMessage()\n{\n    Content = new StringContent(\"content\")\n};\n\nSee\n\n   developer.mozilla.org - CORS \n   developer.mozilla.org - Same origin policy \n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   OWASP HTML5 Security Cheat Sheet - Cross\n  Origin Resource Sharing \n   MITRE, CWE-346 - Origin Validation Error \n   MITRE, CWE-942 - Overly Permissive Cross-domain Whitelist \n   SANS Top 25 - Porous Defenses \n\n\n"
    },
    {
      "Code": "4507",
      "Title": "Delivering code in production with debug features activated is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4507",
      "Description": "Delivering code in production with debug features activated is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2018-1999007 \n   CVE-2015-5306 \n   CVE-2013-2006 \n\nAn application’s debug features enable developers to find bugs more easily and thus facilitate also the work of attackers. It often gives access to\ndetailed information on both the system running the application and users.\nAsk Yourself Whether\n\n   the code or configuration enabling the application debug features is deployed on production servers. \n   the application runs by default with debug features activated. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\nDo not enable debug features on production servers.\nThe .Net Core framework offers multiple features which help during debug.\nMicrosoft.AspNetCore.Builder.IApplicationBuilder.UseDeveloperExceptionPage and\nMicrosoft.AspNetCore.Builder.IApplicationBuilder.UseDatabaseErrorPage are two of them. Make sure that those features are disabled in\nproduction.\nUse if (env.IsDevelopment()) to disable debug code.\nSensitive Code Example\nThis rule raises issues when the following .Net Core methods are called:\nMicrosoft.AspNetCore.Builder.IApplicationBuilder.UseDeveloperExceptionPage,\nMicrosoft.AspNetCore.Builder.IApplicationBuilder.UseDatabaseErrorPage.\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\n\nnamespace mvcApp\n{\n    public class Startup2\n    {\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n        {\n            // Those calls are Sensitive because it seems that they will run in production\n            app.UseDeveloperExceptionPage(); // Sensitive\n            app.UseDatabaseErrorPage(); // Sensitive\n        }\n    }\n}\n\nCompliant Solution\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\n\nnamespace mvcApp\n{\n    public class Startup2\n    {\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                // The following calls are ok because they are disabled in production\n                app.UseDeveloperExceptionPage(); // Compliant\n                app.UseDatabaseErrorPage(); // Compliant\n            }\n        }\n    }\n}\n\nExceptions\nThis rule does not analyze configuration files. Make sure that debug mode is not enabled by default in those files.\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   MITRE, CWE-489 - Leftover Debug Code \n   MITRE, CWE-215 - Information Exposure Through Debug Information \n\n\n"
    },
    {
      "Code": "4036",
      "Title": "Searching OS commands in PATH is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4036",
      "Description": "When executing an OS command and unless you specify the full path to the executable, then the locations in your application’s PATH\nenvironment variable will be searched for the executable. That search could leave an opening for an attacker if one of the elements in\nPATH is a directory under his control.\nAsk Yourself Whether\n\n   The directories in the PATH environment variable may be defined by not trusted entities. \n\nThere is a risk if you answered yes to this question.\nRecommended Secure Coding Practices\nFully qualified/absolute path should be used to specify the OS command to execute.\nSensitive Code Example\n\nProcess p = new Process();\np.StartInfo.FileName = \"binary\"; // Sensitive\n\nCompliant Solution\n\nProcess p = new Process();\np.StartInfo.FileName = @\"C:\\Apps\\binary.exe\"; // Compliant\n\nSee\n\n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-426 - Untrusted Search Path \n   MITRE, CWE-427 - Uncontrolled Search Path Element \n\n\n"
    },
    {
      "Code": "3330",
      "Title": "Creating cookies without the \"HttpOnly\" flag is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3330",
      "Description": "When a cookie is configured with the HttpOnly attribute set to true, the browser guaranties that no client-side script will\nbe able to read it. In most cases, when a cookie is created, the default value of HttpOnly is false and it’s up to the developer\nto decide whether or not the content of the cookie can be read by the client-side script. As a majority of Cross-Site Scripting (XSS) attacks target\nthe theft of session-cookies, the HttpOnly attribute can help to reduce their impact as it won’t be possible to exploit the XSS\nvulnerability to steal session-cookies.\nAsk Yourself Whether\n\n   the cookie is sensitive, used to authenticate the user, for instance a session-cookie \n   the HttpOnly attribute offer an additional protection (not the case for an XSRF-TOKEN cookie / CSRF token for example)\n  \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   By default the HttpOnly flag should be set to true for most of the cookies and it’s mandatory for session /\n  sensitive-security cookies. \n\nSensitive Code Example\nWhen the HttpCookie.HttpOnly property is set to false then the cookie can be accessed by client side code:\n\nHttpCookie myCookie = new HttpCookie(\"Sensitive cookie\");\nmyCookie.HttpOnly = false; // Sensitive: this cookie is created with the httponly flag set to false and so it can be stolen easily in case of XSS vulnerability\n\nThe default value of\nHttpOnly flag is false, unless overwritten by an application’s configuration file:\n\nHttpCookie myCookie = new HttpCookie(\"Sensitive cookie\");\n// Sensitive: this cookie is created without the httponly flag  (by default set to false) and so it can be stolen easily in case of XSS vulnerability\n\nCompliant Solution\nSet the HttpCookie.HttpOnly property to true:\n\nHttpCookie myCookie = new HttpCookie(\"Sensitive cookie\");\nmyCookie.HttpOnly = true; // Compliant: the sensitive cookie is protected against theft thanks to the HttpOnly property set to true (HttpOnly = true)\n\nOr change the default flag values for the whole application by editing the Web.config configuration file:\n\n&lt;httpCookies httpOnlyCookies=\"true\" requireSSL=\"true\" /&gt;\n\n\n   the requireSSL attribute corresponds programmatically to the Secure field. \n   the httpOnlyCookies attribute corresponds programmatically to the httpOnly field. \n\nSee\n\n   OWASP HttpOnly \n   OWASP Top 10 2017 Category A7 - Cross-Site Scripting\n  (XSS) \n   CWE-79 - Improper Neutralization of Input During Web Page Generation ('Cross-site\n  Scripting') \n   CWE-1004 - Sensitive Cookie Without 'HttpOnly' Flag \n   SANS Top 25 - Insecure Interaction Between Components \n   Derived from FindSecBugs rule HTTPONLY_COOKIE \n\n\n"
    },
    {
      "Code": "2092",
      "Title": "Creating cookies without the \"secure\" flag is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2092",
      "Description": "When a cookie is protected with the secure attribute set to true it will not be send by the browser over an unencrypted HTTP\nrequest and thus cannot be observed by an unauthorized person during a man-in-the-middle attack.\nAsk Yourself Whether\n\n   the cookie is for instance a session-cookie not designed to be sent over non-HTTPS communication. \n   it’s not sure that the website contains mixed content or not\n  (ie HTTPS everywhere or not) \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   It is recommended to use HTTPs everywhere so setting the secure flag to true should be the default behaviour\n  when creating cookies. \n   Set the secure flag to true for session-cookies. \n\nSensitive Code Example\nWhen the HttpCookie.Secure property is set to false then the cookie will be send during an unencrypted HTTP request:\n\nHttpCookie myCookie = new HttpCookie(\"Sensitive cookie\");\nmyCookie.Secure = false; //  Sensitive: a security-sensitive cookie is created with the secure flag set to false\n\nThe default value of\nSecure flag is false, unless overwritten by an application’s configuration file:\n\nHttpCookie myCookie = new HttpCookie(\"Sensitive cookie\");\n//  Sensitive: a security-sensitive cookie is created with the secure flag not defined (by default set to false)\n\nCompliant Solution\nSet the HttpCookie.Secure property to true:\n\nHttpCookie myCookie = new HttpCookie(\"Sensitive cookie\");\nmyCookie.Secure = true; // Compliant\n\nOr change the default flag values for the whole application by editing the Web.config configuration file:\n\n&lt;httpCookies httpOnlyCookies=\"true\" requireSSL=\"true\" /&gt;\n\n\n   the requireSSL attribute corresponds programmatically to the Secure field. \n   the httpOnlyCookies attribute corresponds programmatically to the httpOnly field. \n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   MITRE, CWE-311 - Missing Encryption of Sensitive Data \n   MITRE, CWE-315 - Cleartext Storage of Sensitive Information in a Cookie \n   MITRE, CWE-614 - Sensitive Cookie in HTTPS Session Without 'Secure' Attribute \n   SANS Top 25 - Porous Defenses \n\n\n"
    },
    {
      "Code": "818",
      "Title": "Literal suffixes should be upper case",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-818",
      "Description": "Using upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.\nNoncompliant Code Example\n\nconst long b = 0l;      // Noncompliant\n\nCompliant Solution\n\nconst long b = 0L;\n\n\n"
    },
    {
      "Code": "4201",
      "Title": "Null checks should not be used with \"is\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4201",
      "Description": "There’s no need to null test in conjunction with an is test. null is not an instance of anything, so a null check is\nredundant.\nNoncompliant Code Example\n\nif (x != null &amp;&amp; x is MyClass) { ... }  // Noncompliant\n\nif (x == null || !(x is MyClass)) { ... } // Noncompliant\n\nCompliant Solution\n\nif (x is MyClass) { ... }\n\nif (!(x is MyClass)) { ... }\n\n\n"
    },
    {
      "Code": "4136",
      "Title": "Method overloads should be grouped together",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4136",
      "Description": "For clarity, all overloads of the same method should be grouped together. That lets both users and maintainers quickly understand all the current\navailable options.\nNoncompliant Code Example\n\ninterface IMyInterface\n{\n  int DoTheThing(); // Noncompliant - overloaded method declarations are not grouped together\n  string DoTheOtherThing();\n  int DoTheThing(string s);\n}\n\nCompliant Solution\n\ninterface IMyInterface\n{\n  int DoTheThing();\n  int DoTheThing(string s);\n  string DoTheOtherThing();\n}\n\nExceptions\nAs it is common practice to group method declarations by implemented interface, no issue will be raised for implicit and explicit interface\nimplementations if grouped together with other members of that interface.\nAs it is also a common practice to group method declarations by accessibility level, no issue will be raised for method overloads having different\naccess modifiers.\nExample:\n\nclass MyClass\n{\n  private void DoTheThing(string s) // Ok - this method is declared as private while the other one is public\n  {\n    // ...\n  }\n\n  private string DoTheOtherThing(string s)\n  {\n    // ...\n  }\n\n  public void DoTheThing()\n  {\n    // ...\n  }\n}\n\n\n"
    },
    {
      "Code": "4061",
      "Title": "\"params\" should be used instead of \"varargs\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4061",
      "Description": "A method using the VarArgs calling convention is not Common Language Specification (CLS) compliant and might not be accessible across\nprogramming languages, while the params keyword works the same way and is CLS compliant.\nThis rule raises an issue when a public or protected type contains a public or protected method\nthat uses the VarArgs calling convention.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public void Bar(__arglist) // Noncompliant\n        {\n            ArgIterator argumentIterator = new ArgIterator(__arglist);\n            for(int i = 0; i &lt; argumentIterator.GetRemainingCount(); i++)\n            {\n                Console.WriteLine(\n                    __refvalue(argumentIterator.GetNextArg(), string));\n            }\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\n\n[assembly: CLSCompliant(true)]\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public void Bar(params string[] wordList)\n        {\n            for(int i = 0; i &lt; wordList.Length; i++)\n            {\n                Console.WriteLine(wordList[i]);\n            }\n        }\n    }\n}\n\nExceptions\nInterop methods using VarArgs calling convention do not raise an issue.\n\n[DllImport(\"msvcrt40.dll\")]\npublic static extern int printf(string format, __arglist); // Compliant\n\n\n"
    },
    {
      "Code": "3963",
      "Title": "\"static\" fields should be initialized inline",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3963",
      "Description": "When a static constructor serves no other purpose that initializing static fields, it comes with an unnecessary\nperformance cost because the compiler generates a check before each static method or instance constructor invocation.\nInstead, inline initialization is highly recommended.\nNoncompliant Code Example\n\nnamespace myLib\n{\n  public class Foo\n  {\n    static int i;\n    static string s;\n\n    static Foo() // Noncompliant\n    {\n      i = 3;\n      ResourceManager sm =  new ResourceManager(\"strings\", Assembly.GetExecutingAssembly());\n      s = sm.GetString(\"mystring\");\n    }\n  }\n}\n\nCompliant Solution\n\nnamespace myLib\n{\n  public class Foo\n  {\n    static int i =3;\n    static string s = InitString();\n\n    static string InitString()\n    {\n      ResourceManager sm = new ResourceManager(\"strings\", Assembly.GetExecutingAssembly());\n      return sm.GetString(\"mystring\");\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "3897",
      "Title": "Classes that provide \"Equals()\" should implement \"IEquatable\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3897",
      "Description": "The IEquatable&lt;T&gt; interface has only one method in it: Equals(&lt;T&gt;). If you’ve already written\nEquals(T), there’s no reason not to explicitly implement IEquatable&lt;T&gt;. Doing so expands the utility of your class by\nallowing it to be used where an IEquatable is called for.\nNote: Classes that implement IEquatable&lt;T&gt; should also be sealed.\nNoncompliant Code Example\n\nclass MyClass  // Noncompliant\n{\n  public bool Equals(MyClass other)\n  {\n    //...\n  }\n}\n\nCompliant Solution\n\nsealed class MyClass : IEquatable&lt;MyClass&gt;\n{\n  public override bool Equals(object other)\n  {\n    return Equals(other as MyClass);\n  }\n\n  public bool Equals(MyClass other)\n  {\n    //...\n  }\n}\n\n\n"
    },
    {
      "Code": "3626",
      "Title": "Jump statements should not be redundant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3626",
      "Description": "Jump statements, such as return, yield break, goto, and continue let you change the default\nflow of program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.\nNoncompliant Code Example\n\nvoid Foo()\n{\n  goto A; // Noncompliant\n  A:\n  while (condition1)\n  {\n    if (condition2)\n    {\n      continue; // Noncompliant\n    }\n    else\n    {\n      DoTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n\nCompliant Solution\n\nvoid Foo()\n{\n  while (condition1)\n  {\n    if (!condition2)\n    {\n      DoTheThing();\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "3604",
      "Title": "Member initializer values should not be redundant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3604",
      "Description": "Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the same\ntime is redundant; the inline initialization will be overridden.\nNoncompliant Code Example\n\nclass Person\n{\n  int age = 42; // Noncompliant\n  public Person(int age)\n  {\n    this.age = age;\n  }\n}\n\nCompliant Solution\n\nclass Person\n{\n  int age;\n  public Person(int age)\n  {\n    this.age = age;\n  }\n}\n\nExceptions\nThis rule doesn’t report an issue if not all constructors initialize the field. If the field is initialized inline to its default value, then\n{rule:csharpsquid:S3052} already reports an issue on the initialization.\n\n"
    },
    {
      "Code": "3459",
      "Title": "Unassigned members should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3459",
      "Description": "Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely,\nmistakes.\nNoncompliant Code Example\n\nclass MyClass\n{\n  private int field; // Noncompliant, shouldn't it be initialized? This way the value is always default(int), 0.\n  private int Property { get; set; }  // Noncompliant\n  public void Print()\n  {\n    Console.WriteLine(field); //Will always print 0\n    Console.WriteLine(Property); //Will always print 0\n  }\n}\n\nCompliant Solution\n\nclass MyClass\n{\n  private int field = 1;\n  private int Property { get; set; } = 42;\n  public void Print()\n  {\n    field++;\n    Console.WriteLine(field);\n    Console.WriteLine(Property);\n  }\n}\n\n\n"
    },
    {
      "Code": "3458",
      "Title": "Empty \"case\" clauses that fall through to the \"default\" should be omitted",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3458",
      "Description": "Empty case clauses that fall through to the default are useless. Whether or not such a case is present, the\ndefault clause will be invoked. Such cases simply clutter the code, and should be removed.\nNoncompliant Code Example\n\nswitch(ch)\n{\n  case 'a' :\n    HandleA();\n    break;\n  case 'b' :\n    HandleB();\n    break;\n  case 'c' :  // Noncompliant\n  default:\n    HandleTheRest();\n    break;\n}\n\nCompliant Solution\n\nswitch(ch)\n{\n  case 'a' :\n    HandleA();\n    break;\n  case 'b' :\n    HandleB();\n    break;\n  default:\n    HandleTheRest();\n    break;\n}\n\n\n"
    },
    {
      "Code": "3450",
      "Title": "Parameters with \"[DefaultParameterValue]\" attributes should also be marked \"[Optional]\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3450",
      "Description": "There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus,\n[DefaultParameterValue] should always be used in conjunction with [Optional].\nNoncompliant Code Example\n\npublic void MyMethod([DefaultParameterValue(5)] int j) //Noncompliant, useless\n{\n  Console.WriteLine(j);\n}\n\nCompliant Solution\n\npublic void MyMethod(int j = 5)\n{\n  Console.WriteLine(j);\n}\n\nor\n\npublic void MyMethod([DefaultParameterValue(5)][Optional] int j)\n{\n  Console.WriteLine(j);\n}\n\n\n"
    },
    {
      "Code": "3444",
      "Title": "Interfaces should not simply inherit from base interfaces with colliding members",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3444",
      "Description": "When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived\ninterface will result in the compiler error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'.\nSo instead, every caller will be forced to cast instances of the derived interface to one or the other of its base interfaces to resolve the\nambiguity and be able to access the member. Instead, it is better to resolve the ambiguity in the definition of the derived interface either by:\n\n   renaming the member in one of the base interfaces to remove the collision \n   also defining that member in the derived interface. Use this only if all copies of the member are meant to hold the same value. \n\nNoncompliant Code Example\n\npublic interface IBase1\n{\n  string SomeProperty { get; set; }\n}\n\npublic interface IBase2\n{\n  string SomeProperty { get; set; }\n}\n\npublic interface IDerived : IBase1, IBase2 // Noncompliant, accessing IDerived.SomeProperty is ambiguous\n{\n}\n\npublic class MyClass : IDerived\n{\n  // Implements both IBase1.SomeProperty and IBase2.SomeProperty\n  public string SomeProperty { get; set; } = \"Hello\";\n\n  public static void Main()\n  {\n    MyClass myClass = new MyClass();\n    Console.WriteLine(myClass.SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IDerived)myClass).SomeProperty); // Error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'\n  }\n}\n\nCompliant Solution\n\npublic interface IDerived : IBase1, IBase2\n{\n  new string SomeProperty { get; set; }\n}\n\npublic class MyClass : IDerived\n{\n  // Implements IBase1.SomeProperty, IBase2.SomeProperty and IDerived.SomeProperty\n  public string SomeProperty { get; set; } = \"Hello\";\n\n  public static void Main()\n  {\n    MyClass myClass = new MyClass();\n    Console.WriteLine(myClass.SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes \"Hello\" as expected\n    Console.WriteLine(((IDerived)myClass).SomeProperty); // Writes \"Hello\" as expected\n  }\n}\n\nor\n\npublic interface IBase1\n{\n  string SomePropertyOne { get; set; }\n}\n\npublic interface IBase2\n{\n  string SomePropertyTwo { get; set; }\n}\n\npublic interface IDerived : IBase1, IBase2\n{\n}\n\n\n"
    },
    {
      "Code": "3440",
      "Title": "Variables should not be checked against the values they're about to be assigned",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3440",
      "Description": "There’s no point in checking a variable against the value you’re about to assign it. Save the cycles and lines of code, and simply perform the\nassignment.\nNoncompliant Code Example\n\nif (x != a)  // Noncompliant; why bother?\n{\n    x = a;\n}\n\nCompliant Solution\n\nx = a;\n\nExceptions\nProperties and checks inside setters are excluded from this rule because they could have side effects and removing the check could lead to\nundesired side effects.\n\nif (MyProperty != a)\n{\n    MyProperty = a; // Compliant because the setter could be expensive call\n}\n\n\nprivate int myField;\npublic int SomeProperty\n{\n    get\n    {\n        return myField;\n    }\n    set\n    {\n        if (myField != value)\n        {\n            myField = value;\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "3400",
      "Title": "Methods should not return constants",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3400",
      "Description": "There’s no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a\nmethod call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead.\nThis rule raises an issue if on methods that contain only one statement: the return of a constant value.\nNoncompliant Code Example\n\nint GetBestNumber()\n{\n  return 12;  // Noncompliant\n}\n\nCompliant Solution\n\nconst int BestNumber = 12;\n\nor\n\nstatic readonly int BestNumber = 12;\n\n\n"
    },
    {
      "Code": "3376",
      "Title": "Attribute, EventArgs, and Exception type names should end with the type being extended",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3376",
      "Description": "Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance, class FirstAttribute :\nAttribute can be used simply with First, but you must use the full name for class AttributeOne : Attribute.\nThis rule raises an issue when classes extending Attribute, EventArgs, or Exception, do not end with their\nparent class names.\nNoncompliant Code Example\n\nclass AttributeOne : Attribute  // Noncompliant\n{\n}\n\nCompliant Solution\n\nclass FirstAttribute : Attribute\n{\n}\n\nExceptions\nIf a class' direct base class doesn’t follow the convention, then no issue is reported on the class itself, regardless of whether or not it\nconforms to the convention.\n\nclass Timeout : Exception // Noncompliant\n{\n}\nclass ExtendedTimeout : Timeout // Ignored; doesn't conform to convention, but the direct base doesn't conform either\n{\n}\n\n\n"
    },
    {
      "Code": "3261",
      "Title": "Namespaces should not be empty",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3261",
      "Description": "Namespaces with no lines of code clutter a project and should be removed.\nNoncompliant Code Example\n\nnamespace MyEmptyNamespace // Noncompliant\n{\n\n}\n\n\n"
    },
    {
      "Code": "3260",
      "Title": "Non-derived \"private\" classes and records should be \"sealed\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3260",
      "Description": "private classes and records aren’t visible outside of their assemblies anyway, so if they’re not extended inside the assemblies, they\nshould be made explicitly non-extensible with the addition of the sealed keyword.\nNoncompliant Code Example\n\nprivate class MyClass  // Noncompliant\n{\n  // ...\n}\n\nprivate record MyRecord  // Noncompliant\n{\n  // ...\n}\n\nCompliant Solution\n\nprivate sealed class MyClass\n{\n  // ...\n}\n\nprivate sealed record MyRecord\n{\n  // ...\n}\n\n\n"
    },
    {
      "Code": "3256",
      "Title": "\"string.IsNullOrEmpty\" should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3256",
      "Description": "Using string.Equals to determine if a string is empty is significantly slower than using string.IsNullOrEmpty() or\nchecking for string.Length == 0. string.IsNullOrEmpty() is both clear and concise, and therefore preferred to laborious,\nerror-prone, manual null- and emptiness-checking.\nNoncompliant Code Example\n\n\"\".Equals(name); // Noncompliant\n!name.Equals(\"\"); // Noncompliant\nname.Equals(string.Empty); // Noncompliant\n\nCompliant Solution\n\nname != null &amp;&amp; name.Length &gt; 0 // Compliant but more error prone\n!string.IsNullOrEmpty(name)\nstring.IsNullOrEmpty(name)\n\n\n"
    },
    {
      "Code": "3251",
      "Title": "Implementations should be provided for \"partial\" methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3251",
      "Description": "partial methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code by invoking\nmethods that define their signature, but might not have an implementation yet. But if the implementation is still missing when the code makes it to\nproduction, the compiler silently removes the call. In the best case scenario, such calls simply represent cruft, but in they worst case they are\ncritical, missing functionality, the loss of which will lead to unexpected results at runtime.\nThis rule raises an issue for partial methods for which no implementation can be found in the assembly.\nNoncompliant Code Example\n\npartial class C\n{\n  partial void M(); //Noncompliant\n\n  void OtherM()\n  {\n    M(); //Noncompliant. Will be removed.\n  }\n}\n\n\n"
    },
    {
      "Code": "3247",
      "Title": "Duplicate casts should not be made",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3247",
      "Description": "Because the is operator performs a cast if the object is not null, using is to check type and then casting the same\nargument to that type, necessarily performs two casts. The same result can be achieved more efficiently with a single cast using as,\nfollowed by a null-check.\nNoncompliant Code Example\n\nif (x is Fruit)  // Noncompliant\n{\n  var f = (Fruit)x; // or x as Fruit\n  // ...\n}\n\nCompliant Solution\n\n// C# 6\nvar f = x as Fruit;\nif (f != null)\n{\n  // ...\n}\n// C# 7\nif (x is Fruit fruit)\n{\n  // ...\n}\n\n\n"
    },
    {
      "Code": "3241",
      "Title": "Methods should not return values that are never used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3241",
      "Description": "Private methods are clearly intended for use only within their own scope. When such methods return values that are never used by any of their\ncallers, then clearly there is no need to actually make the return, and it should be removed in the interests of efficiency and clarity.\n\n"
    },
    {
      "Code": "3236",
      "Title": "Caller information arguments should not be provided explicitly",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3236",
      "Description": "Caller information attributes: CallerFilePathAttribute and CallerLineNumberAttribute provide a way to get information\nabout the caller of a method through optional parameters. But the arguments for these optional parameters are only generated if they are not\nexplicitly defined in the call. Thus, specifying the argument values defeats the purpose of the attributes.\nNoncompliant Code Example\n\nvoid TraceMessage(string message,\n  [CallerFilePath] string filePath = null,\n  [CallerLineNumber] int lineNumber = 0)\n{\n  /* ... */\n}\n\nvoid MyMethod()\n{\n  TraceMessage(\"my message\", \"A.B.C.Foo.cs\", 42); // Noncompliant\n}\n\nCompliant Solution\n\nvoid TraceMessage(string message,\n  [CallerFilePath] string filePath = \"\",\n  [CallerLineNumber] int lineNumber = 0)\n{\n  /* ... */\n}\n\nvoid MyMethod()\n{\n  TraceMessage(\"my message\");\n}\n\nExceptions\nCallerMemberName is not checked to avoid False-Positives with WPF/UWP applications.\n\n"
    },
    {
      "Code": "3220",
      "Title": "Method calls should not resolve ambiguously to overloads with \"params\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3220",
      "Description": "The rules for method resolution are complex and perhaps not properly understood by all coders. The params keyword can make method\ndeclarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different methods.\nThis rule raises an issue when an invocation resolves to a method declaration with params, but could also resolve to another\nnon-params method too.\nNoncompliant Code Example\n\npublic class MyClass\n{\n    private void Format(string a, params object[] b) { }\n\n    private void Format(object a, object b, object c) { }\n}\n\n// ...\nMyClass myClass = new MyClass();\n\nmyClass.Format(\"\", null, null); // Noncompliant, resolves to the first Format with params, but was that intended?\n\n\n"
    },
    {
      "Code": "2737",
      "Title": "\"catch\" clauses should do more than rethrow",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2737",
      "Description": "A catch clause that only rethrows the caught exception has the same effect as omitting the catch altogether and letting\nit bubble up automatically, but with more code and the additional detriment of leaving maintainers scratching their heads.\nSuch clauses should either be eliminated or populated with the appropriate logic.\nNoncompliant Code Example\n\nstring s = \"\";\ntry\n{\n  s = File.ReadAllText(fileName);\n}\ncatch (Exception e)  // Noncompliant\n{\n  throw;\n}\n\nCompliant Solution\n\nstring s = \"\";\ntry\n{\n  s = File.ReadAllText(fileName);\n}\ncatch (Exception e) // Compliant\n{\n  logger.LogError(e);\n  throw;\n}\n\nor\n\nstring s = File.ReadAllText(fileName);\n\nExceptions\nThis rule will not generate issues for catch blocks with just throw inside if they are followed by a catch\nblock for a more general exception type that does more than just rethrowing the exception.\n\nvar s = \"\"\ntry\n{\n    s = File.ReadAllText(fileName);\n}\ncatch (IOException) // Compliant, if removed will change the logic\n{\n    throw;\n}\ncatch (Exception)  // Compliant, does more than just rethrow\n{\n    logger.LogError(e);\n    throw;\n}\n\n\n"
    },
    {
      "Code": "2486",
      "Title": "Generic exceptions should not be ignored",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2486",
      "Description": "When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.\nThis rule only reports on empty catch clauses that catch generic Exceptions.\nNoncompliant Code Example\n\nstring text = \"\";\ntry\n{\n    text = File.ReadAllText(fileName);\n}\ncatch (Exception exc) // Noncompliant\n{\n}\n\nCompliant Solution\n\nstring text = \"\";\ntry\n{\n    text = File.ReadAllText(fileName);\n}\ncatch (Exception exc)\n{\n    logger.Log(exc);\n}\n\nExceptions\nWhen a block contains a comment, it is not considered to be empty.\nSee\n\n   OWASP Top 10 2017 Category A10 -\n  Insufficient Logging &amp; Monitoring \n   MITRE, CWE-391 - Unchecked Error Condition \n\n\n"
    },
    {
      "Code": "2386",
      "Title": "Mutable fields should not be \"public static\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2386",
      "Description": "public static mutable fields of classes which are accessed directly should be protected to the degree possible. This can be done by\nreducing the accessibility of the field or by changing the return type to an immutable type.\nThis rule raises issues for public static fields with a type inheriting/implementing System.Array or\nSystem.Collections.Generic.ICollection&lt;T&gt;.\nNoncompliant Code Example\n\npublic class A\n{\n  public static string[] strings1 = {\"first\",\"second\"};  // Noncompliant\n  public static List&lt;String&gt; strings3 = new List&lt;String&gt;();  // Noncompliant\n  // ...\n}\n\nCompliant Solution\n\npublic class A\n{\n  protected static string[] strings1 = {\"first\",\"second\"};\n  protected static List&lt;String&gt; strings3 = new List&lt;String&gt;();\n  // ...\n}\n\nExceptions\nNo issue is reported:\n\n   If the type of the field inherits/implements one (at least) of the following types:\n    \n       System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; \n       System.Collections.ObjectModel.ReadOnlyDictionary&lt;TKey, TValue&gt; \n       System.Collections.Immutable.IImmutableArray&lt;T&gt; \n       System.Collections.Immutable.IImmutableDictionary&lt;TKey, TValue&gt; \n       System.Collections.Immutable.IImmutableList&lt;T&gt; \n       System.Collections.Immutable.IImmutableSet&lt;T&gt; \n       System.Collections.Immutable.IImmutableStack&lt;T&gt; \n       System.Collections.Immutable.IImmutableQueue&lt;T&gt; \n      \n   If the field is readonly and is initialized inline with an immutable type (i.e. inherits/implements one of the types in the\n  previous list) or null. \n\nSee\n\n   MITRE, CWE-582 - Array Declared Public, Final, and Static \n   MITRE, CWE-607 - Public Static Final Field References Mutable Object \n\n\n"
    },
    {
      "Code": "2344",
      "Title": "Enumeration type names should not have \"Flags\" or \"Enum\" suffixes",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2344",
      "Description": "The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name.\nNoncompliant Code Example\n\nenum FooFlags // Noncompliant\n{\n    Foo = 1\n    Bar = 2\n    Baz = 4\n}\n\nCompliant Solution\n\nenum Foo\n{\n    Foo = 1\n    Bar = 2\n    Baz = 4\n}\n\n\n"
    },
    {
      "Code": "2342",
      "Title": "Enumeration types should comply with a naming convention",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2342",
      "Description": "Shared naming conventions allow teams to collaborate efficiently. This rule checks that all enum names match a provided regular\nexpression.\nThe default configuration is the one recommended by Microsoft:\n\n   Pascal casing, starting with an upper case character, e.g. BackColor \n   Short abbreviations of 2 letters can be capitalized, e.g. GetID \n   Longer abbreviations need to be lower case, e.g. GetHtml \n   If the enum is marked as [Flags] then its name should be plural (e.g. MyOptions), otherwise, names should be singular (e.g. MyOption) \n\nNoncompliant Code Example\nWith the default regular expression for non-flags enums: ^([A-Z]{1,3}[a-z0-9]+)*([A-Z]{2})?$\n\npublic enum foo // Noncompliant\n{\n    FooValue = 0\n}\n\nWith the default regular expression for flags enums: ^([A-Z]{1,3}[a-z0-9]+)*([A-Z]{2})?s$\n\n[Flags]\npublic enum Option // Noncompliant\n{\n    None = 0,\n    Option1 = 1,\n    Option2 = 2\n}\n\nCompliant Solution\n\npublic enum Foo\n{\n    FooValue = 0\n}\n\n\n[Flags]\npublic enum Options\n{\n    None = 0,\n    Option1 = 1,\n    Option2 = 2\n}\n\n\n"
    },
    {
      "Code": "2292",
      "Title": "Trivial properties should be auto-implemented",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2292",
      "Description": "Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented properties, yielding\ncleaner and more readable code.\nNoncompliant Code Example\n\npublic class Car\n{\n  private string _make;\n  public string Make // Noncompliant\n  {\n    get { return _make; }\n    set { _make = value; }\n  }\n}\n\nCompliant Solution\n\npublic class Car\n{\n  public string Make { get; set; }\n}\n\n\n"
    },
    {
      "Code": "2219",
      "Title": "Runtime type checking should be simplified",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2219",
      "Description": "To check the type of an object there are several options:\n\n   expr is SomeType or expr.GetType() == typeof(SomeType) if the type is known at compile time, \n   typeInstance.IsInstanceOfType(expr) if the type is calculated during runtime. \n\nIf runtime calculated Types need to be compared:\n\n   typeInstance1.IsAssignableFrom(typeInstance2). \n\nDepending on whether the type is returned by a GetType() or typeof() call, the IsAssignableFrom() and\nIsInstanceOfType() might be simplified. Similarly, if the type is sealed, the type comparison with == can be\nconverted to an is call. Simplifying the calls also make null checking unnecessary because both is and\nIsInstanceOfType performs it already.\nFinally, utilizing the most concise language constructs for type checking makes the code more readable, so\n\n   expr as T != null checks should be simplified to expr is T, and \n   expr is T should be converted to expr != null, when expr is of type T. \n\nNoncompliant Code Example\n\nclass Fruit { }\nsealed class Apple : Fruit { }\n\nclass Program\n{\n  static void Main()\n  {\n    var apple = new Apple();\n    var b = apple != null &amp;&amp; apple.GetType() == typeof (Apple); // Noncompliant\n    b = typeof(Apple).IsInstanceOfType(apple); // Noncompliant\n    if (apple != null)\n    {\n      b = typeof(Apple).IsAssignableFrom(apple.GetType()); // Noncompliant\n    }\n    var appleType = typeof (Apple);\n    if (apple != null)\n    {\n      b = appleType.IsAssignableFrom(apple.GetType()); // Noncompliant\n    }\n\n    Fruit f = apple;\n    if (f as Apple != null) // Noncompliant\n    {\n    }\n    if (apple is Apple) // Noncompliant\n    {\n    }\n  }\n}\n\nCompliant Solution\n\nclass Fruit { }\nsealed class Apple : Fruit { }\n\nclass Program\n{\n  static void Main()\n  {\n    var apple = new Apple();\n    var b = apple is Apple;\n    b = apple is Apple;\n    b = apple is Apple;\n    var appleType = typeof(Apple);\n    b = appleType.IsInstanceOfType(apple);\n\n    Fruit f = apple;\n    if (f is Apple)\n    {\n    }\n    if (apple != null)\n    {\n    }\n  }\n}\n\nExceptions\nCalling GetType on an object of Nullable&lt;T&gt; type returns the underlying generic type parameter T, thus\na comparison with typeof(Nullable&lt;T&gt;) can’t be simplified to use the is operator, which doesn’t make difference\nbetween T and T?.\n\nint? i = 42;\nbool condition = i.GetType() == typeof(int?); // false;\ncondition = i is int?; // true\n\nNo issue is reported on the following expressions:\n\n   expr is T&nbsp;when either operand of the is operator is a value type. In that case CS0183 or CS0184 reports \n   expr is object, as this is a common and efficient pattern to do null checks \n\n\n"
    },
    {
      "Code": "1940",
      "Title": "Boolean checks should not be inverted",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1940",
      "Description": "It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.\nNoncompliant Code Example\n\nif ( !(a == 2)) { ...}  // Noncompliant\nbool b = !(i &lt; 10);  // Noncompliant\n\nCompliant Solution\n\nif (a != 2) { ...}\nbool b = (i &gt;= 10);\n\n\n"
    },
    {
      "Code": "1939",
      "Title": "Inheritance list should not be redundant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1939",
      "Description": "An inheritance list entry is redundant if:\n\n   It is Object - all classes extend Object implicitly. \n   It is int for an enum \n   It is a base class of another listed inheritance. \n\nSuch redundant declarations should be removed because they needlessly clutter the code and can be confusing.\nNoncompliant Code Example\n\npublic class MyClass : Object  // Noncompliant\n\nenum MyEnum : int  // Noncompliant\n\nCompliant Solution\n\npublic class MyClass\n\nenum MyEnum\n\n\n"
    },
    {
      "Code": "1905",
      "Title": "Redundant casts should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1905",
      "Description": "Unnecessary casting expressions make the code harder to read and understand.\nNoncompliant Code Example\n\npublic int Example(int i)\n{\n    return (int) (i + 42); // Noncompliant\n}\n\npublic IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll)\n{\n    return coll.Reverse().OfType&lt;int&gt;(); // Noncompliant\n}\n\nCompliant Solution\n\npublic int Example(int i)\n{\n    return i + 42;\n}\n\npublic IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll)\n{\n    return coll.Reverse();\n}\n\nExceptions\nIssues are not raised against C# 7.1 default literal.\n\nbool b = (bool)default; // Doesn't raise an issue\n\n\n"
    },
    {
      "Code": "1643",
      "Title": "Strings should not be concatenated using '+' in a loop",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1643",
      "Description": "StringBuilder is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.\nNoncompliant Code Example\n\nstring str = \"\";\nfor (int i = 0; i &lt; arrayOfStrings.Length ; ++i)\n{\n  str = str + arrayOfStrings[i];\n}\n\nCompliant Solution\n\nStringBuilder bld = new StringBuilder();\nfor (int i = 0; i &lt; arrayOfStrings.Length; ++i)\n{\n  bld.Append(arrayOfStrings[i]);\n}\nstring str = bld.ToString();\n\n\n"
    },
    {
      "Code": "1481",
      "Title": "Unused local variables should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1481",
      "Description": "If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will\nnot wonder what the variable is used for.\nNoncompliant Code Example\n\npublic int NumberOfMinutes(int hours)\n{\n  int seconds = 0;   // seconds is never used\n  return hours * 60;\n}\n\nCompliant Solution\n\npublic int NumberOfMinutes(int hours)\n{\n  return hours * 60;\n}\n\nExceptions\nUnused locally created resources in a using statement are not reported.\n\nusing(var t = new TestTimer()) // t never used, but compliant.\n{\n  //...\n}\n\n\n"
    },
    {
      "Code": "1450",
      "Title": "Private fields only used as local variables in methods should become local variables",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1450",
      "Description": "When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class\ninformation. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.\nNoncompliant Code Example\n\npublic class Foo\n{\n  private int singularField;\n\n  public void DoSomething(int x)\n  {\n    singularField = x + 5;\n\n    if (singularField == 0) { /* ... */ }\n  }\n}\n\nCompliant Solution\n\npublic class Foo\n{\n  public void DoSomething(int x)\n  {\n    int localVariable = x + 5;\n\n    if (localVariable == 0) { /* ... */ }\n  }\n}\n\n\n"
    },
    {
      "Code": "1264",
      "Title": "A \"while\" loop should be used instead of a \"for\" loop",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1264",
      "Description": "When only the condition expression is defined in a for loop, and the initialization and increment expressions are missing, a\nwhile loop should be used instead to increase readability.\nNoncompliant Code Example\n\nfor (;condition;) { /*...*/ }\n\nCompliant Solution\n\nwhile (condition) { /*...*/ }\n\n\n"
    },
    {
      "Code": "1210",
      "Title": "\"Equals\" and the comparison operators should be overridden when implementing \"IComparable\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1210",
      "Description": "When you implement IComparable or IComparable&lt;T&gt; on a class you should also override Equals(object)\nand overload the comparison operators (==, !=, &lt;, &lt;=, &gt;,\n&gt;=). That’s because the CLR cannot automatically call your CompareTo implementation from Equals(object) or\nfrom the base comparison operator implementations. Additionally, it is best practice to override GetHashCode along with\nEquals.\nThis rule raises an issue when a class implements IComparable without also overriding Equals(object) and the comparison\noperators.\nNoncompliant Code Example\n\npublic class Foo: IComparable  // Noncompliant\n{\n  public int CompareTo(object obj) { /* ... */ }\n}\n\nCompliant Solution\n\npublic class Foo: IComparable\n{\n  public int CompareTo(object obj) { /* ... */ }\n  public override bool Equals(object obj)\n  {\n    var other = obj as Foo;\n    if (object.ReferenceEquals(other, null))\n    {\n      return false;\n    }\n    return this.CompareTo(other) == 0;\n  }\n  public int GetHashCode() { /* ... */ }\n  public static bool operator == (Foo left, Foo right)\n  {\n    if (object.ReferenceEquals(left, null))\n    {\n      return object.ReferenceEquals(right, null);\n    }\n    return left.Equals(right);\n  }\n  public static bool operator &gt; (Foo left, Foo right)\n  {\n    return Compare(left, right) &gt; 0;\n  }\n  public static bool operator &lt; (Foo left, Foo right)\n  {\n    return Compare(left, right) &lt; 0;\n  }\n  public static bool operator != (Foo left, Foo right)\n  {\n    return !(left == right);\n  }\n}\n\n\n"
    },
    {
      "Code": "1199",
      "Title": "Nested code blocks should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1199",
      "Description": "Nested code blocks can be used to create a new scope and restrict the visibility of the variables defined inside it. Using this feature in a method\ntypically indicates that the method has too many responsibilities, and should be refactored into smaller methods.\nNoncompliant Code Example\n\npublic void Evaluate()\n{\n    /* ... */\n    {     // Noncompliant - nested code block '{' ... '}'\n          int a = stack.pop();\n          int b = stack.pop();\n          int result = a + b;\n          stack.push(result);\n    }\n    /* ... */\n}\n\nCompliant Solution\n\npublic void Evaluate()\n{\n    /* ... */\n    StackAdd();\n    /* ... */\n}\n\nprivate void StackAdd()\n{\n      int a = stack.pop();\n      int b = stack.pop();\n      int result = a + b;\n      stack.push(result);\n}\n\nExceptions\nThe usage of a code block after a \"case\" is allowed for this rule.\n\n"
    },
    {
      "Code": "1185",
      "Title": "Overriding members should do more than simply call the same member in the base class",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1185",
      "Description": "Overriding a method just to call the same method from the base class without performing any other actions is useless and misleading. The only time\nthis is justified is in sealed overriding methods, where the effect is to lock in the parent class behavior. This rule ignores overrides\nof Equals and GetHashCode.\nNOTE: In some cases it might be dangerous to add or remove empty overrides, as they might be breaking changes.\nNoncompliant Code Example\n\npublic override void Method() // Noncompliant\n{\n  base.Method();\n}\n\nCompliant Solution\n\npublic override void Method()\n{\n  //do something else\n}\n\nExceptions\nIf there is an attribute in any level of the overriding chain, then the overridden member is ignored.\n\npublic class Base\n{\n  [Required]\n  public virtual string Name { get; set; }\n}\n\npublic class Derived : Base\n{\n  public override string Name\n  {\n    get\n    {\n      return base.Name;\n    }\n    set\n    {\n      base.Name = value;\n    }\n  }\n}\n\nIf there is a documentation comment on the overriding method, it will be ignored:\n\npublic class Foo : Bar\n{\n    /// &lt;summary&gt;\n    /// Keep this method for backwards compatibility.\n    /// &lt;/summary&gt;\n    public override void DoSomething()\n    {\n        base.DoSomething();\n    }\n}\n\n\n"
    },
    {
      "Code": "1155",
      "Title": "\"Any()\" should be used to test for emptiness",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1155",
      "Description": "Using .Count() to test for emptiness works, but using .Any() makes the intent clearer, and the code more readable.\nHowever, there are some cases where special attention should be paid:\n\n   if the collection is an EntityFramework or other ORM query, calling .Count() will cause executing a potentially\n  massive SQL query and could put a large overhead on the application database. Calling .Any() will also connect to the database, but\n  will generate much more efficient SQL. \n   if the collection is part of a LINQ query that contains .Select() statements that create objects, a large amount of memory could\n  be unnecessarily allocated. Calling .Any() will be much more efficient because it will execute fewer iterations of the enumerable.\n  \n\nNoncompliant Code Example\n\nprivate static bool HasContent(IEnumerable&lt;string&gt; strings)\n{\n  return strings.Count() &gt; 0;  // Noncompliant\n}\n\nprivate static bool HasContent2(IEnumerable&lt;string&gt; strings)\n{\n  return strings.Count() &gt;= 1;  // Noncompliant\n}\n\nprivate static bool IsEmpty(IEnumerable&lt;string&gt; strings)\n{\n  return strings.Count() == 0;  // Noncompliant\n}\n\nCompliant Solution\n\nprivate static bool HasContent(IEnumerable&lt;string&gt; strings)\n{\n  return strings.Any();\n}\n\nprivate static bool IsEmpty(IEnumerable&lt;string&gt; strings)\n{\n  return !strings.Any();\n}\n\n\n"
    },
    {
      "Code": "1125",
      "Title": "Boolean literals should not be redundant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1125",
      "Description": "Redundant Boolean literals should be removed from expressions to improve readability.\nNoncompliant Code Example\n\nif (booleanMethod() == true) { /* ... */ }\nif (booleanMethod() == false) { /* ... */ }\nif (booleanMethod() || false) { /* ... */ }\ndoSomething(!false);\ndoSomething(booleanMethod() == true);\n\nbooleanVariable = booleanMethod() ? true : false;\nbooleanVariable = booleanMethod() ? true : exp;\nbooleanVariable = booleanMethod() ? false : exp;\nbooleanVariable = booleanMethod() ? exp : true;\nbooleanVariable = booleanMethod() ? exp : false;\n\nfor (var x = 0; true; x++)\n{\n ...\n}\n\nCompliant Solution\n\nif (booleanMethod()) { /* ... */ }\nif (!booleanMethod()) { /* ... */ }\nif (booleanMethod()) { /* ... */ }\ndoSomething(true);\ndoSomething(booleanMethod());\n\nbooleanVariable = booleanMethod();\nbooleanVariable = booleanMethod() || exp;\nbooleanVariable = !booleanMethod() &amp;&amp; exp;\nbooleanVariable = !booleanMethod() || exp;\nbooleanVariable = booleanMethod() &amp;&amp; exp;\n\nfor (var x = 0; ; x++)\n{\n ...\n}\n\n\n"
    },
    {
      "Code": "1116",
      "Title": "Empty statements should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1116",
      "Description": "Empty statements, i.e. ;, are usually introduced by mistake, for example because:\n\n   It was meant to be replaced by an actual statement, but this was forgotten. \n   There was a typo which lead the semicolon to be doubled, i.e. ;;. \n\nNoncompliant Code Example\n\nvoid DoSomething()\n{\n    ; // Noncompliant - was used as a kind of TODO marker\n}\n\nvoid DoSomethingElse()\n{\n    Console.WriteLine(\"Hello, world!\");;  // Noncompliant - double ;\n    // ...\n    // Rarely, they are used on purpose as the body of a loop. It is a bad practice to\n    // have side-effects outside of the loop:\n    for (int i = 0; i &lt; 3; Console.WriteLine(i), i++); // Noncompliant\n    // ...\n}\n\nCompliant Solution\n\nvoid DoSomething()\n{\n}\n\nvoid DoSomethingElse()\n{\n    Console.WriteLine(\"Hello, world!\");\n    // ...\n    for (int i = 0; i &lt; 3; i++)\n    {\n        Console.WriteLine(i);\n     }\n    // ...\n}\n\n\n"
    },
    {
      "Code": "1104",
      "Title": "Fields should not have public accessibility",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1104",
      "Description": "Public fields in public classes do not respect the encapsulation principle and has three main disadvantages:\n\n   Additional behavior such as validation cannot be added. \n   The internal representation is exposed, and cannot be changed afterwards. \n   Member values are subject to change from anywhere in the code and may not meet the programmer’s assumptions. \n\nBy using private fields and public properties (set and get), unauthorized modifications are prevented. Properties also benefit from additional\nprotection (security) features such as Link Demands.\nNote that due to optimizations on simple properties, public fields provide only very little performance gain.\nNoncompliant Code Example\n\npublic class Foo\n{\n    public int instanceData = 32; // Noncompliant\n}\n\nCompliant Solution\n\npublic class Foo\n{\n    private int instanceData = 32;\n\n    public int InstanceData\n    {\n        get { return instanceData; }\n\tset { instanceData = value ; }\n    }\n}\n\nExceptions\nFields marked as readonly or const are ignored by this rule.\nFields inside classes or structs annotated with the StructLayoutAttribute are ignored by this rule.\nSee\n\n   MITRE, CWE-493 - Critical Public Variable Without Final Modifier \n\n\n"
    },
    {
      "Code": "1075",
      "Title": "URIs should not be hardcoded",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1075",
      "Description": "Hardcoding a URI makes it difficult to test a program: path literals are not always portable across operating systems, a given absolute path may\nnot exist on a specific test environment, a specified Internet URL may not be available when executing the tests, production environment filesystems\nusually differ from the development environment, …​etc. For all those reasons, a URI should never be hardcoded. Instead, it should be replaced by\ncustomizable parameter.\nFurther even if the elements of a URI are obtained dynamically, portability can still be limited if the path-delimiters are hardcoded.\nThis rule raises an issue when URI’s or path delimiters are hardcoded.\nExceptions\nThis rule does not raise an issue when an ASP.NET virtual path is passed as an argument to one of the following:\n\n   methods: System.Web.HttpServerUtilityBase.MapPath(), System.Web.HttpRequestBase.MapPath(),\n  System.Web.HttpResponseBase.ApplyAppPathModifier(), System.Web.Mvc.UrlHelper.Content() \n   all methods of: System.Web.VirtualPathUtility \n   constructors of: Microsoft.AspNetCore.Mvc.VirtualFileResult, Microsoft.AspNetCore.Routing.VirtualPathData \n\n\n"
    },
    {
      "Code": "101",
      "Title": "Types should be named in PascalCase",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-101",
      "Description": "Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not type names are using PascalCase. To reduce noise,\ntwo consecutive upper case characters are allowed unless they form the whole type name. So, MyXClass is compliant, but XC on\nits own is not.\nNoncompliant Code Example\n\nclass my_class {...}\nclass SOMEName42 {...}\n\nCompliant Solution\n\nclass MyClass {...}\nclass SomeName42 {...}\n\nExceptions\n\n   The rule ignores types that are marked with ComImportAttribute or InterfaceTypeAttribute. \n   The rule allows for two-letter acronyms in which both letters are capitalized, as shown in the following identifier: IOStream\n  \n   The rule allows having '_' characters in class names inside test projects. \n\n\nclass Some_Name___42 {...} // valid in test\nclass Some_name___42 {...} // still not valid\nclass Some_Name_XC {...} // invalid because of XC, should be Some_Name_Xc\n\nSee\n\n   Microsoft Capitalization\n  Conventions \n\n\n"
    },
    {
      "Code": "1135",
      "Title": "Track uses of \"TODO\" tags",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1135",
      "Description": "TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.\nSometimes the developer will not have the time or will simply forget to get back to that tag.\nThis rule is meant to track those tags and to ensure that they do not go unnoticed.\nNoncompliant Code Example\n\nprivate void DoSomething()\n{\n  // TODO\n}\n\nSee\n\n   MITRE, CWE-546 - Suspicious Comment \n\n\n"
    },
    {
      "Code": "2931",
      "Title": "Classes with \"IDisposable\" members should implement \"IDisposable\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2931",
      "Description": "An IDisposable object should be disposed (there are some rare exceptions where not disposing is fine, most notably Task).\nIf a class has an IDisposable field, there can be two situations:\n\n   The class observes a field that is under the responsibility of another class. \n   The class owns the field, and is therefore responsible for calling Dispose on it. \n\nIn the second case, the safest way for the class to ensure Dispose is called is to call it in its own Dispose function,\nand therefore to be itself IDisposable. A class is considered to own an IDisposable field resource if it created the object\nreferenced by the field.\nNoncompliant Code Example\n\npublic class ResourceHolder   // Noncompliant; doesn't implement IDisposable\n{\n  private FileStream fs;  // This member is never Disposed\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open); // I create the FileStream, I'm owning it\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n}\n\nCompliant Solution\n\npublic class ResourceHolder : IDisposable\n{\n&nbsp;&nbsp;private FileStream fs;\n&nbsp;&nbsp;public void OpenResource(string path)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;this.fs = new FileStream(path, FileMode.Open); // I create the FileStream, I'm owning it\n&nbsp;&nbsp;}\n&nbsp;&nbsp;public void CloseResource()\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;this.fs.Close();\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;public void Dispose()\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;this.fs.Dispose();\n&nbsp;&nbsp;}\n}\n\nSee\n\n   MITRE, CWE-459 - Incomplete Cleanup \n\n\n"
    },
    {
      "Code": "4462",
      "Title": "Calls to \"async\" methods should not be blocking",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4462",
      "Description": "Making blocking calls to async methods transforms something that was intended to be asynchronous into a synchronous block. Doing so\ncan cause deadlocks and unexpected blocking of context threads.\nAccording to the MSDN documentation:\n\n  The root cause of this deadlock is due to the way await handles contexts. By default, when an incomplete Task is\n  awaited, the current “context” is captured and used to resume the method when the Task completes. This “context” is the current\n  SynchronizationContext unless it’s null, in which case it’s the current TaskScheduler. GUI and ASP.NET applications have a\n  SynchronizationContext that permits only one chunk of code to run at a time. When the await completes, it attempts to\n  execute the remainder of the async method within the captured context. But that context already has a thread in it, which is\n  (synchronously) waiting for the async method to complete. They’re each waiting for the other, causing a deadlock.\n\n\n  \n    \n    \n    \n  \n  \n    \n      To Do This …\n      Instead of This …\n      Use This\n    \n  \n  \n    \n      Retrieve the result of a background task\n      Task.Wait, Task.Result or Task.GetAwaiter.GetResult\n      await\n    \n    \n      Wait for any task to complete\n      Task.WaitAny\n      await Task.WhenAny\n    \n    \n      Retrieve the results of multiple tasks\n      Task.WaitAll\n      await Task.WhenAll\n    \n    \n      Wait a period of time\n      Thread.Sleep\n      await Task.Delay\n    \n  \n\nNoncompliant Code Example\n\npublic static class DeadlockDemo\n{\n    private static async Task DelayAsync()\n    {\n        await Task.Delay(1000);\n    }\n\n    // This method causes a deadlock when called in a GUI or ASP.NET context.\n    public static void Test()\n    {\n        // Start the delay.\n        var delayTask = DelayAsync();\n        // Wait for the delay to complete.\n        delayTask.Wait(); // Noncompliant\n    }\n}\n\nCompliant Solution\n\npublic static class DeadlockDemo\n{\n    private static async Task DelayAsync()\n    {\n        await Task.Delay(1000);\n    }\n\n    public static async Task TestAsync()\n    {\n        // Start the delay.\n        var delayTask = DelayAsync();\n        // Wait for the delay to complete.\n        await delayTask;\n    }\n}\n\nExceptions\n\n   Main methods of Console Applications are not subject to this deadlock issue and so are ignored by this rule. \n   Thread.Sleep is also ignored when it is used in a non-async method. \n   Calls chained after Task.Run or Task.Factory.StartNew are ignored because they don’t suffer from this deadlock issue\n  \n\nSee\n\n   Async/Await - Best Practices in Asynchronous Programming \n\n\n"
    },
    {
      "Code": "2387",
      "Title": "Child class fields should not shadow parent class fields",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2387",
      "Description": "Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you’ll get confusion at\nbest, chaos at worst.\nNoncompliant Code Example\n\npublic class Fruit\n{\n  protected Season ripe;\n  protected Color flesh;\n\n  // ...\n}\n\npublic class Raspberry : Fruit\n{\n  private bool ripe; // Noncompliant\n  private static Color FLESH; // Noncompliant\n}\n\nCompliant Solution\n\npublic class Fruit\n{\n  protected Season ripe;\n  protected Color flesh;\n\n  // ...\n}\n\npublic class Raspberry : Fruit\n{\n  private bool ripened;\n  private static Color FLESH_COLOR;\n}\n\nExceptions\nThis rule ignores same-name fields that are static in both the parent and child classes. It also ignores private parent\nclass fields, but in all other such cases, the child class field should be renamed.\n\npublic class Fruit\n{\n  private Season ripe;\n  // ...\n}\n\npublic class Raspberry : Fruit\n{\n  private Season ripe;  // Compliant as parent field 'ripe' is anyway not visible from Raspberry\n  // ...\n}\n\n\n"
    },
    {
      "Code": "1451",
      "Title": "Track lack of copyright and license headers",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1451",
      "Description": "Each source file should start with a header stating file ownership and the license which must be used to distribute the application.\nThis rule must be fed with the header text that is expected at the beginning of every file.\nThe headerFormat must end with an empty line if you want to have an empty line between the file header and the first line for your\nsource file (using, namespace…​).\nFor example, if you want the source file to look like this\n\n// Copyright (c) SonarSource. All Rights Reserved. Licensed under the LGPL License.  See License.txt in the project root for license information.\n\nnamespace Foo\n{\n}\n\nthen the headerFormat parameter should end with an empty line like this\n\n// Copyright (c) SonarSource. All Rights Reserved. Licensed under the LGPL License.  See License.txt in the project root for license information.\n\nCompliant Solution\n\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\n\n"
    },
    {
      "Code": "1147",
      "Title": "Exit methods should not be called",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1147",
      "Description": "Calling Environment.Exit(exitCode) or Application.Exit() terminates the process and returns an exit code to the operating\nsystem..\nEach of these methods should be used with extreme care, and only when the intent is to stop the whole application.\nNoncompliant Code Example\n\nEnvironment.Exit(0);\nApplication.Exit();\n\nExceptions\nThese methods are ignored inside Main.\n\n"
    },
    {
      "Code": "2952",
      "Title": "Classes should \"Dispose\" of members from the classes' own \"Dispose\" methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2952",
      "Description": "It is possible in an IDisposable to call Dispose on class members from any method, but the contract of\nDispose is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource\nleaks.\nThis rule also applies for disposable ref structs.\nNoncompliant Code Example\n\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void CleanUp()\n  {\n    this.fs.Dispose(); // Noncompliant; Dispose not called in class' Dispose method\n  }\n\n  public void Dispose()\n  {\n    // method added to satisfy demands of interface\n  }\n}\n\nCompliant Solution\n\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void Dispose()\n  {\n    this.fs.Dispose();\n  }\n}\n\nSee\n\n   MITRE, CWE-459 - Incomplete Cleanup \n\n\n"
    },
    {
      "Code": "4829",
      "Title": "Reading the Standard Input is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4829",
      "Description": "Reading Standard Input is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2005-2337 \n   CVE-2017-11449 \n\nIt is common for attackers to craft inputs enabling them to exploit software vulnerabilities. Thus any data read from the standard input (stdin)\ncan be dangerous and should be validated.\nThis rule flags code that reads from the standard input.\nAsk Yourself Whether\n\n   data read from the standard input is not sanitized before being used. \n\nYou are at risk if you answered yes to this question.\nRecommended Secure Coding Practices\nSanitize all data read from the standard input before using it.\nSensitive Code Example\n\nusing System;\npublic class C\n{\n    public void Main()\n    {\n        Console.In; // Sensitive\n        var code = Console.Read(); // Sensitive\n        var keyInfo = Console.ReadKey(...); // Sensitive\n        var text = Console.ReadLine(); // Sensitive\n        Console.OpenStandardInput(...); // Sensitive\n    }\n}\n\nExceptions\nThis rule does not raise issues when the return value of the Console.Read Console.ReadKey or\nConsole.ReadLine methods is ignored.\n\nusing System;\npublic class C\n{\n    public void Main()\n    {\n        Console.ReadKey(...); // Return value is ignored\n        Console.ReadLine(); // Return value is ignored\n    }\n}\n\nSee\n\n   MITRE, CWE-20 - Improper Input Validation \n\nDeprecated\nThis rule is deprecated, and will eventually be removed.\n\n"
    },
    {
      "Code": "4823",
      "Title": "Using command line arguments is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4823",
      "Description": "Using command line arguments is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2018-7281 \n   CVE-2018-12326 \n   CVE-2011-3198 \n\nCommand line arguments can be dangerous just like any other user input. They should never be used without being first validated and sanitized.\nRemember also that any user can retrieve the list of processes running on a system, which makes the arguments provided to them visible. Thus\npassing sensitive information via command line arguments should be considered as insecure.\nThis rule raises an issue when on every program entry points (main methods) when command line arguments are used. The goal is to guide\nsecurity code reviews.\nAsk Yourself Whether\n\n   any of the command line arguments are used without being sanitized first. \n   your application accepts sensitive information via command line arguments. \n\nIf you answered yes to any of these questions you are at risk.\nRecommended Secure Coding Practices\nSanitize all command line arguments before using them.\nAny user or application can list running processes and see the command line arguments they were started with. There are safer ways of providing\nsensitive information to an application than exposing them in the command line. It is common to write them on the process' standard input, or give the\npath to a file containing the information.\nSensitive Code Example\n\nnamespace MyNamespace\n{\n    class Program\n    {\n        static void Main(string[] args) // Sensitive if there is a reference to \"args\" in the method.\n        {\n            string myarg = args[0];\n            // ...\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-88 - Argument Injection or Modification \n   MITRE, CWE-214 - Information Exposure Through Process Environment \n   SANS Top 25 - Insecure Interaction Between Components \n\nDeprecated\nThis rule is deprecated, and will eventually be removed.\n\n"
    },
    {
      "Code": "4818",
      "Title": "Using Sockets is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4818",
      "Description": "Using sockets is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2011-178 \n   CVE-2017-5645 \n   CVE-2018-6597 \n\nSockets are vulnerable in multiple ways:\n\n   They enable a software to interact with the outside world. As this world is full of attackers it is necessary to check that they cannot receive\n  sensitive information or inject dangerous input. \n   The number of sockets is limited and can be exhausted. Which makes the application unresponsive to users who need additional sockets. \n\nThis rules flags code that creates sockets. It matches only the direct use of sockets, not use through frameworks or high-level APIs such as the\nuse of http connections.\nAsk Yourself Whether\n\n   sockets are created without any limit every time a user performs an action. \n   input received from sockets is used without being sanitized. \n   sensitive data is sent via sockets without being encrypted. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   In many cases there is no need to open a socket yourself. Use instead libraries and existing protocols. \n   Encrypt all data sent if it is sensitive. Usually it is better to encrypt it even if the data is not sensitive as it might change later. \n   Sanitize any input read from the socket. \n   Limit the number of sockets a given user can create. Close the sockets as soon as possible. \n\nSensitive Code Example\n\nusing System.Net.Sockets;\n\nclass TestSocket\n{\n    public static void Run()\n    {\n        // Sensitive\n        Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n\n        // TcpClient and UdpClient simply abstract the details of creating a Socket\n        TcpClient client = new TcpClient(\"example.com\", 80); // Sensitive\n        UdpClient listener = new UdpClient(80); // Sensitive\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-400 - Uncontrolled Resource Consumption ('Resource Exhaustion') \n   MITRE, CWE-200 - Exposure of Sensitive Information to an Unauthorized Actor \n   SANS Top 25 - Risky Resource Management \n   SANS Top 25 - Porous Defenses \n\nDeprecated\nThis rule is deprecated, and will eventually be removed.\n\n"
    },
    {
      "Code": "4787",
      "Title": "Encrypting data is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4787",
      "Description": "Encrypting data is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2017-7902 \n   CVE-2006-1378 \n   CVE-2003-1376 \n\nProper encryption requires both the encryption algorithm and the key to be strong. Obviously the private key needs to remain secret and be renewed\nregularly. However these are not the only means to defeat or weaken an encryption.\nThis rule flags function calls that initiate encryption/decryption.\nAsk Yourself Whether\n\n   the private key might not be random, strong enough or the same key is reused for a long long time. \n   the private key might be compromised. It can happen when it is stored in an unsafe place or when it was transferred in an unsafe manner. \n   the key exchange is made without properly authenticating the receiver. \n   the encryption algorithm is not strong enough for the level of protection required. Note that encryption algorithms strength decreases as time\n  passes. \n   the chosen encryption library is deemed unsafe. \n   a nonce is used, and the same value is reused multiple times, or the nonce is not random. \n   the RSA algorithm is used, and it does not incorporate an Optimal Asymmetric Encryption Padding (OAEP), which might weaken the encryption.\n  \n   the CBC (Cypher Block Chaining) algorithm is used for encryption, and it’s IV (Initialization Vector) is not generated using a secure random\n  algorithm, or it is reused. \n   the Advanced Encryption Standard (AES) encryption algorithm is used with an unsecure mode. See the recommended practices for more information.\n  \n\nYou are at risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\n\n   Generate encryption keys using secure random algorithms. \n   When generating cryptographic keys (or key pairs), it is important to use a key length that provides enough entropy against brute-force\n  attacks. For the Blowfish algorithm the key should be at least 128 bits long, while for the RSA algorithm it should be at least 2048 bits long.\n  \n   Regenerate the keys regularly. \n   Always store the keys in a safe location and transfer them only over safe channels. \n   If there is an exchange of cryptographic keys, check first the identity of the receiver. \n   Only use strong encryption algorithms. Check regularly that the algorithm is still deemed secure. It is also imperative that they are\n  implemented correctly. Use only encryption libraries which are deemed secure. Do not define your own encryption algorithms as they will most\n  probably have flaws. \n   When a nonce is used, generate it randomly every time. \n   When using the RSA algorithm, incorporate an Optimal Asymmetric Encryption Padding (OAEP). \n   When CBC is used for encryption, the IV must be random and unpredictable. Otherwise it exposes the encrypted value to crypto-analysis attacks\n  like \"Chosen-Plaintext Attacks\". Thus a secure random algorithm should be used. An IV value should be associated to one and only one encryption\n  cycle, because the IV’s purpose is to ensure that the same plaintext encrypted twice will yield two different ciphertexts. \n   The Advanced Encryption Standard (AES) encryption algorithm can be used with various modes. Galois/Counter Mode (GCM) with no padding should be\n  preferred to the following combinations which are not secured:\n    \n       Electronic Codebook (ECB) mode: Under a given key, any given plaintext block always gets encrypted to the same ciphertext block. Thus, it\n      does not hide data patterns well. In some senses, it doesn’t provide serious message confidentiality, and it is not recommended for use in\n      cryptographic protocols at all. \n       Cipher Block Chaining (CBC) with PKCS#5 padding (or PKCS#7) is susceptible to padding oracle attacks. \n      \n\nSensitive Code Example\n\nusing System;\nusing System.Security.Cryptography;\n\nnamespace MyNamespace\n{\n    public class MyClass\n    {\n        public void Main()\n        {\n            Byte[] data = {1,1,1};\n\n            RSA myRSA = RSA.Create();\n            RSAEncryptionPadding padding = RSAEncryptionPadding.CreateOaep(HashAlgorithmName.SHA1);\n            // Review all base RSA class' Encrypt/Decrypt calls\n            myRSA.Encrypt(data, padding); // Sensitive\n            myRSA.EncryptValue(data); // Sensitive\n            myRSA.Decrypt(data, padding); // Sensitive\n            myRSA.DecryptValue(data); // Sensitive\n\n            RSACryptoServiceProvider myRSAC = new RSACryptoServiceProvider();\n            // Review the use of any TryEncrypt/TryDecrypt and specific Encrypt/Decrypt of RSA subclasses.\n            myRSAC.Encrypt(data, false); // Sensitive\n            myRSAC.Decrypt(data, false); // Sensitive\n            int written;\n            myRSAC.TryEncrypt(data, Span&lt;byte&gt;.Empty, padding, out written); // Sensitive\n            myRSAC.TryDecrypt(data, Span&lt;byte&gt;.Empty, padding, out written); // Sensitive\n\n            byte[] rgbKey = {1,2,3};\n            byte[] rgbIV = {4,5,6};\n            SymmetricAlgorithm rijn = SymmetricAlgorithm.Create();\n            // Review the creation of Encryptors from any SymmetricAlgorithm instance.\n            rijn.CreateEncryptor(); // Sensitive\n            rijn.CreateEncryptor(rgbKey, rgbIV); // Sensitive\n            rijn.CreateDecryptor(); // Sensitive\n            rijn.CreateDecryptor(rgbKey, rgbIV); // Sensitive\n        }\n\n        public class MyCrypto : System.Security.Cryptography.AsymmetricAlgorithm // Sensitive\n        {\n            // ...\n        }\n\n        public class MyCrypto2 : System.Security.Cryptography.SymmetricAlgorithm // Sensitive\n        {\n            // ...\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   OWASP Top 10 2017 Category A6 - Security\n  Misconfiguration \n   MITRE, CWE-321 - Use of Hard-coded Cryptographic Key \n   MITRE, CWE-322 - Key Exchange without Entity Authentication \n   MITRE, CWE-323 - Reusing a Nonce, Key Pair in Encryption \n   MITRE, CWE-324 - Use of a Key Past its Expiration Date \n   MITRE, CWE-325 - Missing Required Cryptographic Step \n   MITRE, CWE-326 - Inadequate Encryption Strength \n   MITRE, CWE-327 - Use of a Broken or Risky Cryptographic Algorithm \n   SANS Top 25 - Porous Defenses \n\nDeprecated\nThis rule is deprecated; use {rule:csharpsquid:S4426}, {rule:csharpsquid:S5542}, {rule:csharpsquid:S5547} instead.\n\n"
    },
    {
      "Code": "4784",
      "Title": "Using regular expressions is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4784",
      "Description": "Using regular expressions is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2017-16021 \n   CVE-2018-13863 \n\nEvaluating regular expressions against input strings is potentially an extremely CPU-intensive task. Specially crafted regular expressions such as\n(a+)+s will take several seconds to evaluate the input string aaaaaaaaaaaaaaaaaaaaaaaaaaaaabs. The problem is that with\nevery additional a character added to the input, the time required to evaluate the regex doubles. However, the equivalent regular\nexpression, a+s (without grouping) is efficiently evaluated in milliseconds and scales linearly with the input size.\nEvaluating such regular expressions opens the door to Regular expression Denial of Service (ReDoS) attacks. In the\ncontext of a web application, attackers can force the web server to spend all of its resources evaluating regular expressions thereby making the\nservice inaccessible to genuine users.\nThis rule flags any execution of a hardcoded regular expression which has at least 3 characters and at least two instances of any of the following\ncharacters: *+{.\nExample: (a+)*\nAsk Yourself Whether\n\n   the executed regular expression is sensitive and a user can provide a string which will be analyzed by this regular expression. \n   your regular expression engine performance decrease with specially crafted inputs and regular expressions. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\nCheck whether your regular expression engine (the algorithm executing your regular expression) has any known vulnerabilities. Search for\nvulnerability reports mentioning the one engine you’re are using.\nIf the regular expression is vulnerable to ReDos attacks, mitigate the risk by using a \"match timeout\" to limit the time spent running the regular\nexpression.\nRemember also that a ReDos attack is possible if a user-provided regular expression is executed. This rule won’t detect this kind of injection.\nSensitive Code Example\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.Serialization;\nusing System.Text.RegularExpressions;\nusing System.Web;\n\nnamespace N\n{\n    public class RegularExpression\n    {\n        void Foo(RegexOptions options, TimeSpan matchTimeout, string input,\n                 string replacement, MatchEvaluator evaluator)\n        {\n            // All the following instantiations are Sensitive.\n            new System.Text.RegularExpressions.Regex(\"(a+)+\");\n            new System.Text.RegularExpressions.Regex(\"(a+)+\", options);\n            new System.Text.RegularExpressions.Regex(\"(a+)+\", options, matchTimeout);\n\n            // All the following static methods are Sensitive.\n            System.Text.RegularExpressions.Regex.IsMatch(input, \"(a+)+\");\n            System.Text.RegularExpressions.Regex.IsMatch(input, \"(a+)+\", options);\n            System.Text.RegularExpressions.Regex.IsMatch(input, \"(a+)+\", options, matchTimeout);\n\n            System.Text.RegularExpressions.Regex.Match(input, \"(a+)+\");\n            System.Text.RegularExpressions.Regex.Match(input, \"(a+)+\", options);\n            System.Text.RegularExpressions.Regex.Match(input, \"(a+)+\", options, matchTimeout);\n\n            System.Text.RegularExpressions.Regex.Matches(input, \"(a+)+\");\n            System.Text.RegularExpressions.Regex.Matches(input, \"(a+)+\", options);\n            System.Text.RegularExpressions.Regex.Matches(input, \"(a+)+\", options, matchTimeout);\n\n            System.Text.RegularExpressions.Regex.Replace(input, \"(a+)+\", evaluator);\n            System.Text.RegularExpressions.Regex.Replace(input, \"(a+)+\", evaluator, options);\n            System.Text.RegularExpressions.Regex.Replace(input, \"(a+)+\", evaluator, options, matchTimeout);\n            System.Text.RegularExpressions.Regex.Replace(input, \"(a+)+\", replacement);\n            System.Text.RegularExpressions.Regex.Replace(input, \"(a+)+\", replacement, options);\n            System.Text.RegularExpressions.Regex.Replace(input, \"(a+)+\", replacement, options, matchTimeout);\n\n            System.Text.RegularExpressions.Regex.Split(input, \"(a+)+\");\n            System.Text.RegularExpressions.Regex.Split(input, \"(a+)+\", options);\n            System.Text.RegularExpressions.Regex.Split(input, \"(a+)+\", options, matchTimeout);\n        }\n    }\n}\n\nExceptions\nSome corner-case regular expressions will not raise an issue even though they might be vulnerable. For example: (a|aa)+,\n(a|a?)+.\nIt is a good idea to test your regular expression if it has the same pattern on both side of a \"|\".\nSee\n\n   OWASP Top 10 2017 Category A1 - Injection \n   MITRE, CWE-624 - Executable Regular Expression Error\n  \n   OWASP Regular expression Denial of Service - ReDoS \n\nDeprecated\nThis rule is deprecated; use {rule:roslyn.sonaranalyzer.security.cs:S2631} instead.\n\n"
    },
    {
      "Code": "4039",
      "Title": "Interface methods should be callable by derived types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4039",
      "Description": "When a base type explicitly implements a public interface method, that method is only accessible in derived types through a reference to the\ncurrent instance (namely this). If the derived type explicitly overrides that interface method, the base implementation becomes\ninaccessible.\nThis rule raises an issue when an unsealed, externally visible type provides an explicit method implementation of a public interface\nand does not provide an alternate, externally visible method with the same name.\nNoncompliant Code Example\n\npublic interface IMyInterface\n{\n    void MyMethod();\n}\n\npublic class Foo : IMyInterface\n{\n    void IMyInterface.MyMethod() // Noncompliant\n    {\n        MyMethod();\n    }\n\n    void MyMethod()\n    {\n        // Do something ...\n    }\n}\n\npublic class Bar : Foo, IMyInterface\n{\n    public void MyMethod()\n    {\n        // Can't access base.MyMethod()\n        // ((IMyInterface)this).MyMethod() would be a recursive call\n    }\n}\n\nCompliant Solution\n\npublic interface IMyInterface\n{\n    void MyMethod();\n}\n\npublic class Foo : IMyInterface\n{\n    void IMyInterface.MyMethod()\n    {\n        MyMethod();\n    }\n\n    protected void MyMethod() // or public\n    {\n        // Do something ...\n    }\n}\n\npublic class Bar : Foo, IMyInterface\n{\n    public void MyMethod()\n    {\n        // Do something\n        base.MyMethod();\n    }\n}\n\nExceptions\nThis rule does not report a violation for an explicit implementation of IDisposable.Dispose when an externally visible\nClose() or System.IDisposable.Dispose(Boolean) method is provided.\n\n"
    },
    {
      "Code": "4025",
      "Title": "Child class fields should not differ from parent class fields only by capitalization",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4025",
      "Description": "Having a field in a child class with a name that differs from a parent class' field only by capitalization is sure to cause confusion. Such child\nclass fields should be renamed.\nNoncompliant Code Example\n\npublic class Fruit\n{\n  protected string plantingSeason;\n  //...\n}\n\npublic class Raspberry : Fruit\n{\n  protected string plantingseason;  // Noncompliant\n  // ...\n}\n\nCompliant Solution\n\npublic class Fruit\n{\n  protected string plantingSeason;\n  //...\n}\n\npublic class Raspberry : Fruit\n{\n  protected string whenToPlant;\n  // ...\n}\n\nOr\n\npublic class Fruit\n{\n  protected string plantingSeason;\n  //...\n}\n\npublic class Raspberry : Fruit\n{\n  // field removed; parent field will be used instead\n  // ...\n}\n\nExceptions\nThis rule ignores same-name fields that are static in both the parent and child classes. It also ignores private parent\nclass fields, but in all other such cases, the child class field should be renamed.\n\n"
    },
    {
      "Code": "4000",
      "Title": "Pointers to unmanaged memory should not be visible",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4000",
      "Description": "Pointer and unmanaged function pointer types such as IntPtr, UIntPtr, int* etc. are used to access unmanaged\nmemory, usually in order to use C or C++ libraries. If such a pointer is not secured by making it private, internal or\nreadonly, it can lead to a vulnerability allowing access to arbitrary locations.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class MyClass\n  {\n    public IntPtr myPointer;  // Noncompliant\n    protected UIntPtr myOtherPointer; // Noncompliant\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class MyClass\n  {\n    private IntPtr myPointer;\n    protected readonly UIntPtr myOtherPointer;\n  }\n}\n\n\n"
    },
    {
      "Code": "3937",
      "Title": "Number patterns should be regular",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3937",
      "Description": "The use of punctuation characters to separate subgroups in a number can make the number more readable. For instance consider 1,000,000,000 versus\n1000000000. But when the grouping is irregular, such as 1,000,00,000; it indicates an error.\nThis rule raises an issue when underscores (_) are used to break a number into irregular subgroups.\nNoncompliant Code Example\n\nint duos = 1_00_00;\nint million = 1_000_00_000;  // Noncompliant\nint thousand = 1000;\nint tenThousand = 100_00;  // Noncompliant\n\n\n"
    },
    {
      "Code": "3874",
      "Title": "\"out\" and \"ref\" parameters should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3874",
      "Description": "Passing a parameter by reference, which is what happens when you use the out or ref parameter modifiers, means that the\nmethod will receive a pointer to the argument, rather than the argument itself. If the argument was a value type, the method will be able to change\nthe argument’s values. If it was a reference type, then the method receives a pointer to a pointer, which is usually not what was intended. Even when\nit is what was intended, this is the sort of thing that’s difficult to get right, and should be used with caution.\nThis rule raises an issue when out or ref is used on a non-Optional parameter in a public method.\nOptional parameters are covered by {rule:csharpsquid:S3447}.\nNoncompliant Code Example\n\npublic void GetReply(\n         ref MyClass input, // Noncompliant\n         out string reply)  // Noncompliant\n{ ... }\n\nCompliant Solution\n\npublic string GetReply(MyClass input)\n{ ... }\n\npublic bool TryGetReply(MyClass input, out string reply)\n{ ... }\n\npublic ReplyData GetReply(MyClass input)\n{ ... }\n\ninternal void GetReply(ref MyClass input, out string reply)\n{ ... }\n\nExceptions\nThis rule will not raise issues for:\n\n   non-public methods \n   methods with only 'out' parameters, name starting with \"Try\" and return type bool. \n   interface implementation methods \n\n\n"
    },
    {
      "Code": "3353",
      "Title": "Unchanged local variables should be \"const\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3353",
      "Description": "Marking a variable that is unchanged after initialization const is an indication to future maintainers that \"no this isn’t updated,\nand it’s not supposed to be\". const should be used in these situations in the interests of code clarity.\nNoncompliant Code Example\n\npublic bool Seek(int[] input)\n{\n  int target = 32;  // Noncompliant\n  foreach (int i in input)\n  {\n    if (i == target)\n    {\n      return true;\n    }\n  }\n  return false;\n}\n\nCompliant Solution\n\npublic bool Seek(int[] input)\n{\n  const int target = 32;\n  foreach (int i in input)\n  {\n    if (i == target)\n    {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n"
    },
    {
      "Code": "3216",
      "Title": "\"ConfigureAwait(false)\" should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3216",
      "Description": "After an awaited Task has executed, you can continue execution in the original, calling thread or any arbitrary thread.\nUnless the rest of the code needs the context from which the Task was spawned, Task.ConfigureAwait(false) should be used to\nkeep execution in the Task thread to avoid the need for context switching and the possibility of deadlocks.\nThis rule raises an issue when code in a class library targeting .Net Framework awaits a Task and continues execution in\nthe original calling thread.\nThe rule does not raise for .Net Core libraries as there is no SynchronizationContext in .Net Core.\nNoncompliant Code Example\n\nvar response = await httpClient.GetAsync(url);  // Noncompliant\n\nCompliant Solution\n\nvar response = await httpClient.GetAsync(url).ConfigureAwait(false);\n\n\n"
    },
    {
      "Code": "3215",
      "Title": "\"interface\" instances should not be cast to concrete types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3215",
      "Description": "Needing to cast from an interface to a concrete type indicates that something is wrong with the abstractions in use, likely that\nsomething is missing from the interface. Instead of casting to a discrete type, the missing functionality should be added to the\ninterface. Otherwise there is a risk of runtime exceptions.\nNoncompliant Code Example\n\npublic interface IMyInterface\n{\n  void DoStuff();\n}\n\npublic class MyClass1 : IMyInterface\n{\n  public int Data { get { return new Random().Next(); } }\n\n  public void DoStuff()\n  {\n    // TODO...\n  }\n}\n\npublic static class DowncastExampleProgram\n{\n  static void EntryPoint(IMyInterface interfaceRef)\n  {\n    MyClass1 class1 = (MyClass1)interfaceRef;  // Noncompliant\n    int privateData = class1.Data;\n\n    class1 = interfaceRef as MyClass1;  // Noncompliant\n    if (class1 != null)\n    {\n      // ...\n    }\n  }\n}\n\nExceptions\nCasting to object doesn’t raise an issue, because it can never fail.\n\nstatic void EntryPoint(IMyInterface interfaceRef)\n{\n  var o = (object)interfaceRef;\n  ...\n}\n\n\n"
    },
    {
      "Code": "2701",
      "Title": "Literal boolean values should not be used in assertions",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2701",
      "Description": "There’s no reason to use literal boolean values in assertions. Doing so is at best confusing for maintainers, and at worst a bug.\nNoncompliant Code Example\n\nbool b = true;\nNUnit.Framework.Assert.AreEqual(true, b);\nXunit.Assert.NotSame(true, b);\nMicrosoft.VisualStudio.TestTools.UnitTesting.Assert.AreEqual(true, b);\nSystem.Diagnostics.Debug.Assert(true);\n\n\n"
    },
    {
      "Code": "2360",
      "Title": "Optional parameters should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2360",
      "Description": "The overloading mechanism should be used in place of optional parameters for several reasons:\n\n   Optional parameter values are baked into the method call site code, thus, if a default value has been changed, all referencing assemblies need\n  to be rebuilt, otherwise the original values will be used. \n   The Common Language Specification (CLS) allows compilers to ignore default parameter values, and thus require the caller to explicitly specify\n  the values. For example, if you want to consume a method with default argument from another .NET compatible language (for instance C++/CLI), you\n  will have to provide all arguments. When using method overloads, you could achieve similar behavior as default arguments. \n   Optional parameters prevent muddying the definition of the function contract. Here is a simple example: if there are two optional parameters,\n  when one is defined, is the second one still optional or mandatory? \n\nNoncompliant Code Example\n\nvoid Notify(string company, string office = \"QJZ\") // Noncompliant\n{\n}\n\nCompliant Solution\n\nvoid Notify(string company)\n{\n  Notify(company, \"QJZ\");\n}\nvoid Notify(string company, string office)\n{\n}\n\nExceptions\nThe rule ignores non externally visible methods.\n\n"
    },
    {
      "Code": "2339",
      "Title": "Public constant members should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2339",
      "Description": "Constant members are copied at compile time to the call sites, instead of being fetched at runtime.\nAs an example, say you have a library with a constant Version member set to 1.0, and a client application linked to it.\nThis library is then updated and Version is set to 2.0. Unfortunately, even after the old DLL is replaced by the new one,\nVersion will still be 1.0 for the client application. In order to see 2.0, the client application would need to\nbe rebuilt against the new version of the library.\nThis means that you should use constants to hold values that by definition will never change, such as Zero. In practice, those cases\nare uncommon, and therefore it is generally better to avoid constant members.\nThis rule only reports issues on public constant fields, which can be reached from outside the defining assembly.\nNoncompliant Code Example\n\npublic class Foo\n{\n    public const double Version = 1.0;           // Noncompliant\n}\n\nCompliant Solution\n\npublic class Foo\n{\n    public static double Version\n    {\n      get { return 1.0; }\n    }\n}\n\n\n"
    },
    {
      "Code": "2330",
      "Title": "Array covariance should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2330",
      "Description": "Array covariance is the principle that if an implicit or explicit reference conversion exits from type A to B, then the\nsame conversion exists from the array type A[] to B[].\nWhile this array conversion can be useful in readonly situations to pass instances of A[] where B[] is expected, it must\nbe used with care, since assigning an instance of B into an array of A will cause an ArrayTypeMismatchException\nto be thrown at runtime.\nNoncompliant Code Example\n\nabstract class Fruit { }\nclass Apple : Fruit { }\nclass Orange : Fruit { }\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    Fruit[] fruits = new Apple[1]; // Noncompliant - array covariance is used\n    FillWithOranges(fruits);\n  }\n\n  // Just looking at the code doesn't reveal anything suspicious\n  static void FillWithOranges(Fruit[] fruits)\n  {\n    for (int i = 0; i &lt; fruits.Length; i++)\n    {\n      fruits[i] = new Orange(); // Will throw an ArrayTypeMismatchException\n    }\n  }\n}\n\nCompliant Solution\n\nabstract class Fruit { }\nclass Apple : Fruit { }\nclass Orange : Fruit { }\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    Orange[] fruits = new Orange[1]; // Compliant\n    FillWithOranges(fruits);\n  }\n\n  static void FillWithOranges(Orange[] fruits)\n  {\n    for (int i = 0; i &lt; fruits.Length; i++)\n    {\n      fruits[i] = new Orange();\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "2302",
      "Title": "\"nameof\" should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2302",
      "Description": "Because parameter names could be changed during refactoring, they should not be spelled out literally in strings. Instead, use\nnameof(), and the string that’s output will always be correct.\nThis rule raises an issue when a string in the throw statement contains the name of one of the method parameters.\nNoncompliant Code Example\n\nvoid DoSomething(int someParameter, string anotherParam)\n{\n    if (someParameter &lt; 0)\n    {\n        throw new ArgumentException(\"Bad argument\", \"someParameter\");  // Noncompliant\n    }\n    if (anotherParam == null)\n    {\n        throw new Exception(\"anotherParam should not be null\"); // Noncompliant\n    }\n}\n\nCompliant Solution\n\nvoid DoSomething(int someParameter)\n{\n    if (someParameter &lt; 0)\n    {\n        throw new ArgumentException(\"Bad argument\", nameof(someParameter));\n    }\n    if (anotherParam == null)\n    {\n        throw new Exception($\"{nameof(anotherParam)} should not be null\");\n    }\n}\n\nExceptions\n\n   The rule doesn’t raise any issue when using C# &lt; 6.0. \n   When the parameter name is contained in a sentence inside the throw statement string, the rule will raise an issue only if the\n  parameter name is at least 5 characters long. This is to avoid false positives. \n\n\n"
    },
    {
      "Code": "2197",
      "Title": "Modulus results should not be checked for direct equality",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2197",
      "Description": "When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for\nequality with a positive number (or a negative one) could result in unexpected results.\nNoncompliant Code Example\n\npublic bool IsOdd(int x)\n{\n  return x % 2 == 1;  // Noncompliant; if x is an odd negative, x % 2 == -1\n}\n\nCompliant Solution\n\npublic bool IsOdd(int x)\n{\n  return x %2 != 0;\n}\n\nor\n\npublic bool IsOdd(uint x)\n{\n  return x %2 == 1;\n}\n\n\n"
    },
    {
      "Code": "1994",
      "Title": "\"for\" loop increment clauses should modify the loops' counters",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1994",
      "Description": "It can be extremely confusing when a for loop’s counter is incremented outside of its increment clause. In such cases, the increment\nshould be moved to the loop’s increment clause if at all possible.\nNoncompliant Code Example\n\nfor (i = 0; i &lt; 10; j++) // Noncompliant\n{\n  // ...\n}\n\nCompliant Solution\n\nfor (i = 0; i &lt; 10; i++)\n{\n  // ...\n}\n\n\n"
    },
    {
      "Code": "1821",
      "Title": "\"switch\" statements should not be nested",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1821",
      "Description": "Nested switch structures are difficult to understand because you can easily confuse the cases of an inner switch as\nbelonging to an outer statement. Therefore nested switch statements should be avoided.\nSpecifically, you should structure your code to avoid the need for nested switch statements, but if you cannot, then consider moving\nthe inner switch to another function.\n\n"
    },
    {
      "Code": "1541",
      "Title": "Methods and properties should not be too complex",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1541",
      "Description": "The cyclomatic complexity of methods and properties should not exceed a defined threshold. Complex code can perform poorly and will in any case be\ndifficult to understand and therefore to maintain.\n\n"
    },
    {
      "Code": "134",
      "Title": "Control flow statements \"if\", \"switch\", \"for\", \"foreach\", \"while\", \"do\"  and \"try\" should not be nested too deeply",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-134",
      "Description": "Nested if, switch, for, foreach, while, do, and try\nstatements are key ingredients for making what’s known as \"Spaghetti code\".\nSuch code is hard to read, refactor and therefore maintain.\nNoncompliant Code Example\nWith the default threshold of 3:\n\nif (condition1) // Compliant - depth = 1\n{\n  /* ... */\n  if (condition2) // Compliant - depth = 2\n  {\n    /* ... */\n    for(int i = 0; i &lt; 10; i++) // Compliant - depth = 3, not exceeding the limit\n    {\n      /* ... */\n      if (condition4) // Noncompliant - depth = 4\n      {\n        if (condition5) // Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n        {\n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "131",
      "Title": "\"switch/Select\" statements should contain a \"default/Case Else\" clauses",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-131",
      "Description": "The requirement for a final default clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken. Even when the switch covers all current values of an enum, a\ndefault case should still be used because there is no guarantee that the enum won’t be extended.\nNoncompliant Code Example\n\nint foo = 42;\nswitch (foo) // Noncompliant\n{\n  case 0:\n    Console.WriteLine(\"foo = 0\");\n    break;\n  case 42:\n    Console.WriteLine(\"foo = 42\");\n    break;\n}\n\nCompliant Solution\n\nint foo = 42;\nswitch (foo) // Compliant\n{\n  case 0:\n    Console.WriteLine(\"foo = 0\");\n    break;\n  case 42:\n    Console.WriteLine(\"foo = 42\");\n    break;\n  default:\n    throw new InvalidOperationException(\"Unexpected value foo = \" + foo);\n}\n\nSee\n\n   MITRE, CWE-478 - Missing Default Case in Switch Statement \n\n\n"
    },
    {
      "Code": "126",
      "Title": "\"if ... else if\" constructs should end with \"else\" clauses",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-126",
      "Description": "This rule applies whenever an if statement is followed by one or more else if statements; the final else if\nshould be followed by an else statement.\nThe requirement for a final else statement is defensive programming.\nThe else statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final default clause in a switch statement.\nNoncompliant Code Example\n\nif (x == 0)\n{\n    DoSomething();\n}\nelse if (x == 1)\n{\n    DoSomethingElse();\n}\n\nCompliant Solution\n\nif (x == 0)\n{\n    DoSomething();\n}\nelse if (x == 1)\n{\n    DoSomethingElse();\n}\nelse\n{\n    throw new InvalidOperationException();\n}\n\nExceptions\nNone\n\n"
    },
    {
      "Code": "121",
      "Title": "Control structures should use curly braces",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-121",
      "Description": "While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.\nNoncompliant Code Example\n\n// the two statements seems to be attached to the if statement, but that is only true for the first one:\nif (condition)\n  ExecuteSomething();\n  CheckSomething();\n\nCompliant Solution\n\nif (condition)\n{\n  ExecuteSomething();\n  CheckSomething();\n}\n\n\n"
    },
    {
      "Code": "1067",
      "Title": "Expressions should not be too complex",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1067",
      "Description": "The complexity of an expression is defined by the number of &amp;&amp;, || and condition ? ifTrue : ifFalse\noperators it contains.\nA single expression’s complexity should not become too high to keep the code readable.\nNoncompliant Code Example\nWith the default threshold value of 3\n\nif (((condition1 &amp;&amp; condition2) || (condition3 &amp;&amp; condition4)) &amp;&amp; condition5) { ... }\n\nCompliant Solution\n\nif ((MyFirstCondition() || MySecondCondition()) &amp;&amp; MyLastCondition()) { ... }\n\n\n"
    },
    {
      "Code": "4564",
      "Title": "ASP.NET HTTP request validation feature should not be disabled",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4564",
      "Description": "ASP.Net has a feature to validate HTTP requests to prevent potentially dangerous content to perform a cross-site scripting (XSS) attack. There is\nno reason to disable this mechanism even if other checks to prevent XXS attacks are in place.\nThis rule raises an issue if a method with parameters is marked with System.Web.Mvc.HttpPostAttribute and not\nSystem.Web.Mvc.ValidateInputAttribute(true).\nNoncompliant Code Example\n\npublic class FooBarController : Controller\n{\n    [HttpPost] // Noncompliant\n    [ValidateInput(false)]\n    public ActionResult Purchase(string input)\n    {\n        return Foo(input);\n    }\n\n    [HttpPost] // Noncompliant\n    public ActionResult PurchaseSomethingElse(string input)\n    {\n        return Foo(input);\n    }\n}\n\nCompliant Solution\n\npublic class FooBarController : Controller\n{\n    [HttpPost]\n    [ValidateInput(true)] // Compliant\n    public ActionResult Purchase(string input)\n    {\n        return Foo(input);\n    }\n}\n\nExceptions\nParameterless methods marked with System.Web.Mvc.HttpPostAttribute will not trigger this issue.\nSee\n\n   OWASP Top 10 2017 Category A7 - Cross-Site Scripting\n  (XSS) \n   MITRE, CWE-79 - Improper Neutralization of Input During Web Page Generation ('Cross-site\n  Scripting') \n   SANS Top 25 - Insecure Interaction Between Components \n   OWASP ASP.NET Request Validation \n\nDeprecated\nThis rule is deprecated; use {rule:csharpsquid:S5753} instead.\n\n"
    },
    {
      "Code": "4212",
      "Title": "Serialization constructors should be secured",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4212",
      "Description": "Because serialization constructors allocate and initialize objects, security checks that are present on regular constructors must also be present\non a serialization constructor. Failure to do so would allow callers that could not otherwise create an instance to use the serialization constructor\nto do this.\nThis rule raises an issue when a type implements the System.Runtime.Serialization.ISerializable interface, is not a delegate or\ninterface, is declared in an assembly that allows partially trusted callers and has a constructor that takes a\nSystem.Runtime.Serialization.SerializationInfo object and a System.Runtime.Serialization.StreamingContext object which is\nnot secured by a security check, but one or more of the regular constructors in the type is secured.\nNoncompliant Code Example\n\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Security;\nusing System.Security.Permissions;\n\n[assembly: AllowPartiallyTrustedCallersAttribute()]\nnamespace MyLibrary\n{\n    [Serializable]\n    public class Foo : ISerializable\n    {\n        private int n;\n\n        [FileIOPermissionAttribute(SecurityAction.Demand, Unrestricted = true)]\n        public Foo()\n        {\n           n = -1;\n        }\n\n        protected Foo(SerializationInfo info, StreamingContext context) // Noncompliant\n        {\n           n = (int)info.GetValue(\"n\", typeof(int));\n        }\n\n        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n        {\n           info.AddValue(\"n\", n);\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.IO;\nusing System.Runtime.Serialization;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Security;\nusing System.Security.Permissions;\n\n[assembly: AllowPartiallyTrustedCallersAttribute()]\nnamespace MyLibrary\n{\n    [Serializable]\n    public class Foo : ISerializable\n    {\n        private int n;\n\n        [FileIOPermissionAttribute(SecurityAction.Demand, Unrestricted = true)]\n        public Foo()\n        {\n           n = -1;\n        }\n\n        [FileIOPermissionAttribute(SecurityAction.Demand, Unrestricted = true)]\n        protected Foo(SerializationInfo info, StreamingContext context)\n        {\n           n = (int)info.GetValue(\"n\", typeof(int));\n        }\n\n        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n        {\n           info.AddValue(\"n\", n);\n        }\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A8 - Insecure Deserialization\n  \n\n\n"
    },
    {
      "Code": "3949",
      "Title": "Calculations should not overflow",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3949",
      "Description": "Numbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers\nbeyond those bounds, and the result will be a value that has silently wrapped around from the expected positive value to a negative one, or vice\nversa.\nThis rule is only available for analyses run on Windows machines. It will not be reported in analyses run on any other OS.\nNoncompliant Code Example\n\npublic int getTheNumber(int val) {\n  if (val &lt;= 0) {\n      return val;\n  }\n  int num = int.MaxValue;\n  return num + val;  // Noncompliant\n}\n\n\n"
    },
    {
      "Code": "1244",
      "Title": "Floating point numbers should not be tested for equality",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1244",
      "Description": "Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a float or a double through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.\nEven simple floating point assignments are not simple:\n\nfloat f = 0.100000001f; // 0.1\ndouble d = 0.10000000000000001; // 0.1\n\n(Results will vary based on compiler and compiler settings)\nTherefore, the use of the equality (==) and inequality (!=) operators on float or double values\nis almost always an error.\nThis rule checks for the use of direct and indirect equality/inequality tests on floats and doubles.\nNoncompliant Code Example\n\nfloat myNumber = 3.146f;\nif ( myNumber == 3.146f ) //Noncompliant. Because of floating point imprecision, this will be false\n{\n  // ...\n}\n\nif (myNumber &lt;= 3.146f &amp;&amp; mNumber &gt;= 3.146f) // Noncompliant indirect equality test\n{\n  // ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) // Noncompliant indirect inequality test\n{\n  // ...\n}\n\n\n"
    },
    {
      "Code": "881",
      "Title": "Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-881",
      "Description": "The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:\n\n   It can significantly impair the readability of the code. \n   It introduces additional side effects into a statement, with the potential for undefined behavior. \n   It is safer to use these operators in isolation from any other arithmetic operators. \n\nNoncompliant Code Example\n\nu8a = ++u8b + u8c--;\nfoo = bar++ / 4;\n\nCompliant Solution\nThe following sequence is clearer and therefore safer:\n\n++u8b;\nu8a = u8b + u8c;\nu8c--;\nfoo = bar / 4;\nbar++;\n\n\n"
    },
    {
      "Code": "4059",
      "Title": "Property names should not match get methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4059",
      "Description": "Properties and Get method should have names that makes them clearly distinguishable.\nThis rule raises an issue when the name of a public or protected member starts with 'Get' and otherwise matches the name of a public or protected\nproperty.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public DateTime Date\n        {\n            get { return DateTime.Today; }\n        }\n\n        public string GetDate() // Noncompliant\n        {\n            return this.Date.ToString();\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public DateTime Date\n        {\n            get { return DateTime.Today; }\n        }\n\n        public string GetDateAsString()\n        {\n            return this.Date.ToString();\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "4057",
      "Title": "Locales should be set for data types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4057",
      "Description": "When you create a DataTable or DataSet, you should set the locale explicitly. By default, the locale for these types is\nthe current culture. For data that is stored in a database or file and is shared globally, the locale should ordinarily be set to the invariant\nculture (CultureInfo.InvariantCulture).\nThis rule raises an issue when System.Data.DataTable or System.Data.DataSet instances are created without explicitly\nsetting the locale property (DataTable.Locale or DataSet.Locale).\nNoncompliant Code Example\n\nusing System;\nusing System.Data;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public DataTable CreateTable()\n        {\n            DataTable table = new DataTable(\"Customers\"); // Noncompliant table.Locale not set\n            DataColumn key = table.Columns.Add(\"ID\", typeof(Int32));\n\n            key.AllowDBNull = false;\n            key.Unique = true;\n            table.Columns.Add(\"LastName\", typeof(String));\n            table.Columns.Add(\"FirstName\", typeof(String));\n            return table;\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Data;\nusing System.Globalization;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public DataTable CreateTable()\n        {\n            DataTable table = new DataTable(\"Customers\");\n            table.Locale = CultureInfo.InvariantCulture;\n            DataColumn key = table.Columns.Add(\"ID\", typeof(Int32));\n\n            key.AllowDBNull = false;\n            key.Unique = true;\n            table.Columns.Add(\"LastName\", typeof(String));\n            table.Columns.Add(\"FirstName\", typeof(String));\n            return table;\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "4055",
      "Title": "Literals should not be passed as localized parameters",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4055",
      "Description": "String literals embedded in the source code will not be localized properly.\nThis rule raises an issue when a literal string is passed as a parameter or property and one or more of the following cases is true:\n\n   The LocalizableAttribute attribute of the parameter or property is set to true. \n   The parameter or property name contains \"Text\", \"Message\", or \"Caption\". \n   The name of the string parameter that is passed to a Console.Write or Console.WriteLine method is either \"value\" or\n  \"format\". \n\nNoncompliant Code Example\n\nusing System;\nusing System.Globalization;\nusing System.Reflection;\nusing System.Windows.Forms;\n\n[assembly: NeutralResourcesLanguageAttribute(\"en-US\")]\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public void SetHour(int hour)\n        {\n            if (hour &lt; 0 || hour &gt; 23)\n            {\n                MessageBox.Show(\"The valid range is 0 - 23.\"); // Noncompliant\n            }\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Globalization;\nusing System.Reflection;\nusing System.Resources;\nusing System.Windows.Forms;\n\n\n\n[assembly: NeutralResourcesLanguageAttribute(\"en-US\")]\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        ResourceManager rm;\n        public Foo()\n        {\n            rm = new ResourceManager(\"en-US\", Assembly.GetExecutingAssembly());\n        }\n\n        public void SetHour(int hour)\n        {\n            if (hour &lt; 0 || hour &gt; 23)\n            {\n                MessageBox.Show(\n                rm.GetString(\"OutOfRangeMessage\", CultureInfo.CurrentUICulture));\n            }\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "4050",
      "Title": "Operators should be overloaded consistently",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4050",
      "Description": "When implementing operator overloads, it is very important to make sure that all related operators and methods are consistent in their\nimplementation.\nThe following guidelines should be followed:\n\n   When providing operator == you should also provide operator != and vice-versa. \n   When providing operator == you should also provide Equals(Object) and GetHashCode(). \n   When providing operator +, -, *, / or %&nbsp;you should also provide operator ==, respecting previous guidelines.\n  \n\nThis rule raises an issue when any of these guidelines are not followed on publicly-visible type (public, protected or protected internal).\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo // Noncompliant\n  {\n    private int left;\n    private int right;\n\n    public Foo(int l, int r)\n    {\n      this.left = l;\n      this.right = r;\n    }\n\n    public static Foo operator +(Foo a, Foo b)\n    {\n      return new Foo(a.left + b.left, a.right + b.right);\n    }\n\n    public static Foo operator -(Foo a, Foo b)\n    {\n      return new Foo(a.left - b.left, a.right - b.right);\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    private int left;\n    private int right;\n\n    public Foo(int l, int r)\n    {\n      this.left = l;\n      this.right = r;\n    }\n\n    public static Foo operator +(Foo a, Foo b)\n    {\n      return new Foo(a.left + b.left, a.right + b.right);\n    }\n\n    public static Foo operator -(Foo a, Foo b)\n    {\n      return new Foo(a.left - b.left, a.right - b.right);\n    }\n\n    public static bool operator ==(Foo a, Foo b)\n    {\n      return (a.left == b.left &amp;&amp; a.right == b.right);\n    }\n\n    public static bool operator !=(Foo a, Foo b)\n    {\n      return !(a == b);\n    }\n\n    public override bool Equals(Object obj)\n    {\n      Foo a = obj as Foo;\n      if (a == null)\n        return false;\n      return this == a;\n    }\n\n    public override int GetHashCode()\n    {\n       return (this.left * 10) + this.right;\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "4017",
      "Title": "Method signatures should not contain nested generic types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4017",
      "Description": "A nested type is a type argument that is also a generic type. Calling a method with such a nested type argument requires complicated and confusing\ncode. It should be avoided as much as possible.\nNoncompliant Code Example\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void DoSomething(ICollection&lt;ICollection&lt;int&gt;&gt; outerCollect) // Noncompliant\n    {\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "4016",
      "Title": "Enumeration members should not be named \"Reserved\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4016",
      "Description": "If an enum member’s name contains the word \"reserved\" it implies it is not currently used and will be change in the future. However\nchanging an enum member is a breaking change and can create significant problems. There is no need to reserve an enum member\nsince a new member can be added in the future, and such an addition will usually not be a breaking change.\nThis rule raises an issue when the name of an enumeration member contains \"reserved\".\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public enum Color\n  {\n        None,\n        Red,\n        Orange,\n        Yellow,\n        ReservedColor  // Noncompliant\n    }\n}\n\n\n"
    },
    {
      "Code": "4005",
      "Title": "\"System.Uri\" arguments should be used instead of strings",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4005",
      "Description": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri\nclass is a safe alternative and should be preferred.\nThis rule raises an issue when a called method has a string parameter with a name containing \"uri\", \"Uri\", \"urn\", \"Urn\", \"url\" or \"Url\" and the\ndeclaring type contains a corresponding overload that takes a System.Uri as a parameter.\nWhen there is a choice between two overloads that differ only regarding the representation of a URI, the user should choose the overload that takes\na System.Uri argument.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class Foo\n   {\n      public void FetchResource(string uriString) { }\n      public void FetchResource(Uri uri) { }\n\n      public string ReadResource(string uriString, string name, bool isLocal) { }\n      public string ReadResource(Uri uri, string name, bool isLocal) { }\n\n      public void Main() {\n        FetchResource(\"http://www.mysite.com\"); // Noncompliant\n        ReadResource(\"http://www.mysite.com\", \"foo-resource\", true); // Noncompliant\n      }\n   }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class Foo\n   {\n      public void FetchResource(string uriString) { }\n      public void FetchResource(Uri uri) { }\n\n      public string ReadResource(string uriString, string name, bool isLocal) { }\n      public string ReadResource(Uri uri, string name, bool isLocal) { }\n\n      public void Main() {\n        FetchResource(new Uri(\"http://www.mysite.com\"));\n        ReadResource(new Uri(\"http://www.mysite.com\"), \"foo-resource\", true);\n      }\n   }\n}\n\n\n"
    },
    {
      "Code": "4004",
      "Title": "Collection properties should be readonly",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4004",
      "Description": "A writable collection property can be replaced by a completely different collection. Making it readonly prevents that while still\nallowing individual members to be set. If you want to allow the replacement of the whole collection the recommended pattern is to implement a method\nto remove all the elements (e.g. System.Collections.List&lt;T&gt;.Clear) and a method to populate the collection (e.g.\nSystem.Collections.List&lt;T&gt;.AddRange).\nThis rule raises an issue when an externally visible writable property is of a type that implements System.Collections.ICollection or\nSystem.Collections.Generic.ICollection&lt;T&gt;.\nNoncompliant Code Example\n\nusing System;\nusing System.Collections;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    List&lt;string&gt; strings;\n\n    public List&lt;string&gt; SomeStrings\n    {\n      get { return strings; }\n      set { strings = value; } // Noncompliant\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Collections;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    List&lt;string&gt; strings;\n\n    public readonly List&lt;string&gt; SomeStrings\n    {\n      get { return strings; }\n    }\n  }\n}\n\nExceptions\nThis rule does not raise issues for\n\n   string, Array and PermissionSet, \n   properties marked as DataMemberAttribute \n   classes marked as Serializable \n   properties overriding a base class member \n   properties implementing interface \n\n&nbsp;\n\n"
    },
    {
      "Code": "4002",
      "Title": "Disposable types should declare finalizers",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4002",
      "Description": "This rule raises an issue when a disposable type contains fields of the following types and does not implement a finalizer:\n\n   System.IntPtr \n   System.UIntPtr \n   System.Runtime.InteropService.HandleRef \n\nNoncompliant Code Example\n\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace MyLibrary\n{\n  public class Foo : IDisposable // Noncompliant: Doesn't have a finalizer\n  {\n    private IntPtr myResource;\n    private bool disposed = false;\n\n    protected virtual void Dispose(bool disposing)\n    {\n      if (!disposed)\n      {\n        // Dispose of resources held by this instance.\n        FreeResource(myResource);\n        disposed = true;\n\n        // Suppress finalization of this disposed instance.\n        if (disposing)\n        {\n          GC.SuppressFinalize(this);\n        }\n      }\n    }\n\n    public void Dispose() {\n      Dispose(true);\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace MyLibrary\n{\n  public class Foo : IDisposable\n  {\n    private IntPtr myResource;\n    private bool disposed = false;\n\n    protected virtual void Dispose(bool disposing)\n    {\n      if (!disposed)\n      {\n        // Dispose of resources held by this instance.\n        FreeResource(myResource);\n        disposed = true;\n\n        // Suppress finalization of this disposed instance.\n        if (disposing)\n        {\n          GC.SuppressFinalize(this);\n        }\n      }\n    }\n\n    ~Foo()\n    {\n      Dispose(false);\n    }\n  }\n}\n\nSee\n\n   Related: {rule:csharpsquid:S3881} - \"IDisposable\" should be implemented correctly \n\n\n"
    },
    {
      "Code": "3997",
      "Title": "String URI overloads should call \"System.Uri\" overloads",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3997",
      "Description": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri\nclass is a safe alternative and should be preferred.\nThis rule raises an issue when two overloads differ only by the string / Uri parameter and the string overload doesn’t call the\nUri overload. It is assumed that the string parameter represents a URI because of the exact match besides that parameter type. It stands\nto reason that the safer overload should be used.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class MyClass\n   {\n      public void FetchResource(string uriString) // Noncompliant\n      {\n         // No calls to FetResource(Uri)\n      }\n\n      public void FetchResource(Uri uri) { }\n   }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class MyClass\n   {\n      public void FetchResource(string uriString)\n      {\n          FetchResource(new Uri(uriString));\n      }\n\n      public void FetchResource(Uri uri) { }\n   }\n}\n\n\n"
    },
    {
      "Code": "3996",
      "Title": "URI properties should not be strings",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3996",
      "Description": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri\nclass is a safe alternative and should be preferred.\nThis rule raises an issue when a property is a string type and its name contains \"uri\", \"Uri\", \"urn\", \"Urn\", \"url\" or \"Url\".\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class MyClass\n   {\n      string myUri;\n\n      public string MyUri // Noncompliant\n      {\n         get { return myURI; }\n         set { myUri = value; }\n      }\n   }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class MyClass\n   {\n      Uri myUri;\n\n      public Uri MyUri\n      {\n         get { return myURI; }\n         set { myUri = value; }\n      }\n   }\n}\n\n\n"
    },
    {
      "Code": "3995",
      "Title": "URI return values should not be strings",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3995",
      "Description": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri\nclass is a safe alternative and should be preferred.\nThis rule raises an issue when a method has a string return type and its name contains \"Uri\", \"Urn\", or \"Url\" or begins with \"uri\",\n\"urn\", or \"url\".\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class MyClass\n   {\n      public string GetParentUri() // Noncompliant\n      {\n         return \"http://www.mysite.com\";\n      }\n   }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class MyClass\n   {\n\n      public Uri GetParentUri()\n      {\n         return new URI(\"http://www.mysite.com\");\n      }\n   }\n}\n\n\n"
    },
    {
      "Code": "3994",
      "Title": "URI Parameters should not be strings",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3994",
      "Description": "String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri\nclass is a safe alternative and should be preferred. At minimum, an overload of the method taking a System.Uri as a parameter should be\nprovided in each class that contains a method with an apparent Uri passed as a string.\nThis rule raises issues when a method has a string parameter with a name containing \"uri\", \"Uri\", \"urn\", \"Urn\", \"url\" or \"Url\", and the type\ndoesn’t declare a corresponding overload taking an System.Uri parameter instead.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class MyClass\n   {\n\n      public void FetchResource(string uriString) { } // Noncompliant\n   }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n   public class MyClass\n   {\n\n      public void FetchResource(string uriString)\n      {\n          FetchResource(new Uri(uriString));\n      }\n\n      public void FetchResource(Uri uri) { }\n   }\n}\n\n\n"
    },
    {
      "Code": "3993",
      "Title": "Custom attributes should be marked with \"System.AttributeUsageAttribute\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3993",
      "Description": "When defining custom attributes, System.AttributeUsageAttribute must be used to indicate where the attribute can be applied. This will\ndetermine its valid locations in the code.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n\n   public sealed class MyAttribute :Attribute // Noncompliant\n   {\n      string text;\n\n      public MyAttribute(string myText)\n      {\n         text = myText;\n      }\n      public string Text\n      {\n         get\n         {\n            return text;\n         }\n      }\n   }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n\n   [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Interface | AttributeTargets.Delegate)]\n   public sealed class MyAttribute :Attribute\n   {\n      string text;\n\n      public MyAttribute(string myText)\n      {\n         text = myText;\n      }\n      public string Text\n      {\n         get\n         {\n            return text;\n         }\n      }\n   }\n}\n\n\n"
    },
    {
      "Code": "3992",
      "Title": "Assemblies should explicitly specify COM visibility",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3992",
      "Description": "Assemblies should explicitly indicate whether they are meant to be COM visible or not. If the ComVisibleAttribute is not present, the\ndefault is to make the content of the assembly visible to COM clients.\nNote that COM visibility can be overridden for individual types and members.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary  // Noncompliant\n{\n}\n\nCompliant Solution\n\nusing System;\n\n[assembly: System.Runtime.InteropServices.ComVisible(false)]\nnamespace MyLibrary\n{\n}\n\n\n"
    },
    {
      "Code": "3990",
      "Title": "Assemblies should be marked as CLS compliant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3990",
      "Description": "Assemblies should conform with the Common Language Specification (CLS) in order to be usable across programming languages. To be compliant an\nassembly has to indicate it with System.CLSCompliantAttribute.\nCompliant Solution\n\nusing System;\n\n[assembly:CLSCompliant(true)]\nnamespace MyLibrary\n{\n}\n\n\n"
    },
    {
      "Code": "3956",
      "Title": "\"Generic.List\" instances should not be part of public APIs",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3956",
      "Description": "System.Collections.Generic.List&lt;T&gt; is a generic collection that is designed for performance and not inheritance. For example, it\ndoes not contain virtual members that make it easier to change the behavior of an inherited class. That means that future attempts to expand the\nbehavior will be spoiled because the extension points simply aren’t there. Instead, one of the following generic collections should be used:\n\n   System.Collections.Generic.IEnumerable&lt;T&gt; \n   System.Collections.Generic.IReadOnlyCollection&lt;T&gt; \n   System.Collections.Generic.ICollection&lt;TKey&gt; \n   System.Collections.Generic.IReadOnlyList&lt;T&gt; \n   System.Collections.Generic.IList&lt;TKey&gt; \n   System.Collections.ObjectModel.Collection&lt;T&gt; \n   System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; \n   System.Collections.ObjectModel.KeyedCollection&lt;TKey, Titem&gt; \n\nThis rule raises an issue every time a System.Collections.Generic.List&lt;T&gt; is exposed:\n\n   As an externally visible member. \n   As the return type of an externally visible method. \n   As a parameter type of an an externally visible method. \n\nNoncompliant Code Example\n\nnamespace Foo\n{\n   public class Bar\n   {\n      public List&lt;T&gt; Method1(T arg) // Noncompliant\n      {\n           //...\n      }\n   }\n}\n\nCompliant Solution\n\nnamespace Foo\n{\n   public class Bar\n   {\n      public Collection&lt;T&gt; Method1(T arg)\n      {\n           //...\n      }\n   }\n}\n\n\n"
    },
    {
      "Code": "3909",
      "Title": "Collections should implement the generic interface",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3909",
      "Description": "The NET Framework 2.0 introduced the generic interface System.Collections.Generic.IEnumerable&lt;T&gt; and it should be preferred over\nthe older, non generic, interfaces.\nThis rule raises an issue when a public type implements System.Collections.IEnumerable.\nNoncompliant Code Example\n\nusing System;\nusing System.Collections;\n\npublic class MyData\n{\n  public MyData()\n  {\n  }\n}\n\npublic class MyList : CollectionBase // Noncompliant\n{\n  public void Add(MyData data)\n  {\n    InnerList.Add(data);\n  }\n\n  // ...\n}\n\nCompliant Solution\n\nusing System;\nusing System.Collections.ObjectModel;\n\npublic class MyData\n{\n  public MyData()\n  {\n  }\n}\n\npublic class MyList : Collection&lt;MyData&gt;\n{\n  // Implementation...\n}\n\n\n"
    },
    {
      "Code": "3908",
      "Title": "Generic event handlers should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3908",
      "Description": "Since .Net Framework version 2.0 it is not necessary to declare a delegate that specifies a class derived from System.EventArgs. The\nSystem.EventHandler&lt;TEventArgs&gt; delegate mechanism should be used instead as it allows any class derived from\nEventArgs to be used with that handler.\nThis rule raises an issue when an old style delegate is used as an event handler.\nNoncompliant Code Example\n\npublic class MyEventArgs : EventArgs\n{\n}\n\npublic delegate void MyEventHandler(object sender, MyEventArgs e); // Noncompliant\n\npublic class EventProducer\n{\n  public event MyEventHandler MyEvent;\n\n  protected virtual void OnMyEvent(MyEventArgs e)\n  {\n    if (MyEvent != null)\n    {\n      MyEvent(e);\n    }\n  }\n}\n\npublic class EventConsumer\n{\n  public EventConsumer(EventProducer producer)\n  {\n      producer.MyEvent += HandleEvent;\n  }\n\n  private void HandleEvent(object sender, MyEventArgs e)\n  {\n    // Do something...\n  }\n}\n\nCompliant Solution\n\npublic class MyEventArgs : EventArgs\n{\n}\n\npublic class EventProducer\n{\n  public event EventHandler&lt;MyEventArgs&gt; MyEvent;\n\n  protected virtual void OnMyEvent(MyEventArgs e)\n  {\n    if (MyEvent != null)\n    {\n      MyEvent(e);\n    }\n  }\n}\n\npublic class EventConsumer\n{\n  public EventConsumer(EventProducer producer)\n  {\n      producer.MyEvent += HandleEvent;\n  }\n\n  private void HandleEvent(object sender, MyEventArgs e)\n  {\n    // Do something...\n  }\n}\n\n\n"
    },
    {
      "Code": "3906",
      "Title": "Event Handlers should have the correct signature",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3906",
      "Description": "Delegate event handlers (i.e. delegates used as type of an event) should have a very specific signature:\n\n   Return type void. \n   First argument of type System.Object and named 'sender'. \n   Second argument of type System.EventArgs (or any derived type) and is named 'e'. \n\nThis rule raises an issue whenever a delegate declaration doesn’t match that signature.\nNoncompliant Code Example\n\npublic delegate void AlarmEventHandler(object s);\n\npublic class Foo\n{\n    public event AlarmEventHandler AlarmEvent; // Noncompliant\n}\n\nCompliant Solution\n\npublic delegate void AlarmEventHandler(object sender, AlarmEventArgs e);\n\npublic class Foo\n{\n    public event AlarmEventHandler AlarmEvent; // Compliant\n}\n\nSee\nHandling and Raising Events\n\n"
    },
    {
      "Code": "3902",
      "Title": "\"Assembly.GetExecutingAssembly\" should not be called",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3902",
      "Description": "Using Type.Assembly to get the current assembly is nearly free in terms of performance; it’s a simple property access. On the other\nhand, Assembly.GetExecutingAssembly() can take up to 30 times as long because it walks up the call stack to find the assembly.\nNote that Assembly.GetExecutingAssembly() is different than Type.Assembly because it dynamically returns the assembly\nthat contains the startup object of the currently executed application. For example, if executed from an application it will return the application\nassembly, but if executed from a unit test project it could return the unit test assembly. Type.Assembly always returns the assembly that\ncontains the specified type.\nNoncompliant Code Example\n\npublic class Example\n{\n   public static void Main()\n   {\n      Assembly assem = Assembly.GetExecutingAssembly(); // Noncompliant\n      Console.WriteLine(\"Assembly name: {0}\", assem.FullName);\n   }\n}\n\nCompliant Solution\n\npublic class Example\n{\n   public static void Main()\n   {\n      Assembly assem = typeof(Example).Assembly; // Here we use the type of the current class\n      Console.WriteLine(\"Assembly name: {0}\", assem.FullName);\n   }\n}\n\n\n"
    },
    {
      "Code": "3900",
      "Title": "Arguments of public methods should be validated against null",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3900",
      "Description": "A publicly accessible method can be called from anywhere, which means you should validate parameters to be within the expected constraints. In\ngeneral, checking against null is recommended defensive programming.\nThis rule raises an issue when a parameter of a publicly accessible method is not validated against null before being\ndereferenced.\nNoncompliant Code Example\n\npublic class MyClass\n{\n    private MyOtherClass other;\n\n    public void Foo(MyOtherClass other)\n    {\n        this.other = other; // Compliant: other not being dereferenced\n    }\n\n    public void Bar(MyOtherClass other)\n    {\n        this.other = other.Clone(); // Noncompliant\n    }\n\n    protected void FooBar(MyOtherClass other)\n    {\n        this.other = other.Clone(); // Noncompliant\n    }\n}\n\nCompliant Solution\n\npublic class MyClass\n{\n    private MyOtherClass other;\n\n    public void Foo(MyOtherClass other)\n    {\n        this.other = other;\n    }\n\n    public void Bar(MyOtherClass other)\n    {\n        if (other != null)\n        {\n            this.other = other.Clone();\n        }\n    }\n\n    protected void FooBar(MyOtherClass other)\n    {\n        if (other != null)\n        {\n            this.other = other.Clone();\n        }\n    }\n}\n\nExceptions\nTo create a custom null validation method declare an attribute with name ValidatedNotNullAttribute and mark the parameter that is\nvalidated for null in your method declaration with it:\n\nusing System;\n\npublic sealed class ValidatedNotNullAttribute : Attribute { }\n\npublic static class Guard\n{\n    public static void NotNull&lt;T&gt;([ValidatedNotNullAttribute] this T value, string name) where T : class\n    {\n        if (value == null)\n            throw new ArgumentNullException(name);\n    }\n}\n\npublic static class Utils\n{\n    public static string ToUpper(string value)\n    {\n        Guard.NotNull(value, nameof(value));\n        if (value == null)\n        {\n            return value.ToString();\n        }\n        return value.ToUpper(); // Compliant\n    }\n}\n\n\n"
    },
    {
      "Code": "3898",
      "Title": "Value types should implement \"IEquatable\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3898",
      "Description": "If you’re using a struct, it is likely because you’re interested in performance. But by failing to implement\nIEquatable&lt;T&gt; you’re loosing performance when comparisons are made because without IEquatable&lt;T&gt;, boxing and\nreflection are used to make comparisons.\nNoncompliant Code Example\n\nstruct MyStruct  // Noncompliant\n{\n  private int i;\n  public int I\n  {\n    //...\n  }\n}\n\nCompliant Solution\n\nstruct MyStruct : IEquatable&lt;MyStruct&gt;\n{\n  private int i;\n  public int I\n  {\n    //...\n  }\n\n  public bool Equals(MyStruct other)\n  {\n    throw new NotImplementedException();\n  }\n}\n\n\n"
    },
    {
      "Code": "3880",
      "Title": "Finalizers should not be empty",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3880",
      "Description": "Finalizers come with a performance cost due to the overhead of tracking the life cycle of objects. An empty one is consequently costly with no\nbenefit or justification.\nNoncompliant Code Example\n\npublic class Foo\n{\n    ~Foo() // Noncompliant\n    {\n    }\n}\n\n\n"
    },
    {
      "Code": "3431",
      "Title": "\"[ExpectedException]\" should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3431",
      "Description": "It should be clear to a casual reader what code a test is testing and what results are expected. Unfortunately, that’s not usually the case with\nthe ExpectedException attribute since an exception could be thrown from almost any line in the method.\nThis rule detects MSTest and NUnit ExpectedException attribute.\nNoncompliant Code Example\n\n[TestMethod]\n[ExpectedException(typeof(ArgumentNullException))]  // Noncompliant\npublic void TestNullArg()\n{\n  //...\n}\n\nCompliant Solution\n\n[TestMethod]\npublic void TestNullArg()\n{\n  bool callFailed = false;\n  try\n  {\n    //...\n  }\n  catch (ArgumentNullException)\n  {\n    callFailed = true;\n  }\n  Assert.IsTrue(callFailed, \"Expected call to MyMethod to fail with ArgumentNullException\");\n}\n\nor\n\n[TestMethod]\npublic void TestNullArg()\n{\n  Assert.ThrowsException&lt;ArgumentNullException&gt;(() =&gt; /*...*/);\n}\n\nExceptions\nThis rule ignores one-line test methods, since it is obvious in such methods where the exception is expected to be thrown.\n\n"
    },
    {
      "Code": "3366",
      "Title": "\"this\" should not be exposed from constructors",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3366",
      "Description": "In single-threaded environments, the use of this in constructors is normal, and expected. But in multi-threaded environments, it could\nexpose partially-constructed objects to other threads, and should be used with caution.\nThe classic example is a class with a static list of its instances. If the constructor stores this in the list, another\nthread could access the object before it’s fully-formed. Even when the storage of this is the last instruction in the constructor,\nthere’s still a danger if the class is not final. In that case, the initialization of subclasses won’t be complete before\nthis is exposed.\nThis rule raises an issue when this is assigned to any globally-visible object in a constructor, and when it is passed to the method\nof another object in a constructor\nNoncompliant Code Example\n\npublic class Monument\n{\n  public static readonly List&lt;Monument&gt; ALL_MONUMENTS = new List&lt;Monument&gt;();\n  // ...\n\n  public Monument(string location, ...)\n  {\n    ALL_MONUMENTS.Add(this);  // Noncompliant; passed to a method of another object\n\n    this.location = location;\n    // ...\n  }\n}\n\nExceptions\nThis rule ignores instances of assigning this directly to a static field of the same class because that case is covered\nby {rule:csharpsquid:S3010} .\n\n"
    },
    {
      "Code": "3059",
      "Title": "Types should not have members with visibility set higher than the type's visibility",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3059",
      "Description": "There’s no point in having a public member in a non-public type because objects that can’t access the type will never\nhave the chance to access the member.\nThis rule raises an issue when a type has methods, fields, or inner types with higher visibility than the type itself has.\nNoncompliant Code Example\n\ninternal class MyClass\n{\n    public static decimal PI = 3.14m;  // Noncompliant\n\n    public int GetOne() // Noncompliant\n    {\n        return 1;\n    }\n\n    protected record NestedType // Noncompliant: outer class is internal\n    {\n        public bool FlipCoin() // Noncompliant: outer class is internal\n        {\n            return false;\n        }\n        // ...\n    }\n}\n\nCompliant Solution\n\npublic class MyClass // Class visibility upgrade makes members compliant\n{\n    public static decimal PI = 3.14m;\n\n    public int GetOne()\n    {\n        return 1;\n    }\n\n    protected record NestedType\n    {\n        public bool FlipCoin() // Outer type is public\n        {\n            return false;\n        }\n        // ...\n    }\n}\n\nExceptions\nUser defined operators need to be public:\n\npublic static implicit operator byte(MyClass a) =&gt; 1; // Compliant\npublic static explicit operator MyClass(byte a) =&gt; new MyClass(a); // Compliant\n\nNested types, even if private, can be used and inherited in the parent type. In this case, the visibility of the outer type is considered.\n\ninternal class MyClass\n{\n    private class NestedClass\n    {\n        public int PublicProperty { get; } // Noncompliant: should be internal\n        protected internal int ProtectedInternalProperty { get; } // Compliant: can be used in `InternalsVisibleTo` assemblies\n        internal int InternalProperty { get; } // Compliant: can be used in `InternalsVisibleTo` assemblies\n        protected int ProtectedProperty { get; } // Compliant: can be used in derived type\n        private protected int PrivateProtectedProperty { get; } // Compliant: can be used in derived type\n        private int PrivateProperty { get; }\n    }\n}\n\n\n"
    },
    {
      "Code": "2357",
      "Title": "Fields should be private",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2357",
      "Description": "Fields should not be part of an API, and therefore should always be private. Indeed, they cannot be added to an interface for instance, and\nvalidation cannot be added later on without breaking backward compatibility. Instead, developers should encapsulate their fields into properties.\nExplicit property getters and setters can be introduced for validation purposes or to smooth the transition to a newer system.\nNoncompliant Code Example\n\npublic class Foo\n{\n  public int MagicNumber = 42;\n}\n\nCompliant Solution\n\npublic class Foo\n{\n  public int MagicNumber\n  {\n    get { return 42; }\n  }\n}\n\nor\n\npublic class Foo\n{\n  private int MagicNumber = 42;\n}\n\nExceptions\nstructs are ignored, as are static and const fields in classes.\nFurther, an issue is only raised when the real accessibility is public, taking into account the class accessibility.\n\n"
    },
    {
      "Code": "2327",
      "Title": "\"try\" statements with identical \"catch\" and/or \"finally\" blocks should be merged",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2327",
      "Description": "When multiple, adjacent try statements have duplicate catch and/or finally blocks, they should be merged to\nconsolidate the catch/finally logic for cleaner, more readable code. Note that this applies even when there is intervening code outside\nany try block.\nNoncompliant Code Example\n\ntry\n{\n  DoTheFirstThing(a, b);\n}\ncatch (InvalidOperationException ex)\n{\n  HandleException(ex);\n}\n\nDoSomeOtherStuff();\n\ntry  // Noncompliant; catch is identical to previous\n{\n  DoTheSecondThing();\n}\ncatch (InvalidOperationException ex)\n{\n  HandleException(ex);\n}\n\ntry  // Compliant; catch handles exception differently\n{\n  DoTheThirdThing(a);\n}\ncatch (InvalidOperationException ex)\n{\n  LogAndDie(ex);\n}\n\nCompliant Solution\n\ntry\n{\n  DoTheFirstThing(a, b);\n  DoSomeOtherStuff();\n  DoTheSecondThing();\n}\ncatch (InvalidOperationException ex)\n{\n  HandleException(ex);\n}\n\ntry  // Compliant; catch handles exception differently\n{\n  DoTheThirdThing(a);\n}\ncatch (InvalidOperationException ex)\n{\n  LogAndDie(ex);\n}\n\n\n"
    },
    {
      "Code": "1696",
      "Title": "NullReferenceException should not be caught",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1696",
      "Description": "NullReferenceException should be avoided, not caught. Any situation in which NullReferenceException is explicitly caught\ncan easily be converted to a null test, and any behavior being carried out in the catch block can easily be moved to the \"is null\" branch\nof the conditional.\nNoncompliant Code Example\n\npublic int GetLengthPlusTwo(string str)\n{\n    int length = 2;\n    try\n    {\n       length += str.Length;\n    }\n    catch (NullReferenceException e)\n    {\n        log.info(\"argument was null\");\n    }\n    return length;\n}\n\nCompliant Solution\n\npublic int GetLengthPlusTwo(string str)\n{\n    int length = 2;\n\n    if (str != null)\n    {\n        length += str.Length;\n    }\n    else\n    {\n        log.info(\"argument was null\");\n    }\n    return length;\n}\n\nSee\n\n   MITRE, CWE-395 - Use of NullPointerException Catch to Detect NULL Pointer\n  Dereference \n\n\n"
    },
    {
      "Code": "138",
      "Title": "Functions should not have too many lines of code",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-138",
      "Description": "A function that grows too large tends to aggregate too many responsibilities.\nSuch functions inevitably become harder to understand and therefore harder to maintain.\nAbove a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks.\nThose smaller functions will not only be easier to understand, but also probably easier to test.\n\n"
    },
    {
      "Code": "127",
      "Title": "\"for\" loop stop conditions should be invariant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-127",
      "Description": "A for loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and\nending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.\nStop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the\nintroduction of errors in the future.\nThis rule tracks three types of non-invariant stop conditions:\n\n   When the loop counters are updated in the body of the for loop \n   When the stop condition depend upon a method call \n   When the stop condition depends on an object property, since such properties could change during the execution of the loop. \n\nNoncompliant Code Example\n\nclass Foo\n{\n    static void Main()\n    {\n        for (int i = 1; i &lt;= 5; i++)\n        {\n            Console.WriteLine(i);\n            if (condition)\n            {\n               i = 20;\n           }\n        }\n    }\n}\n\nCompliant Solution\n\nclass Foo\n{\n    static void Main()\n    {\n        for (int i = 1; i &lt;= 5; i++)\n        {\n            Console.WriteLine(i);\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "122",
      "Title": "Statements should be on separate lines",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-122",
      "Description": "For better readability, do not put more than one statement on a single line.\nNoncompliant Code Example\n\nif(someCondition) DoSomething();\n\nCompliant Solution\n\nif(someCondition)\n{\n  DoSomething();\n}\n\nExceptions\nAnonymous functions containing a single statement are ignored. Block statements are not considered either.\n\nFunc&lt;object, bool&gt; item1 = o =&gt; { return true; }; // Compliant\nFunc&lt;object, bool&gt; item1 = o =&gt; { var r = false; return r; }; // Noncompliant\n\n\n"
    },
    {
      "Code": "1200",
      "Title": "Classes should not be coupled to too many other classes (Single Responsibility Principle)",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1200",
      "Description": "According to the Single Responsibility Principle, introduced by Robert C. Martin in his book \"Principles of Object Oriented Design\", a class should\nhave only one responsibility:\n\n  If a class has more than one responsibility, then the responsibilities become coupled.\n  Changes to one responsibility may impair or inhibit the class' ability to meet the others.\n  This kind of coupling leads to fragile designs that break in unexpected ways when changed.\n\nClasses which rely on many other classes tend to aggregate too many responsibilities and should be split into several smaller ones.\nNested classes dependencies are not counted as dependencies of the outer class.\nNoncompliant Code Example\nWith a threshold of 5:\n\npublic class Foo    // Noncompliant - Foo depends on too many classes: T1, T2, T3, T4, T5, T6 and T7\n{\n  private T1 a1;    // Foo is coupled to T1\n  private T2 a2;    // Foo is coupled to T2\n  private T3 a3;    // Foo is coupled to T3\n\n  public T4 Compute(T5 a, T6 b)    // Foo is coupled to T4, T5 and T6\n  {\n    T7 result = a.Process(b);    // Foo is coupled to T7\n    return result;\n  }\n\n  public static class Bar    // Compliant - Bar depends on 2 classes: T8 and T9\n  {\n    public T8 a8;\n    public T9 a9;\n  }\n}\n\n\n"
    },
    {
      "Code": "1151",
      "Title": "\"switch case\" clauses should not have too many lines of code",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1151",
      "Description": "The switch statement should be used only to clearly define some new branches in the control flow. As soon as a case\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of the\ncase clause should be extracted into a dedicated method.\nNoncompliant Code Example\nWith the default threshold of 3:\n\nswitch (myVariable)\n{\n    case 0: // Noncompliant: 5 statements in the case\n        methodCall1(\"\");\n        methodCall2(\"\");\n        methodCall3(\"\");\n        methodCall4(\"\");\n        break;\n    case 1:\n        ...\n}\n\nCompliant Solution\n\nswitch (myVariable)\n{\n    case 0:\n        DoSomething()\n        break;\n    case 1:\n        ...\n}\n...\nprivate void DoSomething()\n{\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n}\n\n\n"
    },
    {
      "Code": "109",
      "Title": "Magic numbers should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-109",
      "Description": "A magic number is a number that comes out of nowhere, and is directly used in a statement. Magic numbers are often used, for instance to limit the\nnumber of iterations of a loop, to test the value of a property, etc.\nUsing magic numbers may seem obvious and straightforward when you’re writing a piece of code, but they are much less obvious and straightforward at\ndebugging time.\nThat is why magic numbers must be demystified by first being assigned to clearly named variables before being used.\n-1, 0 and 1 are not considered magic numbers.\nNoncompliant Code Example\n\npublic static void DoSomething()\n{\n    for(int i = 0; i &lt; 4; i++)  // Noncompliant, 4 is a magic number\n    {\n        ...\n    }\n}\n\nCompliant Solution\n\nprivate const int NUMBER_OF_CYCLES = 4;\n\npublic static void DoSomething()\n{\n    for(int i = 0; i &lt; NUMBER_OF_CYCLES ; i++)  //Compliant\n    {\n        ...\n    }\n}\n\nExceptions\nThis rule doesn’t raise an issue when the magic number is used as part of the GetHashCode method or a variable/field declaration.\n\n"
    },
    {
      "Code": "106",
      "Title": "Standard outputs should not be used directly to log anything",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-106",
      "Description": "When logging a message there are several important requirements which must be fulfilled:\n\n   The user must be able to easily retrieve the logs \n   The format of all logged message must be uniform to allow the user to easily read the log \n   Logged data must actually be recorded \n   Sensitive data must only be logged securely \n\nIf a program directly writes to the standard outputs, there is absolutely no way to comply with those requirements. That’s why defining and using a\ndedicated logger is highly recommended.\nNoncompliant Code Example\n\nprivate void DoSomething()\n{\n    // ...\n    Console.WriteLine(\"so far, so good...\"); // Noncompliant\n    // ...\n}\n\nExceptions\nThe following are ignored by this rule:\n\n   Console Applications \n   Calls in methods decorated with [Conditional (\"DEBUG\")] \n   Calls included in DEBUG preprocessor branches (#if DEBUG) \n\n\n"
    },
    {
      "Code": "104",
      "Title": "Files should not have too many lines of code",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-104",
      "Description": "A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to\nmaintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those\nsmaller files will not only be easier to understand but also probably easier to test.\n\n"
    },
    {
      "Code": "103",
      "Title": "Lines should not be too long",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-103",
      "Description": "Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.\n\n"
    },
    {
      "Code": "5167",
      "Title": "HTTP response headers should not be vulnerable to injection attacks",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-5167",
      "Description": "User provided data, such as URL parameters, POST data payloads, or cookies, should always be considered untrusted and tainted. Applications\nconstructing HTTP response headers based on tainted data could allow attackers to change security sensitive headers like Cross-Origin Resource Sharing\nheaders.\nWeb application frameworks and servers might also allow attackers to inject new line characters in headers to craft malformed HTTP response. In\nthis case the application would be vulnerable to a larger range of attacks like HTTP Response Splitting/Smuggling. Most of the time this type of\nattack is mitigated by default modern web application frameworks but there might be rare cases where older versions are still vulnerable.\nAs a best practice, applications that use user provided data to construct the response header should always validate the data first. Validation\nshould be based on a whitelist.\nNoncompliant Code Example\n\nstring value = Request.QueryString[\"value\"];\nResponse.AddHeader(\"X-Header\", value); // Noncompliant\n\nCompliant Solution\n\nstring value = Request.QueryString[\"value\"];\n// Allow only alphanumeric characters\nif (value == null || !Regex.IsMatch(value, \"^[a-zA-Z0-9]+$\"))\n{\n  throw new Exception(\"Invalid value\");\n}\nResponse.AddHeader(\"X-Header\", value);\n\nSee\n\n   OWASP Top 10 2021 Category A3 - Injection \n   OWASP Attack Category - HTTP Response Splitting \n   MITRE, CWE-20 - Improper Input Validation \n   MITRE, CWE-113 - Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP\n  Response Splitting') \n   SANS Top 25 - Insecure Interaction Between Components \n\nDeprecated\nThis rule is deprecated; use {rule:csharpsquid:S5122}, {rule:csharpsquid:S5146}, {rule:csharpsquid:S6287} instead.\n\n"
    },
    {
      "Code": "2228",
      "Title": "Console logging should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2228",
      "Description": "Debug statements are always useful during development. But include them in production code - particularly in code that runs client-side - and you\nrun the risk of inadvertently exposing sensitive information.\nNoncompliant Code Example\n\nprivate void DoSomething()\n{\n    // ...\n    Console.WriteLine(\"so far, so good...\"); // Noncompliant\n    // ...\n}\n\nExceptions\nThe following are ignored by this rule:\n\n   Console Applications \n   Calls in methods decorated with [Conditional (\"DEBUG\")] \n   Calls included in DEBUG preprocessor branches (#if DEBUG) \n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n\nDeprecated\nThis rule is deprecated; use {rule:csharpsquid:S106} instead.\n\n"
    },
    {
      "Code": "2955",
      "Title": "Generic parameters not constrained to reference types should not be compared to \"null\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2955",
      "Description": "When constraints have not been applied to restrict a generic type parameter to be a reference type, then a value type, such as a\nstruct, could also be passed. In such cases, comparing the type parameter to null would always be false, because a\nstruct can be empty, but never null. If a value type is truly what’s expected, then the comparison should use\ndefault(). If it’s not, then constraints should be added so that no value type can be passed.\nNoncompliant Code Example\n\nprivate bool IsDefault&lt;T&gt;(T value)\n{\n  if (value == null) // Noncompliant\n  {\n    // ...\n  }\n  // ...\n}\n\nCompliant Solution\n\nprivate bool IsDefault&lt;T&gt;(T value)\n{\n  if(object.Equals(value, default(T)))\n  {\n    // ...\n  }\n  // ...\n}\n\nor\n\nprivate bool IsDefault&lt;T&gt;(T value) where T : class\n{\n  if (value == null)\n  {\n    // ...\n  }\n  // ...\n}\n\n\n"
    },
    {
      "Code": "2674",
      "Title": "The length returned from a stream read should be checked",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2674",
      "Description": "You cannot assume that any given stream reading call will fill the byte[] passed in to the method with the number of bytes requested.\nInstead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both\nharmful and difficult to reproduce.\nThis rule raises an issue when a Stream.Read or a Stream.ReadAsync method is called, but the return value is not\nchecked.\nNoncompliant Code Example\n\npublic void DoSomething(string fileName)\n{\n  using (var stream = File.Open(fileName, FileMode.Open))\n  {\n    var result = new byte[stream.Length];\n    stream.Read(result, 0, (int)stream.Length); // Noncompliant\n    // ... do something with result\n  }\n}\n\nCompliant Solution\n\npublic void DoSomething(string fileName)\n{\n  using (var stream = File.Open(fileName, FileMode.Open))\n  {\n    var buffer = new byte[1024];\n    using (var ms = new MemoryStream())\n    {\n        int read;\n        while ((read = stream.Read(buffer, 0, buffer.Length)) &gt; 0)\n        {\n            ms.Write(buffer, 0, read);\n        }\n        // ... do something with ms\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "1226",
      "Title": "Method parameters, caught exceptions and foreach variables' initial values should not be ignored",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1226",
      "Description": "While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug.\nInstead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as final, then at least read\nbefore reassignment.\nNoncompliant Code Example\n\npublic void DoTheThing(string str, int i, List&lt;string&gt; strings)\n{\n  str = i.ToString(i);  // Noncompliant\n\n  foreach (var s in strings)\n  {\n    s = \"hello world\";  // Noncompliant\n  }\n}\n\n\n"
    },
    {
      "Code": "4834",
      "Title": "Controlling permissions is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4834",
      "Description": "The access control of an application must be properly implemented in order to restrict access to resources to authorized entities otherwise this\ncould lead to vulnerabilities:\n\n   CVE-2018-12999 \n   CVE-2018-10285 \n   CVE-2017-7455 \n\nGranting correct permissions to users, applications, groups or roles and defining required permissions that allow access to a resource is\nsensitive, must therefore be done with care. For instance, it is obvious that only users with administrator privilege should be authorized to\nadd/remove the administrator permission of another user.\nAsk Yourself Whether\n\n   Granted permission to an entity (user, application) allow access to information or functionalities not needed by this entity. \n   Privileges are easily acquired (eg: based on the location of the user, type of device used, defined by third parties, does not require approval\n  …​). \n   Inherited permission, default permission, no privileges (eg: anonymous user) is authorized to access to a protected resource. \n\nThere is a risk if you answered yes to any of those questions.\nRecommended Secure Coding Practices\nAt minimum, an access control system should:\n\n   Use a well-defined access control model like RBAC or ACL. \n   Entities' permissions should be reviewed regularly to remove permissions that are no longer needed. \n   Respect the principle of least privilege (\"an entity has access\n  only the information and resources that are necessary for its legitimate purpose\"). \n\nSensitive Code Example\n\nusing System.Threading;\nusing System.Security.Permissions;\nusing System.Security.Principal;\nusing System.IdentityModel.Tokens;\n\nclass SecurityPrincipalDemo\n{\n    class MyIdentity : IIdentity // Sensitive, custom IIdentity implementations should be reviewed\n    {\n        // ...\n    }\n\n    class MyPrincipal : IPrincipal // Sensitive, custom IPrincipal implementations should be reviewed\n    {\n        // ...\n    }\n    [System.Security.Permissions.PrincipalPermission(SecurityAction.Demand, Role = \"Administrators\")] // Sensitive. The access restrictions enforced by this attribute should be reviewed.\n    static void CheckAdministrator()\n    {\n        WindowsIdentity MyIdentity = WindowsIdentity.GetCurrent(); // Sensitive\n        HttpContext.User = ...; // Sensitive: review all reference (set and get) to System.Web HttpContext.User\n        AppDomain domain = AppDomain.CurrentDomain;\n        domain.SetPrincipalPolicy(PrincipalPolicy.WindowsPrincipal); // Sensitive\n        MyIdentity identity = new MyIdentity(); // Sensitive\n        MyPrincipal MyPrincipal = new MyPrincipal(MyIdentity); // Sensitive\n        Thread.CurrentPrincipal = MyPrincipal; // Sensitive\n        domain.SetThreadPrincipal(MyPrincipal); // Sensitive\n\n        // All instantiation of PrincipalPermission should be reviewed.\n        PrincipalPermission principalPerm = new PrincipalPermission(null, \"Administrators\"); // Sensitive\n        principalPerm.Demand();\n\n        SecurityTokenHandler handler = ...;\n        // Sensitive: this creates an identity.\n        ReadOnlyCollection&lt;ClaimsIdentity&gt; identities = handler.ValidateToken(…);\n    }\n\n     // Sensitive: review how this function uses the identity and principal.\n    void modifyPrincipal(MyIdentity identity, MyPrincipal principal)\n    {\n        // ...\n    }\n}\n\nSee\n\n   OWASP Top 10 2017 Category A5 - Boken Access Control \n   SANS Top 25 - Porous Defenses \n   MITRE, CWE-276 - Incorrect Default Permissions \n   MITRE, CWE-732 - Incorrect Permission Assignment for Critical Resource \n   MITRE, CWE-668 - Exposure of Resource to Wrong Sphere \n   MITRE, CWE-277 - Insecure Inherited Permissions \n\nDeprecated\nThis rule is deprecated, and will eventually be removed.\n\n"
    },
    {
      "Code": "2255",
      "Title": "Writing cookies is security-sensitive",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2255",
      "Description": "Using cookies is security-sensitive. It has led in the past to the following vulnerabilities:\n\n   CVE-2018-11639 \n   CVE-2016-6537 \n\nAttackers can use widely-available tools to read cookies. Any sensitive information they may contain will be exposed.\nThis rule flags code that writes cookies.\nAsk Yourself Whether\n\n   sensitive information is stored inside the cookie. \n\nYou are at risk if you answered yes to this question.\nRecommended Secure Coding Practices\nCookies should only be used to manage the user session. The best practice is to keep all user-related information server-side and link them to the\nuser session, never sending them to the client. In a very few corner cases, cookies can be used for non-sensitive information that need to live longer\nthan the user session.\nDo not try to encode sensitive information in a non human-readable format before writing them in a cookie. The encoding can be reverted and the\noriginal information will be exposed.\nUsing cookies only for session IDs doesn’t make them secure. Follow OWASP best practices when you configure your cookies.\nAs a side note, every information read from a cookie should be Sanitized.\nSensitive Code Example\n\n// === .Net Framework ===\n\nHttpCookie myCookie = new HttpCookie(\"UserSettings\");\nmyCookie[\"CreditCardNumber\"] = \"1234 1234 1234 1234\"; // Sensitive; sensitive data stored\nmyCookie.Values[\"password\"] = \"5678\"; // Sensitive\nmyCookie.Value = \"mysecret\"; // Sensitive\n...\nResponse.Cookies.Add(myCookie);\n\n\n// === .Net Core ===\n\nResponse.Headers.Add(\"Set-Cookie\", ...); // Sensitive\nResponse.Cookies.Append(\"mykey\", \"myValue\"); // Sensitive\n\nSee\n\n   OWASP Top 10 2017 Category A3 - Sensitive Data Exposure\n  \n   MITRE, CWE-312 - Cleartext Storage of Sensitive Information \n   MITRE, CWE-315 - Cleartext Storage of Sensitive Information in a Cookie \n   Derived from FindSecBugs rule COOKIE_USAGE \n\nDeprecated\nThis rule is deprecated, and will eventually be removed.\n\n"
    },
    {
      "Code": "4261",
      "Title": "Methods should be named according to their synchronicities",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4261",
      "Description": "According to the Task-based Asynchronous Pattern (TAP), methods returning either a System.Threading.Tasks.Task or a\nSystem.Threading.Tasks.Task&lt;TResult&gt; are considered \"asynchronous\". Such methods should use the Async suffix.\nConversely methods which do not return such Tasks should not have an \"Async\" suffix in their names.\nNoncompliant Code Example\n\nusing System;\nusing  System.Threading.Tasks;\n\nnamespace myLibrary\n{\n\n  public class Foo\n  {\n    public Task Read(byte [] buffer, int offset, int count, // Noncompliant\n                                CancellationToken cancellationToken)\n  }\n}\n\nCompliant Solution\n\nusing System;\nusing  System.Threading.Tasks;\n\nnamespace myLibrary\n{\n\n  public class Foo\n  {\n    public Task ReadAsync(byte [] buffer, int offset, int count, CancellationToken cancellationToken)\n  }\n}\n\nExceptions\nThis rule doesn’t raise an issue when the method is an override or part of the implementation of an interface since it can not be renamed.\nSee\n\n   Task-based\n  Asynchronous Pattern \n\n\n"
    },
    {
      "Code": "4226",
      "Title": "Extensions should be in separate namespaces",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4226",
      "Description": "It makes little sense to create an extension method when it is possible to just add that method to the class itself.\nThis rule raises an issue when an extension is declared in the same namespace as the class it is extending.\nNoncompliant Code Example\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        // ...\n    }\n\n    public static class MyExtensions\n    {\n        public static void Bar(this Foo a) // Noncompliant\n        {\n            // ...\n        }\n    }\n}\n\nCompliant Solution\nUsing separate namespace:\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        // ...\n    }\n}\n\nnamespace Helpers\n{\n    public static class MyExtensions\n    {\n        public static void Bar(this Foo a)\n        {\n            // ...\n        }\n    }\n}\n\nMerging the method in the class:\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        // ...\n        public void Bar()\n        {\n            // ...\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "4225",
      "Title": "Extension methods should not extend \"object\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4225",
      "Description": "Creating an extension method that extends object is not recommended because it makes the method available on every type.\nExtensions should be applied at the most specialized level possible, and that is very unlikely to be object.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n    public static class MyExtensions\n    {\n        public static void Foo(this object o)  //Noncompliant\n        {\n            // ...\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "4069",
      "Title": "Operator overloads should have named alternatives",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4069",
      "Description": "Operator overloading is convenient but unfortunately not portable across languages. To be able to access the same functionality from another\nlanguage you need to provide an alternate named method following the convention:\n\n  \n    \n    \n  \n  \n    \n      Operator\n      Method Name\n    \n  \n  \n    \n      + (binary)\n      Add\n    \n    \n      &amp;\n      BitwiseAnd\n    \n    \n      |\n      BitwiseOr\n    \n    \n      /\n      Divide\n    \n    \n      ==\n      Equals\n    \n    \n      ^\n      Xor\n    \n    \n      &gt;\n      Compare\n    \n    \n      &gt;=\n      Compare\n    \n    \n      !=\n      Equals\n    \n    \n      &lt;\n      Compare\n    \n    \n      &lt;=\n      Compare\n    \n    \n      !\n      LogicalNot\n    \n    \n      %\n      Mod\n    \n    \n      * (binary)\n      Multiply\n    \n    \n      ~\n      OnesComplement\n    \n    \n      - (binary)\n      Subtract\n    \n    \n      - (unary)\n      Negate\n    \n    \n      + (unary)\n      Plus\n    \n  \n\nThis rule raises an issue when there is an operator overload without the expected named alternative method.\nExceptions\nThis rule does not raise an issue when the class implementing the comparison operators &gt;, &lt;, &gt;= and\n&lt;= contains a method named CompareTo.\n\n"
    },
    {
      "Code": "4060",
      "Title": "Non-abstract attributes should be sealed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4060",
      "Description": "The .NET framework class library provides methods for retrieving custom attributes. Sealing the attribute eliminates the search through the\ninheritance hierarchy, and can improve performance.\nThis rule raises an issue when a public type inherits from System.Attribute, is not abstract, and is not sealed.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct)]\n    public class MyAttribute: Attribute // Noncompliant\n    {\n        private string nameValue;\n        public MyAttribute(string name)\n        {\n            nameValue = name;\n        }\n\n        public string Name\n        {\n            get\n            {\n                return nameValue;\n            }\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Struct)]\n    public sealed class MyAttribute: Attribute\n    {\n        private string nameValue;\n        public MyAttribute(string name)\n        {\n            nameValue = name;\n        }\n\n        public string Name\n        {\n            get\n            {\n                return nameValue;\n            }\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "4058",
      "Title": "Overloads with a \"StringComparison\" parameter should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4058",
      "Description": "Many string operations, the Compare and Equals methods in particular, provide an overload that accepts a\nStringComparison enumeration value as a parameter. Calling these overloads and explicitly providing this parameter makes your code\nclearer and easier to maintain.\nThis rule raises an issue when a string comparison operation doesn’t use the overload that takes a StringComparison parameter.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public bool HaveSameNames(string name1, string name2)\n    {\n      return string.Compare(name1, name2) == 0; // Noncompliant\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public bool HaveSameNames(string name1, string name2)\n    {\n      return string.Compare(name1, name2, StringComparison.OrdinalIgnoreCase) == 0;\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "4056",
      "Title": "Overloads with a \"CultureInfo\" or an \"IFormatProvider\" parameter should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4056",
      "Description": "When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by\nthe overloaded member might not have the effect that you want in all locales.\nYou should supply culture-specific information according to the following guidelines:\n\n   If the value will be displayed to the user, use the current culture. See CultureInfo.CurrentCulture. \n   If the value will be stored and accessed by software (persisted to a file or database), use the invariant culture. See\n  CultureInfo.InvariantCulture. \n   If you do not know the destination of the value, have the data consumer or provider specify the culture. \n\nThis rule raises an issue when a method or constructor calls one or more members that have overloads that accept a\nSystem.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider\nparameter. This rule ignores calls to .NET Framework methods that are documented as ignoring the IFormatProvider parameter as well as the\nfollowing methods:\n\n   Activator.CreateInstance \n   ResourceManager.GetObject \n   ResourceManager.GetString \n\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public void Bar(String string1)\n        {\n            if(string.Compare(string1, string2, false) == 0) // Noncompliant\n            {\n                Console.WriteLine(string3.ToLower()); // Noncompliant\n            }\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Globalization;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        public void Bar(String string1, String string2, String string3)\n        {\n            if(string.Compare(string1, string2, false,\n                              CultureInfo.InvariantCulture) == 0)\n            {\n                Console.WriteLine(string3.ToLower(CultureInfo.CurrentCulture));\n            }\n        }\n    }\n}\n\nExceptions\nThis rule will not raise an issue when the overload is marked as obsolete.\n\n"
    },
    {
      "Code": "4052",
      "Title": "Types should not extend outdated base types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4052",
      "Description": "With the advent of .NET framework version 2, certain practices have become obsolete.\nIn particular, exceptions should now extend System.Exception instead of System.ApplicationException. Similarly, generic\ncollections should be used instead of the older, non-generic, ones. Finally when creating an XML view, you should not extend\nSystem.Xml.XmlDocument.\nThis rule raises an issue when an externally visible type extends one of these types:\n\n   System.ApplicationException \n   System.Xml.XmlDocument \n   System.Collections.CollectionBase \n   System.Collections.DictionaryBase \n   System.Collections.Queue \n   System.Collections.ReadOnlyCollectionBase \n   System.Collections.SortedList \n   System.Collections.Stack \n\nNoncompliant Code Example\n\nusing System;\nusing System.Collections;\n\nnamespace MyLibrary\n{\n  public class MyCollection : CollectionBase  // Noncompliant\n  {\n  }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Collections;\n\nnamespace MyLibrary\n{\n  public class MyCollection : Collection&lt;T&gt;\n  {\n  }\n}\n\n\n"
    },
    {
      "Code": "4049",
      "Title": "Properties should be preferred",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4049",
      "Description": "Properties are accessed like fields which makes them easier to use.\nThis rule raises an issue when the name of a public or protected method starts with Get, takes no parameter,\nand returns a value that is not an array.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        private string name;\n\n        public string GetName()  // Noncompliant\n        {\n            return name;\n        }\n    }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n    public class Foo\n    {\n        private string name;\n\n        public string Name\n        {\n            get\n            {\n                return name;\n            }\n        }\n    }\n}\n\nExceptions\nThe rule doesn’t raise an issue when the method:\n\n   Is a constructor \n   Is an override \n   Is an interface implementation \n   Is async \n   Returns Task, Task&lt;T&gt; \n   Is named GetEnumerator, GetAwaiter \n\n\n"
    },
    {
      "Code": "4047",
      "Title": "Generics should be used when appropriate",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4047",
      "Description": "When a reference parameter (keyword ref) is used, the passed argument type must exactly match the reference parameter type. This means\nthat to be able to pass a derived type, it must be cast and assigned to a variable of the proper type. Use of generic methods eliminates that\ncumbersome down casting and should therefore be preferred.\nThis rule raises an issue when a method contains a ref parameter of type System.Object.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void Bar(ref object o1, ref object o2) // Noncompliant\n    {\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void Bar&lt;T&gt;(ref T ref1, ref T ref2)\n    {\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "4041",
      "Title": "Type names should not match namespaces",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4041",
      "Description": "When a type name matches the name of a publicly defined namespace, for instance one in the .NET framework class library, it leads to confusion and\nmakes the library that much harder to use.\nThis rule raises an issue when a name of a public type matches the name of a .NET Framework namespace, or a namespace of the project assembly, in a\ncase-insensitive comparison.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Text   // Noncompliant: Collides with System.Text\n  {\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class MyText\n  {\n  }\n}\n\n\n"
    },
    {
      "Code": "4040",
      "Title": "Strings should be normalized to uppercase",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4040",
      "Description": "Certain characters, once normalized to lowercase, cannot make a round trip. That is, they can not be converted from one locale to another and then\naccurately restored to their original characters.\nIt is therefore strongly recommended to normalize characters and strings to uppercase instead.\nNoncompliant Code Example\n\nThread.CurrentThread.CurrentCulture = new CultureInfo(\"tr-TR\");\nvar areStringEqual = \"INTEGER\".ToLower() == \"integer\"; // Noncompliant, the result is false as the ToLower will resolve to \"ınteger\"\nvar areCharEqual = char.ToLower('I') == 'i'; // Noncompliant, the result is false as the ToLower will resolve to \"ı\"\n\nvar incorrectRoundtrip = \"İ\".ToLowerInvariant().ToUpper() == \"I\".ToLowerInvariant().ToUpper(); // Noncompliant, because of the lower we lose the information about the correct uppercase character\n\nCompliant Solution\n\nThread.CurrentThread.CurrentCulture = new CultureInfo(\"tr-TR\");\nvar areStringEqual = \"ınteger\".ToUpperInvariant() == \"ıNTEGER\";\nvar areCharEqual = char.ToUpperInvariant('ı') == 'ı';\nvar correctRoundtrip = \"İ\".ToUpperInvariant().ToLower() != \"I\".ToUpperInvariant().ToLower();\n\nSee\n\n   Internationalization for Turkish \n   How to correctly normalize\n  strings \n   Best Practices\n  for Using Strings in .NET \n\n\n"
    },
    {
      "Code": "4027",
      "Title": "Exceptions should provide standard constructors",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4027",
      "Description": "Exceptions types should provide the following constructors:\n\n   public MyException() \n   public MyException(string) \n   public MyException(string, Exception) \n   protected or private MyException(SerializationInfo, StreamingContext) \n\nThat fourth constructor should be protected in unsealed classes, and private in sealed classes.\nNot having this full set of constructors can make it difficult to handle exceptions.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class MyException // Noncompliant: several constructors are missing\n  {\n    public MyException()\n    {\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\nusing System.Runtime.Serialization;\n\nnamespace MyLibrary\n{\n  public class MyException : Exception\n  {\n      public MyException()\n      {\n      }\n\n      public MyException(string message)\n          :base(message)\n      {\n      }\n\n      public MyException(string message, Exception innerException)\n          : base(message, innerException)\n      {\n      }\n\n      protected MyException(SerializationInfo info, StreamingContext context)\n          : base(info, context)\n      {\n      }\n  }\n}\n\n\n"
    },
    {
      "Code": "4026",
      "Title": "Assemblies should be marked with \"NeutralResourcesLanguageAttribute\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4026",
      "Description": "It is important to inform the ResourceManager of the language used to display the resources of the neutral culture for an assembly.\nThis improves lookup performance for the first resource loaded.\nThis rule raises an issue when an assembly contains a ResX-based resource but does not have the\nSystem.Resources.NeutralResourcesLanguageAttribute applied to it.\nNoncompliant Code Example\n\nusing System;\n\npublic class MyClass // Noncompliant\n{\n   public static void Main()\n   {\n      string[] cultures = { \"de-DE\", \"en-us\", \"fr-FR\" };\n      Random rnd = new Random();\n      int index = rnd.Next(0, cultures.Length);\n      Thread.CurrentThread.CurrentUICulture = CultureInfo.CreateSpecificCulture(cultures[index]);\n\n      ResourceManager rm = new ResourceManager(\"MyResources\" ,\n                                               typeof(MyClass).Assembly);\n      string greeting = rm.GetString(\"Greeting\");\n\n      Console.Write(\"Enter your name: \");\n      string name = Console.ReadLine();\n      Console.WriteLine(\"{0} {1}!\", greeting, name);\n   }\n}\n\nCompliant Solution\n\nusing System;\n\n[assembly:NeutralResourcesLanguageAttribute(\"en\")]\npublic class MyClass\n{\n   public static void Main()\n   {\n      string[] cultures = { \"de-DE\", \"en-us\", \"fr-FR\" };\n      Random rnd = new Random();\n      int index = rnd.Next(0, cultures.Length);\n      Thread.CurrentThread.CurrentUICulture = CultureInfo.CreateSpecificCulture(cultures[index]);\n\n      ResourceManager rm = new ResourceManager(\"MyResources\" ,\n                                               typeof(MyClass).Assembly);\n      string greeting = rm.GetString(\"Greeting\");\n\n      Console.Write(\"Enter your name: \");\n      string name = Console.ReadLine();\n      Console.WriteLine(\"{0} {1}!\", greeting, name);\n   }\n}\n\n\n"
    },
    {
      "Code": "4023",
      "Title": "Interfaces should not be empty",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4023",
      "Description": "Empty interfaces are usually used as a marker or a way to identify groups of types. The preferred way to achieve this is to use custom\nattributes.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n   public interface MyInterface // Noncompliant\n   {\n   }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n   public interface MyInterface\n   {\n      void Foo();\n   }\n}\n\n\n"
    },
    {
      "Code": "4022",
      "Title": "Enumerations should have \"Int32\" storage",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4022",
      "Description": "By default the storage type of an enum is Int32. In most cases it is not necessary to change this. In particular you will\nnot achieve any performance gain by using a smaller data type (e.g. Byte) and may limit future uses.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n    public enum Visibility : sbyte // Noncompliant\n    {\n        Visible = 0,\n        Invisible = 1,\n    }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n    public enum Visibility\n    {\n        Visible = 0,\n        Invisible = 1,\n    }\n}\n\n\n"
    },
    {
      "Code": "4018",
      "Title": "Generic methods should provide type parameters",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-4018",
      "Description": "The best way to determine the type of a generic method is by inference based on the type of argument that is passed to the method. This is not\npossible when a parameter type is missing from the argument list.\nNoncompliant Code Example\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void MyMethod&lt;T&gt;()  // Noncompliant\n    {\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void MyMethod&lt;T&gt;(T param)\n    {\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "3967",
      "Title": "Multidimensional arrays should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3967",
      "Description": "A jagged array is an array whose elements are arrays. It is recommended over a multidimensional array because the arrays that make up the elements\ncan be of different sizes, which avoids wasting memory space.\nNoncompliant Code Example\n\nint [,] myArray =  // Noncompliant\n    {\n        {1,2,3,4},\n        {5,6,7,0},\n        {8,0,0,0},\n        {9,0,0,0}\n    };\n// ...\nmyArray[1,1] = 0;\n\nCompliant Solution\n\nint[][] myArray =\n    {\n        new int[] {1,2,3,4},\n        new int[] {5,6,7},\n        new int[] {8},\n        new int[] {9}\n    };\n// ...\nmyArray[1][1] = 0;\n\n\n"
    },
    {
      "Code": "3962",
      "Title": "\"static readonly\" constants should be \"const\" instead",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3962",
      "Description": "The value of a static readonly field is computed at runtime while the value of a const field is calculated at compile\ntime, which improves performance.\nThis rule raises an issue when a static readonly field is initialized with a value that is computable at compile time.\nAs specified by Microsoft, the list of types that can have a constant value are:\n\n  \n    \n    \n  \n  \n    \n      C# type\n      .Net Fwk type\n    \n  \n  \n    \n      bool\n      System.Boolean\n    \n    \n      byte\n      System.Byte\n    \n    \n      sbyte\n      System.SByte\n    \n    \n      char\n      System.Char\n    \n    \n      decimal\n      System.Decimal\n    \n    \n      double\n      System.Double\n    \n    \n      float\n      System.Single\n    \n    \n      int\n      System.Int32\n    \n    \n      uint\n      System.UInt32\n    \n    \n      long\n      System.Int64\n    \n    \n      ulong\n      System.UInt64\n    \n    \n      short\n      System.Int16\n    \n    \n      ushort\n      System.UInt16\n    \n    \n      string\n      System.String\n    \n  \n\nNoncompliant Code Example\n\nnamespace myLib\n{\n  public class Foo\n  {\n    static readonly int x = 1;  // Noncompliant\n    static readonly int y = x + 4; // Noncompliant\n    static readonly string s = \"Bar\";  // Noncompliant\n  }\n}\n\nCompliant Solution\n\nnamespace myLib\n{\n  public class Foo\n  {\n    const int x = 1;\n    const int y = x + 4;\n    const string s = \"Bar\";\n  }\n}\n\n\n"
    },
    {
      "Code": "3876",
      "Title": "Strings or integral types should be used for indexers",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3876",
      "Description": "Strings and integral types are typically used as indexers. When some other type is required, it typically indicates design problems, and\npotentially a situation where a method should be used instead.\nNoncompliant Code Example\n\npublic int this[MyCustomClass index]  // Noncompliant\n{\n    // get and set accessors\n}\n\n\n"
    },
    {
      "Code": "3872",
      "Title": "Parameter names should not duplicate the names of their methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3872",
      "Description": "The name of a method should communicate what it does, and the names of its parameters should indicate how they’re used. If a method and its\nparameter have the same name it is an indication that one of these rules of thumb has been broken, if not both. Even if by some trick of language\nthat’s not the case, it is still likely to confuse callers and maintainers.\nNoncompliant Code Example\n\npublic void Login(string login)  // Noncompliant\n{\n  //...\n}\n\nCompliant Solution\n\npublic void Login(string userName)\n{\n  //...\n}\n\n\n"
    },
    {
      "Code": "3717",
      "Title": "Track use of \"NotImplementedException\"",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3717",
      "Description": "NotImplementedException is often used to mark methods which must be implemented for the overall functionality to be complete, but\nwhich the developer wants to implement later. That’s as opposed to the NotSupportedException which is thrown by methods which are\nrequired by base classes or interfaces, but which are not appropriate to the current class.\nThis rule raises an exception when NotImplementedException is thrown.\nNoncompliant Code Example\n\nvoid doTheThing()\n{\n    throw new NotImplementedException();\n}\n\nExceptions\nExceptions derived from NotImplementedException are ignored.\n\n"
    },
    {
      "Code": "3532",
      "Title": "Empty \"default\" clauses should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3532",
      "Description": "The default clause should take appropriate action. Having an empty default is a waste of keystrokes.\nNoncompliant Code Example\n\nenum Fruit\n{\n  Apple,\n  Orange,\n  Banana\n}\n\nvoid PrintName(Fruit fruit)\n{\n  switch(fruit)\n  {\n    case Fruit.Apple:\n      Console.WriteLine(\"apple\");\n      break;\n    default:  //Noncompliant\n      break;\n  }\n}\n\nCompliant Solution\n\nenum Fruit\n{\n  Apple,\n  Orange,\n  Banana\n}\n\nvoid PrintName(Fruit fruit)\n{\n  switch(fruit)\n  {\n    case Fruit.Apple:\n      Console.WriteLine(\"apple\");\n      break;\n    default:\n      throw new NotSupportedException();\n  }\n}\n\nor\n\nvoid PrintName(Fruit fruit)\n{\n  switch(fruit)\n  {\n    case Fruit.Apple:\n      Console.WriteLine(\"apple\");\n      break;\n  }\n}\n\nExceptions\ndefault clauses containing only a comment are ignored with the assumption that they are empty on purpose and the comment documents\nwhy.\n\n"
    },
    {
      "Code": "3441",
      "Title": "Redundant property names should be omitted in anonymous classes",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3441",
      "Description": "When an anonymous type’s properties are copied from properties or variables with the same names, it yields cleaner code to omit the new type’s\nproperty name and the assignment operator.\nNoncompliant Code Example\n\nvar X = 5;\n\nvar anon = new\n{\n  X = X, //Noncompliant, the new object would have the same property without the \"X =\" part.\n  Y = \"my string\"\n};\n\nCompliant Solution\n\nvar X = 5;\n\nvar anon = new\n{\n  X,\n  Y = \"my string\"\n};\n\n\n"
    },
    {
      "Code": "3257",
      "Title": "Declarations and initializations should be as concise as possible",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3257",
      "Description": "Unnecessarily verbose declarations and initializations make it harder to read the code, and should be simplified.\nSpecifically the following should be omitted when they can be inferred:\n\n   array element type \n   array size \n   new DelegateType \n   new Nullable&lt;Type&gt; \n   object or collection initializers ({}) \n   type of lambda expression parameters \n   parameter declarations of anonymous methods when the parameters are not used. \n\nNoncompliant Code Example\n\nvar l = new List&lt;int&gt;() {}; // Noncompliant, {} can be removed\nvar o = new object() {}; // Noncompliant, {} can be removed\n\nvar ints = new int[] {1, 2, 3}; // Noncompliant, int can be omitted\nints = new int[3] {1, 2, 3}; // Noncompliant, the size specification can be removed\n\nint? i = new int?(5); // Noncompliant new int? could be omitted, it can be inferred from the declaration, and there's implicit conversion from T to T?\nvar j = new int?(5);\n\nFunc&lt;int, int&gt; f1 = (int i) =&gt; 1; //Noncompliant, can be simplified\n\nclass Class\n{\n    private event EventHandler MyEvent;\n\n    public Class()\n    {\n        MyEvent += new EventHandler((a,b)=&gt;{ }); // Noncompliant, needlessly verbose\n    }\n}\n\nCompliant Solution\n\nvar l = new List&lt;int&gt;();\nvar o = new object();\n\nvar ints = new [] {1, 2, 3};\nints = new [] {1, 2, 3};\n\nint? i = 5;\nvar j = new int?(5);\n\nFunc&lt;int, int&gt; f1 = (i) =&gt; 1;\n\nclass Class\n{\n    private event EventHandler MyEvent;\n\n    public Class()\n    {\n        MyEvent += (a,b)=&gt;{ };\n    }\n}\n\n\n"
    },
    {
      "Code": "3254",
      "Title": "Default parameter values should not be passed as arguments",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3254",
      "Description": "Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability.\nNoncompliant Code Example\n\npublic void M(int x, int y=5, int z = 7) { /* ... */ }\n\n// ...\nM(1, 5); //Noncompliant, y has the default value\nM(1, z: 7); //Noncompliant, z has the default value\n\nCompliant Solution\n\npublic void M(int x, int y=5, int z = 7) { /* ... */ }\n\n// ...\nM(1);\nM(1);\n\n\n"
    },
    {
      "Code": "3253",
      "Title": "Constructor and destructor declarations should not be redundant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3253",
      "Description": "Since the compiler will automatically invoke the base type’s no-argument constructor, there’s no need to specify its invocation explicitly. Also,\nwhen only a single public parameterless constructor is defined in a class, then that constructor can be removed because the compiler\nwould generate it automatically. Similarly, empty static constructors and empty destructors are also wasted keystrokes.\nNoncompliant Code Example\n\nclass X\n{\n  public X() { } // Noncompliant\n  static X() { }  // Noncompliant\n  ~X() { } // Noncompliant\n\n  ...\n}\n\nclass Y : X\n{\n  public Y(int parameter) : base() // Noncompliant\n  {\n    /* does something with the parameter */\n  }\n}\n\nCompliant Solution\n\nclass X\n{\n  ...\n}\n\nclass Y : X\n{\n  public Y(int parameter)\n  {\n    /* does something with the parameter */\n  }\n}\n\n\n"
    },
    {
      "Code": "3242",
      "Title": "Method parameters should be declared with base types",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3242",
      "Description": "When a derived type is used as a parameter instead of the base type, it limits the uses of the method. If the additional functionality that is\nprovided in the derived type is not requires then that limitation isn’t required, and should be removed.\nThis rule raises an issue when a method declaration includes a parameter that is a derived type and accesses only members of the base type.\nNoncompliant Code Example\n\nusing System;\nusing System.IO;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void ReadStream(FileStream stream) // Noncompliant: Uses only System.IO.Stream methods\n    {\n      int a;\n      while ((a = stream.ReadByte()) != -1)\n      {\n            // Do something.\n      }\n    }\n  }\n}\n\nCompliant Solution\n\nusing System;\nusing System.IO;\n\nnamespace MyLibrary\n{\n  public class Foo\n  {\n    public void ReadStream(Stream stream)\n    {\n      int a;\n      while ((a = stream.ReadByte()) != -1)\n      {\n            // Do something.\n      }\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "3240",
      "Title": "The simplest possible condition syntax should be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3240",
      "Description": "In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means\n\n   using the ??= operator for a self-assign-if-not-null operation, \n   using the ?? operator for an assign-if-not-null operation, and \n   using the ternary operator ?: for assignment to a single variable. \n\nNoncompliant Code Example\n\nobject a = null, b = null, x;\n\nif (a != null) // Noncompliant; needlessly verbose\n{\n  x = a;\n}\nelse\n{\n  x = b;\n}\n\nx = a != null ? a : b; // Noncompliant; better but could still be simplified\n\nx = (a == null) ? new object() : a; // Noncompliant\n\nif (condition) // Noncompliant\n{\n  x = a;\n}\nelse\n{\n  x = b;\n}\n\nif (a == null)  // Noncompliant\n    a = new object();\n\nvar y = null ?? new object(); // Noncompliant\n\na = a ?? new object();  // Noncompliant for C# 8\n\nCompliant Solution\n\nobject x;\n\nx = a ?? b;\nx = a ?? b;\nx = a ?? new object();\nx = condition ? a : b;\na ??= new object();\nvar y = new object();\na ??= new object();\n\n\n"
    },
    {
      "Code": "3235",
      "Title": "Redundant parentheses should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3235",
      "Description": "Redundant parentheses are simply wasted keystrokes, and should be removed.\nNoncompliant Code Example\n\n[MyAttribute()] //Noncompliant\nclass MyClass\n{\n  public int MyProperty { get; set; }\n  public static MyClass CreateNew(int propertyValue)\n  {\n    return new MyClass() //Noncompliant\n    {\n      MyProperty = propertyValue\n    };\n  }\n}\n\nCompliant Solution\n\n[MyAttribute]\nclass MyClass\n{\n  public int MyProperty { get; set; }\n  public static MyClass CreateNew(int propertyValue)\n  {\n    return new MyClass\n    {\n      MyProperty = propertyValue\n    };\n  }\n}\n\n\n"
    },
    {
      "Code": "3234",
      "Title": "\"GC.SuppressFinalize\" should not be invoked for types without destructors",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3234",
      "Description": "GC.SuppressFinalize asks the Common Language Runtime not to call the finalizer of an object. This is useful when implementing the\ndispose pattern where object finalization is already handled in IDisposable.Dispose. However, it has no effect if there is no finalizer\ndefined in the object’s type, so using it in such cases is just confusing.\nThis rule raises an issue when GC.SuppressFinalize is called for objects of sealed types without a finalizer.\nNote: {rule:csharpsquid:S3971} is a stricter version of this rule. Typically it makes sense to activate only one of these 2\nrules.\nNoncompliant Code Example\n\nsealed class MyClass\n{\n  public void Method()\n  {\n    ...\n    GC.SuppressFinalize(this); //Noncompliant\n  }\n}\n\nCompliant Solution\n\nsealed class MyClass\n{\n  public void Method()\n  {\n    ...\n  }\n}\n\n\n"
    },
    {
      "Code": "3052",
      "Title": "Members should not be initialized to default values",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-3052",
      "Description": "The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any initialization\nvalues, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner code is better code, it’s\nconsidered poor style to do so.\nNoncompliant Code Example\n\nclass X\n{\n  public int field = 0; // Noncompliant\n  public object o = null; // Noncompliant\n  public object MyProperty { get; set; } = null; // Noncompliant\n  public event EventHandler MyEvent = null;  // Noncompliant\n}\n\nCompliant Solution\n\nclass X\n{\n  public int field;\n  public object o;\n  public object MyProperty { get; set; }\n  public event EventHandler MyEvent;\n}\n\nExceptions\nconst fields are ignored.\n\n"
    },
    {
      "Code": "2760",
      "Title": "Sequential tests should not check the same condition",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2760",
      "Description": "When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition should\nhave been checked in the second test.\nNoncompliant Code Example\n\nif (a == b)\n{\n  doTheThing(b);\n}\nif (a == b) // Noncompliant; is this really what was intended?\n{\n  doTheThing(c);\n}\n\nCompliant Solution\n\nif (a == b)\n{\n  doTheThing(b);\n  doTheThing(c);\n}\n\nor\n\nif (a == b)\n{\n  doTheThing(b);\n}\nif (b == c)\n{\n  doTheThing(c);\n}\n\nExceptions\nSince it is a common pattern to test a variable, reassign it if it fails the test, then re-test it, that pattern is ignored.\n\n"
    },
    {
      "Code": "2333",
      "Title": "Redundant modifiers should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2333",
      "Description": "Unnecessary keywords simply clutter the code and should be removed. Specifically:\n\n   partial on type declarations that are completely defined in one place \n   sealed on members of sealed classes \n   unsafe method or block inside construct already marked with unsafe, or when there are no unsafe\n  constructs in the block \n   checked and unchecked blocks with no integral-type arithmetic operations \n\nNoncompliant Code Example\n\npublic partial class MyClass // Noncompliant\n{\n  public virtual void Method()\n  {\n  }\n}\n\npublic sealed class MyOtherClass : MyClass\n{\n  public sealed override void Method() // Noncompliant\n  {\n  }\n}\n\nCompliant Solution\n\npublic class MyClass\n{\n  public virtual void Method()\n  {\n  }\n}\n\npublic sealed class MyOtherClass : MyClass\n{\n  public override void Method()\n  {\n  }\n}\n\n\n"
    },
    {
      "Code": "2325",
      "Title": "Methods and properties that don't access instance data should be static",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2325",
      "Description": "Methods and properties that don’t access instance data can be static to prevent any misunderstanding about the contract of the\nmethod.\nNoncompliant Code Example\n\npublic class Utilities\n{\n    public int MagicNum // Noncompliant\n    {\n        get\n        {\n            return 42;\n        }\n    }\n\n    private static string magicWord = \"please\";\n    public string MagicWord  // Noncompliant\n    {\n        get\n        {\n            return magicWord;\n        }\n        set\n        {\n            magicWord = value;\n        }\n  }\n\n    public int Sum(int a, int b)  // Noncompliant\n    {\n        return a + b;\n    }\n}\n\nCompliant Solution\n\npublic class Utilities\n{\n    public static int MagicNum\n    {\n        get\n        {\n            return 42;\n        }\n    }\n\n    private static string magicWord = \"please\";\n    public static string MagicWord\n    {\n        get\n        {\n            return magicWord;\n        }\n        set\n        {\n            magicWord = value;\n        }\n    }\n\n    public static int Sum(int a, int b)\n    {\n        return a + b;\n    }\n}\n\nExceptions\nMethods with the following names are excluded because they can’t be made static:\n\n   Application_AuthenticateRequest \n   Application_BeginRequest \n   Application_End \n   Application_EndRequest \n   Application_Error \n   Application_Init \n   Application_Start \n   Session_End \n   Session_Start \n\n\n"
    },
    {
      "Code": "2221",
      "Title": "\"Exception\" should not be caught when not required by called methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2221",
      "Description": "Catching System.Exception seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception\ntypes, including the ones that were not intended to be caught. To prevent any misunderstandings, the exception filters should be used. Alternatively\neach exception type should be in a separate catch block.\nNoncompliant Code Example\n\ntry\n{\n  // do something that might throw a FileNotFoundException or IOException\n}\ncatch (Exception e) // Noncompliant\n{\n  // log exception ...\n}\n\nCompliant Solution\n\ntry\n{\n  // do something\n}\ncatch (Exception e) when (e is FileNotFoundException || e is IOException)\n{\n  // do something\n}\n\nExceptions\nThe final option is to catch System.Exception and throw it in the last statement in the catch block. This is\nthe least-preferred option, as it is an old-style code, which also suffers from performance penalty compared to exception filters.\n\ntry\n{\n  // do something\n}\ncatch (Exception e)\n{\n  if (e is FileNotFoundException || e is IOException)\n  {\n    // do something\n  }\n  else\n  {\n    throw;\n  }\n}\n\nSee\n\n   MITRE, CWE-396 - Declaration of Catch for Generic Exception \n\n\n"
    },
    {
      "Code": "2156",
      "Title": "\"sealed\" classes should not have \"protected\" members",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2156",
      "Description": "The difference between private and protected visibility is that child classes can see and use protected\nmembers, but they cannot see private ones. Since a sealed class cannot have children, marking its members\nprotected is confusingly pointless.\nNoncompliant Code Example\n\npublic sealed class MySealedClass\n{\n    protected string name = \"Fred\";  // Noncompliant\n    protected void SetName(string name) // Noncompliant\n    {\n        // ...\n    }\n}\n\nCompliant Solution\n\npublic sealed class MySealedClass\n{\n    private string name = \"Fred\";\n    public void SetName(string name)\n    {\n        // ...\n    }\n}\n\n\n"
    },
    {
      "Code": "2148",
      "Title": "Underscores should be used to make large numbers readable",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-2148",
      "Description": "Beginning with C# 7, it is possible to add underscores ('_') to numeric literals to enhance readability. The addition of underscores in this manner\nhas no semantic meaning, but makes it easier for maintainers to understand the code.\nThe number of digits to the left of a decimal point needed to trigger this rule varies by base.\n\n  \n    \n    \n  \n  \n    \n      Base\n      Minimum digits\n    \n  \n  \n    \n      binary\n      9\n    \n    \n      decimal\n      6\n    \n    \n      hexadecimal\n      9\n    \n  \n\nIt is only the presence of underscores, not their spacing that is scrutinized by this rule.\nNote that this rule is automatically disabled when the project’s C# version is lower than 7.\nNoncompliant Code Example\n\nint i = 10000000;  // Noncompliant; is this 10 million or 100 million?\nint  j = 0b01101001010011011110010101011110;  // Noncompliant\nlong l = 0x7fffffffffffffffL;  // Noncompliant\n\nCompliant Solution\n\nint i = 10_000_000;\nint  j = 0b01101001_01001101_11100101_01011110;\nlong l = 0x7fff_ffff_ffff_ffffL;\n\n\n"
    },
    {
      "Code": "1858",
      "Title": "\"ToString()\" calls should not be redundant",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1858",
      "Description": "Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. Similarly, explicitly\ninvoking ToString() when the compiler would do it implicitly is also needless code-bloat.\nThis rule raises an issue when ToString() is invoked:\n\n   on a string \n   on a non-string operand to concatenation \n   on an argument to string.Format \n\nNoncompliant Code Example\n\nvar s = \"foo\";\nvar t = \"fee fie foe \" + s.ToString();  // Noncompliant\nvar someObject = new object();\nvar u = \"\" + someObject.ToString(); // Noncompliant\nvar v = string.Format(\"{0}\", someObject.ToString()); // Noncompliant\n\nCompliant Solution\n\nvar s = \"foo\";\nvar t = \"fee fie foe \" + s;\nvar someObject = new object();\nvar u = \"\" + someObject;\nvar v = string.Format(\"{0}\", someObject);\n\nExceptions\nThe rule does not report on value types, where leaving off the ToString() call would result in automatic boxing.\n\nvar v = string.Format(\"{0}\", 1.ToString());\n\n\n"
    },
    {
      "Code": "1698",
      "Title": "\"==\" should not be used when \"Equals\" is overridden",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1698",
      "Description": "Using the equality == and inequality != operators to compare two objects generally works. The operators can be\noverloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then\n== resolves to reference equality, which may result in unexpected behavior if implementing classes override Equals.\nSimilarly, when a class overrides Equals, but instances are compared with non-overloaded ==, there is a high chance that\nvalue comparison was meant instead of the reference one.\nNoncompliant Code Example\n\npublic interface IMyInterface\n{\n}\n\npublic class MyClass : IMyInterface\n{\n    public override bool Equals(object obj)\n    {\n        //...\n    }\n}\n\npublic class Program\n{\n    public static void Method(IMyInterface instance1, IMyInterface instance2)\n    {\n        if (instance1 == instance2) // Noncompliant, will do reference equality check, but was that intended? MyClass overrides Equals.\n        {\n            Console.WriteLine(\"Equal\");\n        }\n    }\n}\n\nCompliant Solution\n\npublic interface IMyInterface\n{\n}\n\npublic class MyClass : IMyInterface\n{\n    public override bool Equals(object obj)\n    {\n        //...\n    }\n}\n\npublic class Program\n{\n    public static void Method(IMyInterface instance1, IMyInterface instance2)\n    {\n        if (object.Equals(instance1, instance2)) // object.Equals checks for null and then calls the instance based Equals, so MyClass.Equals\n        {\n            Console.WriteLine(\"Equal\");\n        }\n    }\n}\n\nExceptions\nThe rule does not report on comparisons of System.Type instances and on comparisons inside Equals overrides.\nIt also does not raise an issue when one of the operands is null nor when one of the operand is cast to object (because\nin this case we want to ensure reference equality even if some == overload is present).\nSee\n\n   MITRE, CWE-595 - Comparison of Object References Instead of Object Contents \n   MITRE, CWE-597 - Use of Wrong Operator in String Comparison \n\n\n"
    },
    {
      "Code": "1694",
      "Title": "An abstract class should have both abstract and concrete methods",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1694",
      "Description": "The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be implemented by sub-classes.\nA class with no abstract methods that was made abstract purely to prevent instantiation should be converted to a concrete\nclass (i.e. remove the abstract keyword) with a protected constructor.\nA class with only abstract methods and no inheritable behavior should be converted to an interface.\nNoncompliant Code Example\n\npublic abstract class Animal //Noncompliant; should be an interface\n{\n  abstract void Move();\n  abstract void Feed();\n}\n\npublic abstract class Color //Noncompliant; should be concrete with a private constructor\n{\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  public int GetRed()\n  {\n    return red;\n  }\n}\n\nCompliant Solution\n\npublic interface Animal\n{\n  void Move();\n  void Feed();\n}\n\npublic class Color\n{\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  protected Color()\n  {}\n\n  public int GetRed()\n  {\n    return red;\n  }\n}\n\npublic abstract class Lamp\n{\n  private bool switchLamp = false;\n\n  public abstract void Glow();\n\n  public void FlipSwitch()\n  {\n    switchLamp = !switchLamp;\n    if (switchLamp)\n    {\n      Glow();\n    }\n  }\n}\n\n\n"
    },
    {
      "Code": "1659",
      "Title": "Multiple variables should not be declared on the same line",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1659",
      "Description": "Declaring multiple variable on one line is difficult to read.\nNoncompliant Code Example\n\nclass MyClass\n{\n  private int a, b; // Noncompliant\n\n  public void Method()\n  {\n    int c, d; // Noncompliant\n  }\n}\n\nCompliant Solution\n\nclass MyClass\n{\n  private int a;\n  private int b;\n\n  public void Method()\n  {\n    int c;\n    int d;\n  }\n}\n\n\n"
    },
    {
      "Code": "1449",
      "Title": "Culture should be specified for \"string\" operations",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1449",
      "Description": "string.ToLower(), ToUpper, IndexOf, LastIndexOf, and Compare are all\nculture-dependent, as are some (floating point number and DateTime-related) calls to ToString. Fortunately, all have\nvariants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the system default\nculture, possibly creating problems with international characters.\nstring.CompareTo() is also culture specific, but has no overload that takes a culture information, so instead it’s better to use\nCompareOrdinal, or Compare with culture.\nCalls without a culture may work fine in the system’s \"home\" environment, but break in ways that are extremely difficult to diagnose for customers\nwho use different encodings. Such bugs can be nearly, if not completely, impossible to reproduce when it’s time to fix them.\nNoncompliant Code Example\n\nvar lowered = someString.ToLower(); //Noncompliant\n\nCompliant Solution\n\nvar lowered = someString.ToLower(CultureInfo.InvariantCulture);\n\nor\n\nvar lowered = someString.ToLowerInvariant();\n\n\n"
    },
    {
      "Code": "1301",
      "Title": "\"switch\" statements should have at least 3 \"case\" clauses",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1301",
      "Description": "switch statements and expressions are useful when there are many different cases depending on the value of the same expression.\nWhen a switch statement or expression is simple enough, the code will be more readable with a single if,\nif-else or ternary conditional operator.\nNoncompliant Code Example\n\nswitch (variable)\n{\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n\nvar foo = variable switch\n{\n  0 =&gt; doSomething(),\n  _ =&gt; doSomethingElse(),\n}\n\nCompliant Solution\n\nif (variable == 0)\n{\n  doSomething();\n}\nelse\n{\n  doSomethingElse();\n}\n\nvar foo = variable == 0\n  ? doSomething()\n  : doSomethingElse();\n\n\n"
    },
    {
      "Code": "1227",
      "Title": "break statements should not be used except for switch cases",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1227",
      "Description": "break; is an unstructured control flow statement which makes code harder to read.\nIdeally, every loop should have a single termination condition.\nNoncompliant Code Example\n\nint i = 0;\nwhile (true)\n{\n  if (i == 10)\n  {\n    break;      // Non-Compliant\n  }\n\n  Console.WriteLine(i);\n  i++;\n}\n\nCompliant Solution\n\nint i = 0;\nwhile (i != 10) // Compliant\n{\n  Console.WriteLine(i);\n  i++;\n}\n\n\n"
    },
    {
      "Code": "1192",
      "Title": "String literals should not be duplicated",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1192",
      "Description": "Duplicated string literals make the process of refactoring error-prone, since you must be sure to update all occurrences.\nOn the other hand, constants can be referenced from many places, but only need to be updated in a single place.\nNoncompliant Code Example\n\npublic class Foo\n{\n    private string name = \"foobar\"; // Noncompliant\n\n    public string DefaultName { get; } = \"foobar\"; // Noncompliant\n\n    public Foo(string value = \"foobar\") // Noncompliant\n    {\n        var something = value ?? \"foobar\"; // Noncompliant\n    }\n}\n\nCompliant Solution\n\npublic class Foo\n{\n    private const string Foobar = \"foobar\";\n\n    private string name = Foobar;\n\n    public string DefaultName { get; } = Foobar;\n\n    public Foo(string value = Foobar)\n    {\n        var something = value ?? Foobar;\n    }\n}\n\nExceptions\nThe following are ignored:\n\n   literals with fewer than 5 characters \n   literals matching one of the parameter names \n   literals used in attributes \n\n\n"
    },
    {
      "Code": "113",
      "Title": "Files should contain an empty newline at the end",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-113",
      "Description": "Some tools work better when files end with an empty line.\nThis rule simply generates an issue if it is missing.\nFor example, a Git diff looks like this if the empty line is missing at the end of the file:\n\n+class Test\n+{\n+}\n\\ No newline at end of file\n\n\n"
    },
    {
      "Code": "1128",
      "Title": "Unused \"using\" should be removed",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1128",
      "Description": "Although unnecessary using won’t change anything to the produced application, removing them:\n\n   Will help readability and maintenance. \n   Will help reduce the number of items in the IDE auto-completion list when coding. \n   May avoid some name collisions. \n   May improve compilation time because the compiler has fewer namespaces to look-up when it resolves types. \n   The build will fail if this namespace is removed from the project. \n\nNoncompliant Code Example\n\nusing System.Collections.Generic; // Noncompliant - unnecessary using\n\nnamespace Foo\n{\n    public class Bar\n    {\n        public Bar(string path)\n        {\n            File.ReadAllLines(path);\n        }\n    }\n}\n\nCompliant Solution\n\nusing System.IO;\n\nnamespace Foo\n{\n    public class Bar\n    {\n        public Bar(string path)\n        {\n            File.ReadAllLines(path);\n        }\n    }\n}\n\n\n"
    },
    {
      "Code": "1109",
      "Title": "A close curly brace should be located at the beginning of a line",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1109",
      "Description": "Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the\nbeginning of a line.\nNoncompliant Code Example\n\nif(condition)\n{\n  doSomething();}\n\nCompliant Solution\n\nif(condition)\n{\n  doSomething();\n}\n\nExceptions\nWhen blocks are inlined (open and close curly braces on the same line), no issue is triggered.\n\nif(condition) {doSomething();}\n\n\n"
    },
    {
      "Code": "105",
      "Title": "Tabulation characters should not be used",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-105",
      "Description": "Developers should not need to configure the tab width of their text editors in order to be able to read source code.\nSo the use of the tabulation character must be banned.\n\n"
    },
    {
      "Code": "100",
      "Title": "Methods and properties should be named in PascalCase",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-100",
      "Description": "Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not method and property names are PascalCased. To\nreduce noise, two consecutive upper case characters are allowed unless they form the whole name. So, MyXMethod is compliant, but\nXM on its own is not.\nNoncompliant Code Example\n\npublic int doSomething() {...}\n\nCompliant Solution\n\npublic int DoSomething() {...}\n\nExceptions\n\n   The rule ignores members in types that are marked with ComImportAttribute or InterfaceTypeAttribute. \n   The rule ignores extern methods. \n   The rule allows for two-letter acronyms in which both letters are capitalized, as shown in the following identifier:\n  ExecuteOnUIThread. \n   Furthermore, when '_' character is found in a name, the camel casing is not enforced. \n\n\nvoid My_method(){...} // valid\nvoid My_method_(){...} // invalid, leading and trailing underscores are reported\n\nSee\nMicrosoft Capitalization\nConventions\n\n"
    },
    {
      "Code": "1309",
      "Title": "Track uses of in-source issue suppressions",
      "Link": "https://rules.sonarsource.com/csharp/RSPEC-1309",
      "Description": "This rule allows you to track the usage of the SuppressMessage attributes and #pragma warning disable mechanism.\nNoncompliant Code Example\n\n[SuppressMessage(\"\", \"S100\")]\n...\n\n#pragma warning disable S100\n...\n#pragma warning restore S100\n\n\n"
    }
  ]
}